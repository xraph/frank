// Copyright 2023-present XRaph LLC. All rights reserved.
// This source code is licensed under the XRaph LLC license found
// in the LICENSE file in the root directory of this source tree.
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/rs/xid"
	"github.com/xraph/frank/ent/activity"
	"github.com/xraph/frank/ent/apikey"
	"github.com/xraph/frank/ent/apikeyactivity"
	"github.com/xraph/frank/ent/audit"
	"github.com/xraph/frank/ent/emailtemplate"
	"github.com/xraph/frank/ent/featureflag"
	"github.com/xraph/frank/ent/identityprovider"
	"github.com/xraph/frank/ent/membership"
	"github.com/xraph/frank/ent/mfa"
	"github.com/xraph/frank/ent/oauthauthorization"
	"github.com/xraph/frank/ent/oauthclient"
	"github.com/xraph/frank/ent/oauthscope"
	"github.com/xraph/frank/ent/oauthtoken"
	"github.com/xraph/frank/ent/organization"
	"github.com/xraph/frank/ent/organizationfeature"
	"github.com/xraph/frank/ent/organizationprovider"
	"github.com/xraph/frank/ent/passkey"
	"github.com/xraph/frank/ent/permission"
	"github.com/xraph/frank/ent/permissiondependency"
	"github.com/xraph/frank/ent/predicate"
	"github.com/xraph/frank/ent/providertemplate"
	"github.com/xraph/frank/ent/role"
	"github.com/xraph/frank/ent/session"
	"github.com/xraph/frank/ent/smstemplate"
	"github.com/xraph/frank/ent/ssostate"
	"github.com/xraph/frank/ent/user"
	"github.com/xraph/frank/ent/userpermission"
	"github.com/xraph/frank/ent/userrole"
	"github.com/xraph/frank/ent/verification"
	"github.com/xraph/frank/ent/webhook"
	"github.com/xraph/frank/ent/webhookevent"
	"github.com/xraph/frank/pkg/common"
	"github.com/xraph/frank/pkg/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity             = "Activity"
	TypeApiKey               = "ApiKey"
	TypeApiKeyActivity       = "ApiKeyActivity"
	TypeAudit                = "Audit"
	TypeEmailTemplate        = "EmailTemplate"
	TypeFeatureFlag          = "FeatureFlag"
	TypeIdentityProvider     = "IdentityProvider"
	TypeMFA                  = "MFA"
	TypeMembership           = "Membership"
	TypeOAuthAuthorization   = "OAuthAuthorization"
	TypeOAuthClient          = "OAuthClient"
	TypeOAuthScope           = "OAuthScope"
	TypeOAuthToken           = "OAuthToken"
	TypeOrganization         = "Organization"
	TypeOrganizationFeature  = "OrganizationFeature"
	TypeOrganizationProvider = "OrganizationProvider"
	TypePasskey              = "Passkey"
	TypePermission           = "Permission"
	TypePermissionDependency = "PermissionDependency"
	TypeProviderTemplate     = "ProviderTemplate"
	TypeRole                 = "Role"
	TypeSMSTemplate          = "SMSTemplate"
	TypeSSOState             = "SSOState"
	TypeSession              = "Session"
	TypeUser                 = "User"
	TypeUserPermission       = "UserPermission"
	TypeUserRole             = "UserRole"
	TypeVerification         = "Verification"
	TypeWebhook              = "Webhook"
	TypeWebhookEvent         = "WebhookEvent"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	resource_type       *model.ResourceType
	resource_id         *xid.ID
	action              *string
	category            *string
	source              *string
	endpoint            *string
	method              *string
	status_code         *int
	addstatus_code      *int
	response_time       *int
	addresponse_time    *int
	ip_address          *string
	user_agent          *string
	location            *string
	success             *bool
	error               *string
	error_code          *string
	size                *int
	addsize             *int
	count               *int
	addcount            *int
	value               *float64
	addvalue            *float64
	timestamp           *time.Time
	expires_at          *time.Time
	metadata            *map[string]interface{}
	tags                *[]string
	appendtags          []string
	clearedFields       map[string]struct{}
	user                *xid.ID
	cleareduser         bool
	organization        *xid.ID
	clearedorganization bool
	session             *xid.ID
	clearedsession      bool
	done                bool
	oldValue            func(context.Context) (*Activity, error)
	predicates          []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id xid.ID) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Activity entities.
func (m *ActivityMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Activity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResourceType sets the "resource_type" field.
func (m *ActivityMutation) SetResourceType(mt model.ResourceType) {
	m.resource_type = &mt
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *ActivityMutation) ResourceType() (r model.ResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldResourceType(ctx context.Context) (v model.ResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *ActivityMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ActivityMutation) SetResourceID(x xid.ID) {
	m.resource_id = &x
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ActivityMutation) ResourceID() (r xid.ID, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldResourceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ActivityMutation) ResetResourceID() {
	m.resource_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ActivityMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ActivityMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ActivityMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[activity.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ActivityMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[activity.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ActivityMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, activity.FieldUserID)
}

// SetOrganizationID sets the "organization_id" field.
func (m *ActivityMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ActivityMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *ActivityMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[activity.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *ActivityMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[activity.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ActivityMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, activity.FieldOrganizationID)
}

// SetSessionID sets the "session_id" field.
func (m *ActivityMutation) SetSessionID(x xid.ID) {
	m.session = &x
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *ActivityMutation) SessionID() (r xid.ID, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSessionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *ActivityMutation) ClearSessionID() {
	m.session = nil
	m.clearedFields[activity.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *ActivityMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[activity.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *ActivityMutation) ResetSessionID() {
	m.session = nil
	delete(m.clearedFields, activity.FieldSessionID)
}

// SetAction sets the "action" field.
func (m *ActivityMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ActivityMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ActivityMutation) ResetAction() {
	m.action = nil
}

// SetCategory sets the "category" field.
func (m *ActivityMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ActivityMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ActivityMutation) ResetCategory() {
	m.category = nil
}

// SetSource sets the "source" field.
func (m *ActivityMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ActivityMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ActivityMutation) ClearSource() {
	m.source = nil
	m.clearedFields[activity.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ActivityMutation) SourceCleared() bool {
	_, ok := m.clearedFields[activity.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ActivityMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, activity.FieldSource)
}

// SetEndpoint sets the "endpoint" field.
func (m *ActivityMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ActivityMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ClearEndpoint clears the value of the "endpoint" field.
func (m *ActivityMutation) ClearEndpoint() {
	m.endpoint = nil
	m.clearedFields[activity.FieldEndpoint] = struct{}{}
}

// EndpointCleared returns if the "endpoint" field was cleared in this mutation.
func (m *ActivityMutation) EndpointCleared() bool {
	_, ok := m.clearedFields[activity.FieldEndpoint]
	return ok
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ActivityMutation) ResetEndpoint() {
	m.endpoint = nil
	delete(m.clearedFields, activity.FieldEndpoint)
}

// SetMethod sets the "method" field.
func (m *ActivityMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *ActivityMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *ActivityMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[activity.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *ActivityMutation) MethodCleared() bool {
	_, ok := m.clearedFields[activity.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *ActivityMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, activity.FieldMethod)
}

// SetStatusCode sets the "status_code" field.
func (m *ActivityMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *ActivityMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *ActivityMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *ActivityMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *ActivityMutation) ClearStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	m.clearedFields[activity.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *ActivityMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[activity.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *ActivityMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	delete(m.clearedFields, activity.FieldStatusCode)
}

// SetResponseTime sets the "response_time" field.
func (m *ActivityMutation) SetResponseTime(i int) {
	m.response_time = &i
	m.addresponse_time = nil
}

// ResponseTime returns the value of the "response_time" field in the mutation.
func (m *ActivityMutation) ResponseTime() (r int, exists bool) {
	v := m.response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTime returns the old "response_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldResponseTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTime: %w", err)
	}
	return oldValue.ResponseTime, nil
}

// AddResponseTime adds i to the "response_time" field.
func (m *ActivityMutation) AddResponseTime(i int) {
	if m.addresponse_time != nil {
		*m.addresponse_time += i
	} else {
		m.addresponse_time = &i
	}
}

// AddedResponseTime returns the value that was added to the "response_time" field in this mutation.
func (m *ActivityMutation) AddedResponseTime() (r int, exists bool) {
	v := m.addresponse_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseTime clears the value of the "response_time" field.
func (m *ActivityMutation) ClearResponseTime() {
	m.response_time = nil
	m.addresponse_time = nil
	m.clearedFields[activity.FieldResponseTime] = struct{}{}
}

// ResponseTimeCleared returns if the "response_time" field was cleared in this mutation.
func (m *ActivityMutation) ResponseTimeCleared() bool {
	_, ok := m.clearedFields[activity.FieldResponseTime]
	return ok
}

// ResetResponseTime resets all changes to the "response_time" field.
func (m *ActivityMutation) ResetResponseTime() {
	m.response_time = nil
	m.addresponse_time = nil
	delete(m.clearedFields, activity.FieldResponseTime)
}

// SetIPAddress sets the "ip_address" field.
func (m *ActivityMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ActivityMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *ActivityMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[activity.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *ActivityMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[activity.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ActivityMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, activity.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *ActivityMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *ActivityMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *ActivityMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[activity.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *ActivityMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[activity.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *ActivityMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, activity.FieldUserAgent)
}

// SetLocation sets the "location" field.
func (m *ActivityMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ActivityMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ActivityMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[activity.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ActivityMutation) LocationCleared() bool {
	_, ok := m.clearedFields[activity.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ActivityMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, activity.FieldLocation)
}

// SetSuccess sets the "success" field.
func (m *ActivityMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *ActivityMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *ActivityMutation) ResetSuccess() {
	m.success = nil
}

// SetError sets the "error" field.
func (m *ActivityMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ActivityMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ActivityMutation) ClearError() {
	m.error = nil
	m.clearedFields[activity.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ActivityMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[activity.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ActivityMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, activity.FieldError)
}

// SetErrorCode sets the "error_code" field.
func (m *ActivityMutation) SetErrorCode(s string) {
	m.error_code = &s
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *ActivityMutation) ErrorCode() (r string, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *ActivityMutation) ClearErrorCode() {
	m.error_code = nil
	m.clearedFields[activity.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *ActivityMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[activity.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *ActivityMutation) ResetErrorCode() {
	m.error_code = nil
	delete(m.clearedFields, activity.FieldErrorCode)
}

// SetSize sets the "size" field.
func (m *ActivityMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *ActivityMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *ActivityMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *ActivityMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *ActivityMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[activity.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *ActivityMutation) SizeCleared() bool {
	_, ok := m.clearedFields[activity.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *ActivityMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, activity.FieldSize)
}

// SetCount sets the "count" field.
func (m *ActivityMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *ActivityMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *ActivityMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *ActivityMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *ActivityMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[activity.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *ActivityMutation) CountCleared() bool {
	_, ok := m.clearedFields[activity.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *ActivityMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, activity.FieldCount)
}

// SetValue sets the "value" field.
func (m *ActivityMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *ActivityMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *ActivityMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *ActivityMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ClearValue clears the value of the "value" field.
func (m *ActivityMutation) ClearValue() {
	m.value = nil
	m.addvalue = nil
	m.clearedFields[activity.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *ActivityMutation) ValueCleared() bool {
	_, ok := m.clearedFields[activity.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *ActivityMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
	delete(m.clearedFields, activity.FieldValue)
}

// SetTimestamp sets the "timestamp" field.
func (m *ActivityMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ActivityMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ActivityMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ActivityMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ActivityMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ActivityMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[activity.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ActivityMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ActivityMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, activity.FieldExpiresAt)
}

// SetMetadata sets the "metadata" field.
func (m *ActivityMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ActivityMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ActivityMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[activity.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ActivityMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[activity.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ActivityMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, activity.FieldMetadata)
}

// SetTags sets the "tags" field.
func (m *ActivityMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ActivityMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ActivityMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ActivityMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ActivityMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[activity.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ActivityMutation) TagsCleared() bool {
	_, ok := m.clearedFields[activity.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ActivityMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, activity.FieldTags)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ActivityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[activity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ActivityMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ActivityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ActivityMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[activity.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ActivityMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ActivityMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearSession clears the "session" edge to the Session entity.
func (m *ActivityMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[activity.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *ActivityMutation) SessionCleared() bool {
	return m.SessionIDCleared() || m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) SessionIDs() (ids []xid.ID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *ActivityMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Activity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.resource_type != nil {
		fields = append(fields, activity.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, activity.FieldResourceID)
	}
	if m.user != nil {
		fields = append(fields, activity.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, activity.FieldOrganizationID)
	}
	if m.session != nil {
		fields = append(fields, activity.FieldSessionID)
	}
	if m.action != nil {
		fields = append(fields, activity.FieldAction)
	}
	if m.category != nil {
		fields = append(fields, activity.FieldCategory)
	}
	if m.source != nil {
		fields = append(fields, activity.FieldSource)
	}
	if m.endpoint != nil {
		fields = append(fields, activity.FieldEndpoint)
	}
	if m.method != nil {
		fields = append(fields, activity.FieldMethod)
	}
	if m.status_code != nil {
		fields = append(fields, activity.FieldStatusCode)
	}
	if m.response_time != nil {
		fields = append(fields, activity.FieldResponseTime)
	}
	if m.ip_address != nil {
		fields = append(fields, activity.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, activity.FieldUserAgent)
	}
	if m.location != nil {
		fields = append(fields, activity.FieldLocation)
	}
	if m.success != nil {
		fields = append(fields, activity.FieldSuccess)
	}
	if m.error != nil {
		fields = append(fields, activity.FieldError)
	}
	if m.error_code != nil {
		fields = append(fields, activity.FieldErrorCode)
	}
	if m.size != nil {
		fields = append(fields, activity.FieldSize)
	}
	if m.count != nil {
		fields = append(fields, activity.FieldCount)
	}
	if m.value != nil {
		fields = append(fields, activity.FieldValue)
	}
	if m.timestamp != nil {
		fields = append(fields, activity.FieldTimestamp)
	}
	if m.expires_at != nil {
		fields = append(fields, activity.FieldExpiresAt)
	}
	if m.metadata != nil {
		fields = append(fields, activity.FieldMetadata)
	}
	if m.tags != nil {
		fields = append(fields, activity.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldResourceType:
		return m.ResourceType()
	case activity.FieldResourceID:
		return m.ResourceID()
	case activity.FieldUserID:
		return m.UserID()
	case activity.FieldOrganizationID:
		return m.OrganizationID()
	case activity.FieldSessionID:
		return m.SessionID()
	case activity.FieldAction:
		return m.Action()
	case activity.FieldCategory:
		return m.Category()
	case activity.FieldSource:
		return m.Source()
	case activity.FieldEndpoint:
		return m.Endpoint()
	case activity.FieldMethod:
		return m.Method()
	case activity.FieldStatusCode:
		return m.StatusCode()
	case activity.FieldResponseTime:
		return m.ResponseTime()
	case activity.FieldIPAddress:
		return m.IPAddress()
	case activity.FieldUserAgent:
		return m.UserAgent()
	case activity.FieldLocation:
		return m.Location()
	case activity.FieldSuccess:
		return m.Success()
	case activity.FieldError:
		return m.Error()
	case activity.FieldErrorCode:
		return m.ErrorCode()
	case activity.FieldSize:
		return m.Size()
	case activity.FieldCount:
		return m.Count()
	case activity.FieldValue:
		return m.Value()
	case activity.FieldTimestamp:
		return m.Timestamp()
	case activity.FieldExpiresAt:
		return m.ExpiresAt()
	case activity.FieldMetadata:
		return m.Metadata()
	case activity.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldResourceType:
		return m.OldResourceType(ctx)
	case activity.FieldResourceID:
		return m.OldResourceID(ctx)
	case activity.FieldUserID:
		return m.OldUserID(ctx)
	case activity.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case activity.FieldSessionID:
		return m.OldSessionID(ctx)
	case activity.FieldAction:
		return m.OldAction(ctx)
	case activity.FieldCategory:
		return m.OldCategory(ctx)
	case activity.FieldSource:
		return m.OldSource(ctx)
	case activity.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case activity.FieldMethod:
		return m.OldMethod(ctx)
	case activity.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case activity.FieldResponseTime:
		return m.OldResponseTime(ctx)
	case activity.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case activity.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case activity.FieldLocation:
		return m.OldLocation(ctx)
	case activity.FieldSuccess:
		return m.OldSuccess(ctx)
	case activity.FieldError:
		return m.OldError(ctx)
	case activity.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case activity.FieldSize:
		return m.OldSize(ctx)
	case activity.FieldCount:
		return m.OldCount(ctx)
	case activity.FieldValue:
		return m.OldValue(ctx)
	case activity.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case activity.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case activity.FieldMetadata:
		return m.OldMetadata(ctx)
	case activity.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldResourceType:
		v, ok := value.(model.ResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case activity.FieldResourceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case activity.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case activity.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case activity.FieldSessionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case activity.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case activity.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case activity.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case activity.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case activity.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case activity.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case activity.FieldResponseTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTime(v)
		return nil
	case activity.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case activity.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case activity.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case activity.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case activity.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case activity.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case activity.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case activity.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case activity.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case activity.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case activity.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case activity.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case activity.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_code != nil {
		fields = append(fields, activity.FieldStatusCode)
	}
	if m.addresponse_time != nil {
		fields = append(fields, activity.FieldResponseTime)
	}
	if m.addsize != nil {
		fields = append(fields, activity.FieldSize)
	}
	if m.addcount != nil {
		fields = append(fields, activity.FieldCount)
	}
	if m.addvalue != nil {
		fields = append(fields, activity.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldStatusCode:
		return m.AddedStatusCode()
	case activity.FieldResponseTime:
		return m.AddedResponseTime()
	case activity.FieldSize:
		return m.AddedSize()
	case activity.FieldCount:
		return m.AddedCount()
	case activity.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	case activity.FieldResponseTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseTime(v)
		return nil
	case activity.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case activity.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case activity.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldUserID) {
		fields = append(fields, activity.FieldUserID)
	}
	if m.FieldCleared(activity.FieldOrganizationID) {
		fields = append(fields, activity.FieldOrganizationID)
	}
	if m.FieldCleared(activity.FieldSessionID) {
		fields = append(fields, activity.FieldSessionID)
	}
	if m.FieldCleared(activity.FieldSource) {
		fields = append(fields, activity.FieldSource)
	}
	if m.FieldCleared(activity.FieldEndpoint) {
		fields = append(fields, activity.FieldEndpoint)
	}
	if m.FieldCleared(activity.FieldMethod) {
		fields = append(fields, activity.FieldMethod)
	}
	if m.FieldCleared(activity.FieldStatusCode) {
		fields = append(fields, activity.FieldStatusCode)
	}
	if m.FieldCleared(activity.FieldResponseTime) {
		fields = append(fields, activity.FieldResponseTime)
	}
	if m.FieldCleared(activity.FieldIPAddress) {
		fields = append(fields, activity.FieldIPAddress)
	}
	if m.FieldCleared(activity.FieldUserAgent) {
		fields = append(fields, activity.FieldUserAgent)
	}
	if m.FieldCleared(activity.FieldLocation) {
		fields = append(fields, activity.FieldLocation)
	}
	if m.FieldCleared(activity.FieldError) {
		fields = append(fields, activity.FieldError)
	}
	if m.FieldCleared(activity.FieldErrorCode) {
		fields = append(fields, activity.FieldErrorCode)
	}
	if m.FieldCleared(activity.FieldSize) {
		fields = append(fields, activity.FieldSize)
	}
	if m.FieldCleared(activity.FieldCount) {
		fields = append(fields, activity.FieldCount)
	}
	if m.FieldCleared(activity.FieldValue) {
		fields = append(fields, activity.FieldValue)
	}
	if m.FieldCleared(activity.FieldExpiresAt) {
		fields = append(fields, activity.FieldExpiresAt)
	}
	if m.FieldCleared(activity.FieldMetadata) {
		fields = append(fields, activity.FieldMetadata)
	}
	if m.FieldCleared(activity.FieldTags) {
		fields = append(fields, activity.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldUserID:
		m.ClearUserID()
		return nil
	case activity.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case activity.FieldSessionID:
		m.ClearSessionID()
		return nil
	case activity.FieldSource:
		m.ClearSource()
		return nil
	case activity.FieldEndpoint:
		m.ClearEndpoint()
		return nil
	case activity.FieldMethod:
		m.ClearMethod()
		return nil
	case activity.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case activity.FieldResponseTime:
		m.ClearResponseTime()
		return nil
	case activity.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case activity.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case activity.FieldLocation:
		m.ClearLocation()
		return nil
	case activity.FieldError:
		m.ClearError()
		return nil
	case activity.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case activity.FieldSize:
		m.ClearSize()
		return nil
	case activity.FieldCount:
		m.ClearCount()
		return nil
	case activity.FieldValue:
		m.ClearValue()
		return nil
	case activity.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case activity.FieldMetadata:
		m.ClearMetadata()
		return nil
	case activity.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldResourceType:
		m.ResetResourceType()
		return nil
	case activity.FieldResourceID:
		m.ResetResourceID()
		return nil
	case activity.FieldUserID:
		m.ResetUserID()
		return nil
	case activity.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case activity.FieldSessionID:
		m.ResetSessionID()
		return nil
	case activity.FieldAction:
		m.ResetAction()
		return nil
	case activity.FieldCategory:
		m.ResetCategory()
		return nil
	case activity.FieldSource:
		m.ResetSource()
		return nil
	case activity.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case activity.FieldMethod:
		m.ResetMethod()
		return nil
	case activity.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case activity.FieldResponseTime:
		m.ResetResponseTime()
		return nil
	case activity.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case activity.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case activity.FieldLocation:
		m.ResetLocation()
		return nil
	case activity.FieldSuccess:
		m.ResetSuccess()
		return nil
	case activity.FieldError:
		m.ResetError()
		return nil
	case activity.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case activity.FieldSize:
		m.ResetSize()
		return nil
	case activity.FieldCount:
		m.ResetCount()
		return nil
	case activity.FieldValue:
		m.ResetValue()
		return nil
	case activity.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case activity.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case activity.FieldMetadata:
		m.ResetMetadata()
		return nil
	case activity.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, activity.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, activity.EdgeOrganization)
	}
	if m.session != nil {
		edges = append(edges, activity.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, activity.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, activity.EdgeOrganization)
	}
	if m.clearedsession {
		edges = append(edges, activity.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeUser:
		return m.cleareduser
	case activity.EdgeOrganization:
		return m.clearedorganization
	case activity.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeUser:
		m.ClearUser()
		return nil
	case activity.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case activity.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeUser:
		m.ResetUser()
		return nil
	case activity.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case activity.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// ApiKeyMutation represents an operation that mutates the ApiKey nodes in the graph.
type ApiKeyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	public_key          *string
	secret_key          *string
	hashed_secret_key   *string
	key                 *string
	hashed_key          *string
	_type               *model.APIKeyType
	environment         *model.Environment
	active              *bool
	permissions         *[]string
	appendpermissions   []string
	scopes              *[]string
	appendscopes        []string
	ip_whitelist        *[]string
	appendip_whitelist  []string
	rate_limits         *common.APIKeyRateLimits
	metadata            *map[string]interface{}
	last_used           *time.Time
	expires_at          *time.Time
	clearedFields       map[string]struct{}
	user                *xid.ID
	cleareduser         bool
	organization        *xid.ID
	clearedorganization bool
	activities          map[xid.ID]struct{}
	removedactivities   map[xid.ID]struct{}
	clearedactivities   bool
	done                bool
	oldValue            func(context.Context) (*ApiKey, error)
	predicates          []predicate.ApiKey
}

var _ ent.Mutation = (*ApiKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*ApiKeyMutation)

// newApiKeyMutation creates new mutation for the ApiKey entity.
func newApiKeyMutation(c config, op Op, opts ...apikeyOption) *ApiKeyMutation {
	m := &ApiKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeApiKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiKeyID sets the ID field of the mutation.
func withApiKeyID(id xid.ID) apikeyOption {
	return func(m *ApiKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiKey
		)
		m.oldValue = func(ctx context.Context) (*ApiKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiKey sets the old ApiKey of the mutation.
func withApiKey(node *ApiKey) apikeyOption {
	return func(m *ApiKeyMutation) {
		m.oldValue = func(context.Context) (*ApiKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiKey entities.
func (m *ApiKeyMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiKeyMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiKeyMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApiKeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApiKeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApiKeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apikey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApiKeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApiKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apikey.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ApiKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiKeyMutation) ResetName() {
	m.name = nil
}

// SetPublicKey sets the "public_key" field.
func (m *ApiKeyMutation) SetPublicKey(s string) {
	m.public_key = &s
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *ApiKeyMutation) PublicKey() (r string, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *ApiKeyMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetSecretKey sets the "secret_key" field.
func (m *ApiKeyMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *ApiKeyMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *ApiKeyMutation) ResetSecretKey() {
	m.secret_key = nil
}

// SetHashedSecretKey sets the "hashed_secret_key" field.
func (m *ApiKeyMutation) SetHashedSecretKey(s string) {
	m.hashed_secret_key = &s
}

// HashedSecretKey returns the value of the "hashed_secret_key" field in the mutation.
func (m *ApiKeyMutation) HashedSecretKey() (r string, exists bool) {
	v := m.hashed_secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedSecretKey returns the old "hashed_secret_key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldHashedSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedSecretKey: %w", err)
	}
	return oldValue.HashedSecretKey, nil
}

// ResetHashedSecretKey resets all changes to the "hashed_secret_key" field.
func (m *ApiKeyMutation) ResetHashedSecretKey() {
	m.hashed_secret_key = nil
}

// SetKey sets the "key" field.
func (m *ApiKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ApiKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *ApiKeyMutation) ClearKey() {
	m.key = nil
	m.clearedFields[apikey.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *ApiKeyMutation) KeyCleared() bool {
	_, ok := m.clearedFields[apikey.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *ApiKeyMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, apikey.FieldKey)
}

// SetHashedKey sets the "hashed_key" field.
func (m *ApiKeyMutation) SetHashedKey(s string) {
	m.hashed_key = &s
}

// HashedKey returns the value of the "hashed_key" field in the mutation.
func (m *ApiKeyMutation) HashedKey() (r string, exists bool) {
	v := m.hashed_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedKey returns the old "hashed_key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldHashedKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedKey: %w", err)
	}
	return oldValue.HashedKey, nil
}

// ClearHashedKey clears the value of the "hashed_key" field.
func (m *ApiKeyMutation) ClearHashedKey() {
	m.hashed_key = nil
	m.clearedFields[apikey.FieldHashedKey] = struct{}{}
}

// HashedKeyCleared returns if the "hashed_key" field was cleared in this mutation.
func (m *ApiKeyMutation) HashedKeyCleared() bool {
	_, ok := m.clearedFields[apikey.FieldHashedKey]
	return ok
}

// ResetHashedKey resets all changes to the "hashed_key" field.
func (m *ApiKeyMutation) ResetHashedKey() {
	m.hashed_key = nil
	delete(m.clearedFields, apikey.FieldHashedKey)
}

// SetUserID sets the "user_id" field.
func (m *ApiKeyMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiKeyMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApiKeyMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApiKeyMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiKeyMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, apikey.FieldUserID)
}

// SetOrganizationID sets the "organization_id" field.
func (m *ApiKeyMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ApiKeyMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *ApiKeyMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[apikey.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *ApiKeyMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ApiKeyMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, apikey.FieldOrganizationID)
}

// SetType sets the "type" field.
func (m *ApiKeyMutation) SetType(mkt model.APIKeyType) {
	m._type = &mkt
}

// GetType returns the value of the "type" field in the mutation.
func (m *ApiKeyMutation) GetType() (r model.APIKeyType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldType(ctx context.Context) (v model.APIKeyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ApiKeyMutation) ResetType() {
	m._type = nil
}

// SetEnvironment sets the "environment" field.
func (m *ApiKeyMutation) SetEnvironment(value model.Environment) {
	m.environment = &value
}

// Environment returns the value of the "environment" field in the mutation.
func (m *ApiKeyMutation) Environment() (r model.Environment, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironment returns the old "environment" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldEnvironment(ctx context.Context) (v model.Environment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironment: %w", err)
	}
	return oldValue.Environment, nil
}

// ResetEnvironment resets all changes to the "environment" field.
func (m *ApiKeyMutation) ResetEnvironment() {
	m.environment = nil
}

// SetActive sets the "active" field.
func (m *ApiKeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ApiKeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ApiKeyMutation) ResetActive() {
	m.active = nil
}

// SetPermissions sets the "permissions" field.
func (m *ApiKeyMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *ApiKeyMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *ApiKeyMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *ApiKeyMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ClearPermissions clears the value of the "permissions" field.
func (m *ApiKeyMutation) ClearPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	m.clearedFields[apikey.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *ApiKeyMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[apikey.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *ApiKeyMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	delete(m.clearedFields, apikey.FieldPermissions)
}

// SetScopes sets the "scopes" field.
func (m *ApiKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ApiKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ApiKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ApiKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *ApiKeyMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apikey.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *ApiKeyMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ApiKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apikey.FieldScopes)
}

// SetIPWhitelist sets the "ip_whitelist" field.
func (m *ApiKeyMutation) SetIPWhitelist(s []string) {
	m.ip_whitelist = &s
	m.appendip_whitelist = nil
}

// IPWhitelist returns the value of the "ip_whitelist" field in the mutation.
func (m *ApiKeyMutation) IPWhitelist() (r []string, exists bool) {
	v := m.ip_whitelist
	if v == nil {
		return
	}
	return *v, true
}

// OldIPWhitelist returns the old "ip_whitelist" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldIPWhitelist(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPWhitelist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPWhitelist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPWhitelist: %w", err)
	}
	return oldValue.IPWhitelist, nil
}

// AppendIPWhitelist adds s to the "ip_whitelist" field.
func (m *ApiKeyMutation) AppendIPWhitelist(s []string) {
	m.appendip_whitelist = append(m.appendip_whitelist, s...)
}

// AppendedIPWhitelist returns the list of values that were appended to the "ip_whitelist" field in this mutation.
func (m *ApiKeyMutation) AppendedIPWhitelist() ([]string, bool) {
	if len(m.appendip_whitelist) == 0 {
		return nil, false
	}
	return m.appendip_whitelist, true
}

// ClearIPWhitelist clears the value of the "ip_whitelist" field.
func (m *ApiKeyMutation) ClearIPWhitelist() {
	m.ip_whitelist = nil
	m.appendip_whitelist = nil
	m.clearedFields[apikey.FieldIPWhitelist] = struct{}{}
}

// IPWhitelistCleared returns if the "ip_whitelist" field was cleared in this mutation.
func (m *ApiKeyMutation) IPWhitelistCleared() bool {
	_, ok := m.clearedFields[apikey.FieldIPWhitelist]
	return ok
}

// ResetIPWhitelist resets all changes to the "ip_whitelist" field.
func (m *ApiKeyMutation) ResetIPWhitelist() {
	m.ip_whitelist = nil
	m.appendip_whitelist = nil
	delete(m.clearedFields, apikey.FieldIPWhitelist)
}

// SetRateLimits sets the "rate_limits" field.
func (m *ApiKeyMutation) SetRateLimits(ckrl common.APIKeyRateLimits) {
	m.rate_limits = &ckrl
}

// RateLimits returns the value of the "rate_limits" field in the mutation.
func (m *ApiKeyMutation) RateLimits() (r common.APIKeyRateLimits, exists bool) {
	v := m.rate_limits
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimits returns the old "rate_limits" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldRateLimits(ctx context.Context) (v common.APIKeyRateLimits, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimits: %w", err)
	}
	return oldValue.RateLimits, nil
}

// ClearRateLimits clears the value of the "rate_limits" field.
func (m *ApiKeyMutation) ClearRateLimits() {
	m.rate_limits = nil
	m.clearedFields[apikey.FieldRateLimits] = struct{}{}
}

// RateLimitsCleared returns if the "rate_limits" field was cleared in this mutation.
func (m *ApiKeyMutation) RateLimitsCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRateLimits]
	return ok
}

// ResetRateLimits resets all changes to the "rate_limits" field.
func (m *ApiKeyMutation) ResetRateLimits() {
	m.rate_limits = nil
	delete(m.clearedFields, apikey.FieldRateLimits)
}

// SetMetadata sets the "metadata" field.
func (m *ApiKeyMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ApiKeyMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ApiKeyMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[apikey.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ApiKeyMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[apikey.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ApiKeyMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, apikey.FieldMetadata)
}

// SetLastUsed sets the "last_used" field.
func (m *ApiKeyMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *ApiKeyMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *ApiKeyMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[apikey.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *ApiKeyMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *ApiKeyMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, apikey.FieldLastUsed)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ApiKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ApiKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ApiKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ApiKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ApiKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiKeyMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ApiKeyMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[apikey.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ApiKeyMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ApiKeyMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddActivityIDs adds the "activities" edge to the ApiKeyActivity entity by ids.
func (m *ApiKeyMutation) AddActivityIDs(ids ...xid.ID) {
	if m.activities == nil {
		m.activities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the ApiKeyActivity entity.
func (m *ApiKeyMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the ApiKeyActivity entity was cleared.
func (m *ApiKeyMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the ApiKeyActivity entity by IDs.
func (m *ApiKeyMutation) RemoveActivityIDs(ids ...xid.ID) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the ApiKeyActivity entity.
func (m *ApiKeyMutation) RemovedActivitiesIDs() (ids []xid.ID) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *ApiKeyMutation) ActivitiesIDs() (ids []xid.ID) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *ApiKeyMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the ApiKeyMutation builder.
func (m *ApiKeyMutation) Where(ps ...predicate.ApiKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiKey).
func (m *ApiKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiKeyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.public_key != nil {
		fields = append(fields, apikey.FieldPublicKey)
	}
	if m.secret_key != nil {
		fields = append(fields, apikey.FieldSecretKey)
	}
	if m.hashed_secret_key != nil {
		fields = append(fields, apikey.FieldHashedSecretKey)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.hashed_key != nil {
		fields = append(fields, apikey.FieldHashedKey)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, apikey.FieldOrganizationID)
	}
	if m._type != nil {
		fields = append(fields, apikey.FieldType)
	}
	if m.environment != nil {
		fields = append(fields, apikey.FieldEnvironment)
	}
	if m.active != nil {
		fields = append(fields, apikey.FieldActive)
	}
	if m.permissions != nil {
		fields = append(fields, apikey.FieldPermissions)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.ip_whitelist != nil {
		fields = append(fields, apikey.FieldIPWhitelist)
	}
	if m.rate_limits != nil {
		fields = append(fields, apikey.FieldRateLimits)
	}
	if m.metadata != nil {
		fields = append(fields, apikey.FieldMetadata)
	}
	if m.last_used != nil {
		fields = append(fields, apikey.FieldLastUsed)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldPublicKey:
		return m.PublicKey()
	case apikey.FieldSecretKey:
		return m.SecretKey()
	case apikey.FieldHashedSecretKey:
		return m.HashedSecretKey()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldHashedKey:
		return m.HashedKey()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldOrganizationID:
		return m.OrganizationID()
	case apikey.FieldType:
		return m.GetType()
	case apikey.FieldEnvironment:
		return m.Environment()
	case apikey.FieldActive:
		return m.Active()
	case apikey.FieldPermissions:
		return m.Permissions()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldIPWhitelist:
		return m.IPWhitelist()
	case apikey.FieldRateLimits:
		return m.RateLimits()
	case apikey.FieldMetadata:
		return m.Metadata()
	case apikey.FieldLastUsed:
		return m.LastUsed()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case apikey.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case apikey.FieldHashedSecretKey:
		return m.OldHashedSecretKey(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldHashedKey:
		return m.OldHashedKey(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case apikey.FieldType:
		return m.OldType(ctx)
	case apikey.FieldEnvironment:
		return m.OldEnvironment(ctx)
	case apikey.FieldActive:
		return m.OldActive(ctx)
	case apikey.FieldPermissions:
		return m.OldPermissions(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldIPWhitelist:
		return m.OldIPWhitelist(ctx)
	case apikey.FieldRateLimits:
		return m.OldRateLimits(ctx)
	case apikey.FieldMetadata:
		return m.OldMetadata(ctx)
	case apikey.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case apikey.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case apikey.FieldHashedSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedSecretKey(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldHashedKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedKey(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case apikey.FieldType:
		v, ok := value.(model.APIKeyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case apikey.FieldEnvironment:
		v, ok := value.(model.Environment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironment(v)
		return nil
	case apikey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case apikey.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldIPWhitelist:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPWhitelist(v)
		return nil
	case apikey.FieldRateLimits:
		v, ok := value.(common.APIKeyRateLimits)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimits(v)
		return nil
	case apikey.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case apikey.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldDeletedAt) {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.FieldCleared(apikey.FieldKey) {
		fields = append(fields, apikey.FieldKey)
	}
	if m.FieldCleared(apikey.FieldHashedKey) {
		fields = append(fields, apikey.FieldHashedKey)
	}
	if m.FieldCleared(apikey.FieldUserID) {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.FieldCleared(apikey.FieldOrganizationID) {
		fields = append(fields, apikey.FieldOrganizationID)
	}
	if m.FieldCleared(apikey.FieldPermissions) {
		fields = append(fields, apikey.FieldPermissions)
	}
	if m.FieldCleared(apikey.FieldScopes) {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.FieldCleared(apikey.FieldIPWhitelist) {
		fields = append(fields, apikey.FieldIPWhitelist)
	}
	if m.FieldCleared(apikey.FieldRateLimits) {
		fields = append(fields, apikey.FieldRateLimits)
	}
	if m.FieldCleared(apikey.FieldMetadata) {
		fields = append(fields, apikey.FieldMetadata)
	}
	if m.FieldCleared(apikey.FieldLastUsed) {
		fields = append(fields, apikey.FieldLastUsed)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case apikey.FieldKey:
		m.ClearKey()
		return nil
	case apikey.FieldHashedKey:
		m.ClearHashedKey()
		return nil
	case apikey.FieldUserID:
		m.ClearUserID()
		return nil
	case apikey.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case apikey.FieldPermissions:
		m.ClearPermissions()
		return nil
	case apikey.FieldScopes:
		m.ClearScopes()
		return nil
	case apikey.FieldIPWhitelist:
		m.ClearIPWhitelist()
		return nil
	case apikey.FieldRateLimits:
		m.ClearRateLimits()
		return nil
	case apikey.FieldMetadata:
		m.ClearMetadata()
		return nil
	case apikey.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ApiKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case apikey.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case apikey.FieldHashedSecretKey:
		m.ResetHashedSecretKey()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldHashedKey:
		m.ResetHashedKey()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case apikey.FieldType:
		m.ResetType()
		return nil
	case apikey.FieldEnvironment:
		m.ResetEnvironment()
		return nil
	case apikey.FieldActive:
		m.ResetActive()
		return nil
	case apikey.FieldPermissions:
		m.ResetPermissions()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldIPWhitelist:
		m.ResetIPWhitelist()
		return nil
	case apikey.FieldRateLimits:
		m.ResetRateLimits()
		return nil
	case apikey.FieldMetadata:
		m.ResetMetadata()
		return nil
	case apikey.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, apikey.EdgeOrganization)
	}
	if m.activities != nil {
		edges = append(edges, apikey.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedactivities != nil {
		edges = append(edges, apikey.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, apikey.EdgeOrganization)
	}
	if m.clearedactivities {
		edges = append(edges, apikey.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeOrganization:
		return m.clearedorganization
	case apikey.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ApiKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case apikey.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown ApiKey edge %s", name)
}

// ApiKeyActivityMutation represents an operation that mutates the ApiKeyActivity nodes in the graph.
type ApiKeyActivityMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	action           *string
	endpoint         *string
	method           *string
	status_code      *int
	addstatus_code   *int
	response_time    *int
	addresponse_time *int
	ip_address       *string
	user_agent       *string
	success          *bool
	error            *string
	timestamp        *time.Time
	metadata         *map[string]interface{}
	clearedFields    map[string]struct{}
	key              *xid.ID
	clearedkey       bool
	done             bool
	oldValue         func(context.Context) (*ApiKeyActivity, error)
	predicates       []predicate.ApiKeyActivity
}

var _ ent.Mutation = (*ApiKeyActivityMutation)(nil)

// apikeyactivityOption allows management of the mutation configuration using functional options.
type apikeyactivityOption func(*ApiKeyActivityMutation)

// newApiKeyActivityMutation creates new mutation for the ApiKeyActivity entity.
func newApiKeyActivityMutation(c config, op Op, opts ...apikeyactivityOption) *ApiKeyActivityMutation {
	m := &ApiKeyActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeApiKeyActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiKeyActivityID sets the ID field of the mutation.
func withApiKeyActivityID(id xid.ID) apikeyactivityOption {
	return func(m *ApiKeyActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiKeyActivity
		)
		m.oldValue = func(ctx context.Context) (*ApiKeyActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiKeyActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiKeyActivity sets the old ApiKeyActivity of the mutation.
func withApiKeyActivity(node *ApiKeyActivity) apikeyactivityOption {
	return func(m *ApiKeyActivityMutation) {
		m.oldValue = func(context.Context) (*ApiKeyActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiKeyActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiKeyActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiKeyActivity entities.
func (m *ApiKeyActivityMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiKeyActivityMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiKeyActivityMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiKeyActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKeyID sets the "key_id" field.
func (m *ApiKeyActivityMutation) SetKeyID(x xid.ID) {
	m.key = &x
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *ApiKeyActivityMutation) KeyID() (r xid.ID, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldKeyID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *ApiKeyActivityMutation) ResetKeyID() {
	m.key = nil
}

// SetAction sets the "action" field.
func (m *ApiKeyActivityMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ApiKeyActivityMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ApiKeyActivityMutation) ResetAction() {
	m.action = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *ApiKeyActivityMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *ApiKeyActivityMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ClearEndpoint clears the value of the "endpoint" field.
func (m *ApiKeyActivityMutation) ClearEndpoint() {
	m.endpoint = nil
	m.clearedFields[apikeyactivity.FieldEndpoint] = struct{}{}
}

// EndpointCleared returns if the "endpoint" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) EndpointCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldEndpoint]
	return ok
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *ApiKeyActivityMutation) ResetEndpoint() {
	m.endpoint = nil
	delete(m.clearedFields, apikeyactivity.FieldEndpoint)
}

// SetMethod sets the "method" field.
func (m *ApiKeyActivityMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *ApiKeyActivityMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *ApiKeyActivityMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[apikeyactivity.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) MethodCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *ApiKeyActivityMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, apikeyactivity.FieldMethod)
}

// SetStatusCode sets the "status_code" field.
func (m *ApiKeyActivityMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *ApiKeyActivityMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *ApiKeyActivityMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *ApiKeyActivityMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *ApiKeyActivityMutation) ClearStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	m.clearedFields[apikeyactivity.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *ApiKeyActivityMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	delete(m.clearedFields, apikeyactivity.FieldStatusCode)
}

// SetResponseTime sets the "response_time" field.
func (m *ApiKeyActivityMutation) SetResponseTime(i int) {
	m.response_time = &i
	m.addresponse_time = nil
}

// ResponseTime returns the value of the "response_time" field in the mutation.
func (m *ApiKeyActivityMutation) ResponseTime() (r int, exists bool) {
	v := m.response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTime returns the old "response_time" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldResponseTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTime: %w", err)
	}
	return oldValue.ResponseTime, nil
}

// AddResponseTime adds i to the "response_time" field.
func (m *ApiKeyActivityMutation) AddResponseTime(i int) {
	if m.addresponse_time != nil {
		*m.addresponse_time += i
	} else {
		m.addresponse_time = &i
	}
}

// AddedResponseTime returns the value that was added to the "response_time" field in this mutation.
func (m *ApiKeyActivityMutation) AddedResponseTime() (r int, exists bool) {
	v := m.addresponse_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseTime clears the value of the "response_time" field.
func (m *ApiKeyActivityMutation) ClearResponseTime() {
	m.response_time = nil
	m.addresponse_time = nil
	m.clearedFields[apikeyactivity.FieldResponseTime] = struct{}{}
}

// ResponseTimeCleared returns if the "response_time" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) ResponseTimeCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldResponseTime]
	return ok
}

// ResetResponseTime resets all changes to the "response_time" field.
func (m *ApiKeyActivityMutation) ResetResponseTime() {
	m.response_time = nil
	m.addresponse_time = nil
	delete(m.clearedFields, apikeyactivity.FieldResponseTime)
}

// SetIPAddress sets the "ip_address" field.
func (m *ApiKeyActivityMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ApiKeyActivityMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *ApiKeyActivityMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[apikeyactivity.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ApiKeyActivityMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, apikeyactivity.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *ApiKeyActivityMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *ApiKeyActivityMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *ApiKeyActivityMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[apikeyactivity.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *ApiKeyActivityMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, apikeyactivity.FieldUserAgent)
}

// SetSuccess sets the "success" field.
func (m *ApiKeyActivityMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *ApiKeyActivityMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *ApiKeyActivityMutation) ResetSuccess() {
	m.success = nil
}

// SetError sets the "error" field.
func (m *ApiKeyActivityMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ApiKeyActivityMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ApiKeyActivityMutation) ClearError() {
	m.error = nil
	m.clearedFields[apikeyactivity.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ApiKeyActivityMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, apikeyactivity.FieldError)
}

// SetTimestamp sets the "timestamp" field.
func (m *ApiKeyActivityMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ApiKeyActivityMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ApiKeyActivityMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetMetadata sets the "metadata" field.
func (m *ApiKeyActivityMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ApiKeyActivityMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ApiKeyActivity entity.
// If the ApiKeyActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyActivityMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ApiKeyActivityMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[apikeyactivity.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ApiKeyActivityMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[apikeyactivity.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ApiKeyActivityMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, apikeyactivity.FieldMetadata)
}

// ClearKey clears the "key" edge to the ApiKey entity.
func (m *ApiKeyActivityMutation) ClearKey() {
	m.clearedkey = true
	m.clearedFields[apikeyactivity.FieldKeyID] = struct{}{}
}

// KeyCleared reports if the "key" edge to the ApiKey entity was cleared.
func (m *ApiKeyActivityMutation) KeyCleared() bool {
	return m.clearedkey
}

// KeyIDs returns the "key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeyID instead. It exists only for internal usage by the builders.
func (m *ApiKeyActivityMutation) KeyIDs() (ids []xid.ID) {
	if id := m.key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKey resets all changes to the "key" edge.
func (m *ApiKeyActivityMutation) ResetKey() {
	m.key = nil
	m.clearedkey = false
}

// Where appends a list predicates to the ApiKeyActivityMutation builder.
func (m *ApiKeyActivityMutation) Where(ps ...predicate.ApiKeyActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiKeyActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiKeyActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiKeyActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiKeyActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiKeyActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiKeyActivity).
func (m *ApiKeyActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiKeyActivityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.key != nil {
		fields = append(fields, apikeyactivity.FieldKeyID)
	}
	if m.action != nil {
		fields = append(fields, apikeyactivity.FieldAction)
	}
	if m.endpoint != nil {
		fields = append(fields, apikeyactivity.FieldEndpoint)
	}
	if m.method != nil {
		fields = append(fields, apikeyactivity.FieldMethod)
	}
	if m.status_code != nil {
		fields = append(fields, apikeyactivity.FieldStatusCode)
	}
	if m.response_time != nil {
		fields = append(fields, apikeyactivity.FieldResponseTime)
	}
	if m.ip_address != nil {
		fields = append(fields, apikeyactivity.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, apikeyactivity.FieldUserAgent)
	}
	if m.success != nil {
		fields = append(fields, apikeyactivity.FieldSuccess)
	}
	if m.error != nil {
		fields = append(fields, apikeyactivity.FieldError)
	}
	if m.timestamp != nil {
		fields = append(fields, apikeyactivity.FieldTimestamp)
	}
	if m.metadata != nil {
		fields = append(fields, apikeyactivity.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiKeyActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikeyactivity.FieldKeyID:
		return m.KeyID()
	case apikeyactivity.FieldAction:
		return m.Action()
	case apikeyactivity.FieldEndpoint:
		return m.Endpoint()
	case apikeyactivity.FieldMethod:
		return m.Method()
	case apikeyactivity.FieldStatusCode:
		return m.StatusCode()
	case apikeyactivity.FieldResponseTime:
		return m.ResponseTime()
	case apikeyactivity.FieldIPAddress:
		return m.IPAddress()
	case apikeyactivity.FieldUserAgent:
		return m.UserAgent()
	case apikeyactivity.FieldSuccess:
		return m.Success()
	case apikeyactivity.FieldError:
		return m.Error()
	case apikeyactivity.FieldTimestamp:
		return m.Timestamp()
	case apikeyactivity.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiKeyActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikeyactivity.FieldKeyID:
		return m.OldKeyID(ctx)
	case apikeyactivity.FieldAction:
		return m.OldAction(ctx)
	case apikeyactivity.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case apikeyactivity.FieldMethod:
		return m.OldMethod(ctx)
	case apikeyactivity.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case apikeyactivity.FieldResponseTime:
		return m.OldResponseTime(ctx)
	case apikeyactivity.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case apikeyactivity.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case apikeyactivity.FieldSuccess:
		return m.OldSuccess(ctx)
	case apikeyactivity.FieldError:
		return m.OldError(ctx)
	case apikeyactivity.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case apikeyactivity.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown ApiKeyActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikeyactivity.FieldKeyID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case apikeyactivity.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case apikeyactivity.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case apikeyactivity.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case apikeyactivity.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case apikeyactivity.FieldResponseTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTime(v)
		return nil
	case apikeyactivity.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case apikeyactivity.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case apikeyactivity.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case apikeyactivity.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case apikeyactivity.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case apikeyactivity.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKeyActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiKeyActivityMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_code != nil {
		fields = append(fields, apikeyactivity.FieldStatusCode)
	}
	if m.addresponse_time != nil {
		fields = append(fields, apikeyactivity.FieldResponseTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiKeyActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikeyactivity.FieldStatusCode:
		return m.AddedStatusCode()
	case apikeyactivity.FieldResponseTime:
		return m.AddedResponseTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikeyactivity.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	case apikeyactivity.FieldResponseTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseTime(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKeyActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiKeyActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikeyactivity.FieldEndpoint) {
		fields = append(fields, apikeyactivity.FieldEndpoint)
	}
	if m.FieldCleared(apikeyactivity.FieldMethod) {
		fields = append(fields, apikeyactivity.FieldMethod)
	}
	if m.FieldCleared(apikeyactivity.FieldStatusCode) {
		fields = append(fields, apikeyactivity.FieldStatusCode)
	}
	if m.FieldCleared(apikeyactivity.FieldResponseTime) {
		fields = append(fields, apikeyactivity.FieldResponseTime)
	}
	if m.FieldCleared(apikeyactivity.FieldIPAddress) {
		fields = append(fields, apikeyactivity.FieldIPAddress)
	}
	if m.FieldCleared(apikeyactivity.FieldUserAgent) {
		fields = append(fields, apikeyactivity.FieldUserAgent)
	}
	if m.FieldCleared(apikeyactivity.FieldError) {
		fields = append(fields, apikeyactivity.FieldError)
	}
	if m.FieldCleared(apikeyactivity.FieldMetadata) {
		fields = append(fields, apikeyactivity.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiKeyActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiKeyActivityMutation) ClearField(name string) error {
	switch name {
	case apikeyactivity.FieldEndpoint:
		m.ClearEndpoint()
		return nil
	case apikeyactivity.FieldMethod:
		m.ClearMethod()
		return nil
	case apikeyactivity.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case apikeyactivity.FieldResponseTime:
		m.ClearResponseTime()
		return nil
	case apikeyactivity.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case apikeyactivity.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case apikeyactivity.FieldError:
		m.ClearError()
		return nil
	case apikeyactivity.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown ApiKeyActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiKeyActivityMutation) ResetField(name string) error {
	switch name {
	case apikeyactivity.FieldKeyID:
		m.ResetKeyID()
		return nil
	case apikeyactivity.FieldAction:
		m.ResetAction()
		return nil
	case apikeyactivity.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case apikeyactivity.FieldMethod:
		m.ResetMethod()
		return nil
	case apikeyactivity.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case apikeyactivity.FieldResponseTime:
		m.ResetResponseTime()
		return nil
	case apikeyactivity.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case apikeyactivity.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case apikeyactivity.FieldSuccess:
		m.ResetSuccess()
		return nil
	case apikeyactivity.FieldError:
		m.ResetError()
		return nil
	case apikeyactivity.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case apikeyactivity.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown ApiKeyActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiKeyActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.key != nil {
		edges = append(edges, apikeyactivity.EdgeKey)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiKeyActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikeyactivity.EdgeKey:
		if id := m.key; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiKeyActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiKeyActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiKeyActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkey {
		edges = append(edges, apikeyactivity.EdgeKey)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiKeyActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case apikeyactivity.EdgeKey:
		return m.clearedkey
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiKeyActivityMutation) ClearEdge(name string) error {
	switch name {
	case apikeyactivity.EdgeKey:
		m.ClearKey()
		return nil
	}
	return fmt.Errorf("unknown ApiKeyActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiKeyActivityMutation) ResetEdge(name string) error {
	switch name {
	case apikeyactivity.EdgeKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown ApiKeyActivity edge %s", name)
}

// AuditMutation represents an operation that mutates the Audit nodes in the graph.
type AuditMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	deleted_at          *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	action              *string
	resource_type       *string
	resource_id         *xid.ID
	status              *string
	ip_address          *string
	user_agent          *string
	location            *string
	device_id           *string
	request_id          *string
	error_code          *string
	error_message       *string
	description         *string
	metadata            *map[string]interface{}
	old_values          *map[string]interface{}
	current_values      *map[string]interface{}
	timestamp           *time.Time
	clearedFields       map[string]struct{}
	user                *xid.ID
	cleareduser         bool
	organization        *xid.ID
	clearedorganization bool
	session             *xid.ID
	clearedsession      bool
	done                bool
	oldValue            func(context.Context) (*Audit, error)
	predicates          []predicate.Audit
}

var _ ent.Mutation = (*AuditMutation)(nil)

// auditOption allows management of the mutation configuration using functional options.
type auditOption func(*AuditMutation)

// newAuditMutation creates new mutation for the Audit entity.
func newAuditMutation(c config, op Op, opts ...auditOption) *AuditMutation {
	m := &AuditMutation{
		config:        c,
		op:            op,
		typ:           TypeAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditID sets the ID field of the mutation.
func withAuditID(id xid.ID) auditOption {
	return func(m *AuditMutation) {
		var (
			err   error
			once  sync.Once
			value *Audit
		)
		m.oldValue = func(ctx context.Context) (*Audit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Audit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAudit sets the old Audit of the mutation.
func withAudit(node *Audit) auditOption {
	return func(m *AuditMutation) {
		m.oldValue = func(context.Context) (*Audit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Audit entities.
func (m *AuditMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Audit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuditMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuditMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuditMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[audit.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuditMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[audit.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuditMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, audit.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuditMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuditMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuditMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *AuditMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[audit.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, audit.FieldUserID)
}

// SetOrganizationID sets the "organization_id" field.
func (m *AuditMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *AuditMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *AuditMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[audit.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *AuditMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *AuditMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, audit.FieldOrganizationID)
}

// SetSessionID sets the "session_id" field.
func (m *AuditMutation) SetSessionID(x xid.ID) {
	m.session = &x
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AuditMutation) SessionID() (r xid.ID, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldSessionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *AuditMutation) ClearSessionID() {
	m.session = nil
	m.clearedFields[audit.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *AuditMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AuditMutation) ResetSessionID() {
	m.session = nil
	delete(m.clearedFields, audit.FieldSessionID)
}

// SetAction sets the "action" field.
func (m *AuditMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditMutation) ResetAction() {
	m.action = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AuditMutation) SetResourceID(x xid.ID) {
	m.resource_id = &x
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditMutation) ResourceID() (r xid.ID, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldResourceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[audit.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, audit.FieldResourceID)
}

// SetStatus sets the "status" field.
func (m *AuditMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AuditMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AuditMutation) ResetStatus() {
	m.status = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuditMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[audit.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuditMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[audit.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, audit.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[audit.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[audit.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, audit.FieldUserAgent)
}

// SetLocation sets the "location" field.
func (m *AuditMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *AuditMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *AuditMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[audit.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *AuditMutation) LocationCleared() bool {
	_, ok := m.clearedFields[audit.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *AuditMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, audit.FieldLocation)
}

// SetDeviceID sets the "device_id" field.
func (m *AuditMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AuditMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AuditMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[audit.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AuditMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AuditMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, audit.FieldDeviceID)
}

// SetRequestID sets the "request_id" field.
func (m *AuditMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[audit.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, audit.FieldRequestID)
}

// SetErrorCode sets the "error_code" field.
func (m *AuditMutation) SetErrorCode(s string) {
	m.error_code = &s
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditMutation) ErrorCode() (r string, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditMutation) ClearErrorCode() {
	m.error_code = nil
	m.clearedFields[audit.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[audit.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditMutation) ResetErrorCode() {
	m.error_code = nil
	delete(m.clearedFields, audit.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[audit.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[audit.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, audit.FieldErrorMessage)
}

// SetDescription sets the "description" field.
func (m *AuditMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuditMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuditMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[audit.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuditMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[audit.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuditMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, audit.FieldDescription)
}

// SetMetadata sets the "metadata" field.
func (m *AuditMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[audit.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[audit.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, audit.FieldMetadata)
}

// SetOldValues sets the "old_values" field.
func (m *AuditMutation) SetOldValues(value map[string]interface{}) {
	m.old_values = &value
}

// OldValues returns the value of the "old_values" field in the mutation.
func (m *AuditMutation) OldValues() (r map[string]interface{}, exists bool) {
	v := m.old_values
	if v == nil {
		return
	}
	return *v, true
}

// OldOldValues returns the old "old_values" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldOldValues(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldValues: %w", err)
	}
	return oldValue.OldValues, nil
}

// ClearOldValues clears the value of the "old_values" field.
func (m *AuditMutation) ClearOldValues() {
	m.old_values = nil
	m.clearedFields[audit.FieldOldValues] = struct{}{}
}

// OldValuesCleared returns if the "old_values" field was cleared in this mutation.
func (m *AuditMutation) OldValuesCleared() bool {
	_, ok := m.clearedFields[audit.FieldOldValues]
	return ok
}

// ResetOldValues resets all changes to the "old_values" field.
func (m *AuditMutation) ResetOldValues() {
	m.old_values = nil
	delete(m.clearedFields, audit.FieldOldValues)
}

// SetCurrentValues sets the "current_values" field.
func (m *AuditMutation) SetCurrentValues(value map[string]interface{}) {
	m.current_values = &value
}

// CurrentValues returns the value of the "current_values" field in the mutation.
func (m *AuditMutation) CurrentValues() (r map[string]interface{}, exists bool) {
	v := m.current_values
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentValues returns the old "current_values" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldCurrentValues(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentValues: %w", err)
	}
	return oldValue.CurrentValues, nil
}

// ClearCurrentValues clears the value of the "current_values" field.
func (m *AuditMutation) ClearCurrentValues() {
	m.current_values = nil
	m.clearedFields[audit.FieldCurrentValues] = struct{}{}
}

// CurrentValuesCleared returns if the "current_values" field was cleared in this mutation.
func (m *AuditMutation) CurrentValuesCleared() bool {
	_, ok := m.clearedFields[audit.FieldCurrentValues]
	return ok
}

// ResetCurrentValues resets all changes to the "current_values" field.
func (m *AuditMutation) ResetCurrentValues() {
	m.current_values = nil
	delete(m.clearedFields, audit.FieldCurrentValues)
}

// SetTimestamp sets the "timestamp" field.
func (m *AuditMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AuditMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AuditMutation) ResetTimestamp() {
	m.timestamp = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuditMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[audit.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuditMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuditMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuditMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *AuditMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[audit.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *AuditMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *AuditMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *AuditMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearSession clears the "session" edge to the Session entity.
func (m *AuditMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[audit.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *AuditMutation) SessionCleared() bool {
	return m.SessionIDCleared() || m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *AuditMutation) SessionIDs() (ids []xid.ID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *AuditMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the AuditMutation builder.
func (m *AuditMutation) Where(ps ...predicate.Audit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Audit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Audit).
func (m *AuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.deleted_at != nil {
		fields = append(fields, audit.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, audit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, audit.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, audit.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, audit.FieldOrganizationID)
	}
	if m.session != nil {
		fields = append(fields, audit.FieldSessionID)
	}
	if m.action != nil {
		fields = append(fields, audit.FieldAction)
	}
	if m.resource_type != nil {
		fields = append(fields, audit.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, audit.FieldResourceID)
	}
	if m.status != nil {
		fields = append(fields, audit.FieldStatus)
	}
	if m.ip_address != nil {
		fields = append(fields, audit.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, audit.FieldUserAgent)
	}
	if m.location != nil {
		fields = append(fields, audit.FieldLocation)
	}
	if m.device_id != nil {
		fields = append(fields, audit.FieldDeviceID)
	}
	if m.request_id != nil {
		fields = append(fields, audit.FieldRequestID)
	}
	if m.error_code != nil {
		fields = append(fields, audit.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, audit.FieldErrorMessage)
	}
	if m.description != nil {
		fields = append(fields, audit.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, audit.FieldMetadata)
	}
	if m.old_values != nil {
		fields = append(fields, audit.FieldOldValues)
	}
	if m.current_values != nil {
		fields = append(fields, audit.FieldCurrentValues)
	}
	if m.timestamp != nil {
		fields = append(fields, audit.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audit.FieldDeletedAt:
		return m.DeletedAt()
	case audit.FieldCreatedAt:
		return m.CreatedAt()
	case audit.FieldUpdatedAt:
		return m.UpdatedAt()
	case audit.FieldUserID:
		return m.UserID()
	case audit.FieldOrganizationID:
		return m.OrganizationID()
	case audit.FieldSessionID:
		return m.SessionID()
	case audit.FieldAction:
		return m.Action()
	case audit.FieldResourceType:
		return m.ResourceType()
	case audit.FieldResourceID:
		return m.ResourceID()
	case audit.FieldStatus:
		return m.Status()
	case audit.FieldIPAddress:
		return m.IPAddress()
	case audit.FieldUserAgent:
		return m.UserAgent()
	case audit.FieldLocation:
		return m.Location()
	case audit.FieldDeviceID:
		return m.DeviceID()
	case audit.FieldRequestID:
		return m.RequestID()
	case audit.FieldErrorCode:
		return m.ErrorCode()
	case audit.FieldErrorMessage:
		return m.ErrorMessage()
	case audit.FieldDescription:
		return m.Description()
	case audit.FieldMetadata:
		return m.Metadata()
	case audit.FieldOldValues:
		return m.OldValues()
	case audit.FieldCurrentValues:
		return m.CurrentValues()
	case audit.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case audit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case audit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case audit.FieldUserID:
		return m.OldUserID(ctx)
	case audit.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case audit.FieldSessionID:
		return m.OldSessionID(ctx)
	case audit.FieldAction:
		return m.OldAction(ctx)
	case audit.FieldResourceType:
		return m.OldResourceType(ctx)
	case audit.FieldResourceID:
		return m.OldResourceID(ctx)
	case audit.FieldStatus:
		return m.OldStatus(ctx)
	case audit.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case audit.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case audit.FieldLocation:
		return m.OldLocation(ctx)
	case audit.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case audit.FieldRequestID:
		return m.OldRequestID(ctx)
	case audit.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case audit.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case audit.FieldDescription:
		return m.OldDescription(ctx)
	case audit.FieldMetadata:
		return m.OldMetadata(ctx)
	case audit.FieldOldValues:
		return m.OldOldValues(ctx)
	case audit.FieldCurrentValues:
		return m.OldCurrentValues(ctx)
	case audit.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Audit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audit.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case audit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case audit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case audit.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case audit.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case audit.FieldSessionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case audit.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case audit.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case audit.FieldResourceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case audit.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case audit.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case audit.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case audit.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case audit.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case audit.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case audit.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case audit.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case audit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case audit.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case audit.FieldOldValues:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldValues(v)
		return nil
	case audit.FieldCurrentValues:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentValues(v)
		return nil
	case audit.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Audit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Audit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(audit.FieldDeletedAt) {
		fields = append(fields, audit.FieldDeletedAt)
	}
	if m.FieldCleared(audit.FieldUserID) {
		fields = append(fields, audit.FieldUserID)
	}
	if m.FieldCleared(audit.FieldOrganizationID) {
		fields = append(fields, audit.FieldOrganizationID)
	}
	if m.FieldCleared(audit.FieldSessionID) {
		fields = append(fields, audit.FieldSessionID)
	}
	if m.FieldCleared(audit.FieldResourceID) {
		fields = append(fields, audit.FieldResourceID)
	}
	if m.FieldCleared(audit.FieldIPAddress) {
		fields = append(fields, audit.FieldIPAddress)
	}
	if m.FieldCleared(audit.FieldUserAgent) {
		fields = append(fields, audit.FieldUserAgent)
	}
	if m.FieldCleared(audit.FieldLocation) {
		fields = append(fields, audit.FieldLocation)
	}
	if m.FieldCleared(audit.FieldDeviceID) {
		fields = append(fields, audit.FieldDeviceID)
	}
	if m.FieldCleared(audit.FieldRequestID) {
		fields = append(fields, audit.FieldRequestID)
	}
	if m.FieldCleared(audit.FieldErrorCode) {
		fields = append(fields, audit.FieldErrorCode)
	}
	if m.FieldCleared(audit.FieldErrorMessage) {
		fields = append(fields, audit.FieldErrorMessage)
	}
	if m.FieldCleared(audit.FieldDescription) {
		fields = append(fields, audit.FieldDescription)
	}
	if m.FieldCleared(audit.FieldMetadata) {
		fields = append(fields, audit.FieldMetadata)
	}
	if m.FieldCleared(audit.FieldOldValues) {
		fields = append(fields, audit.FieldOldValues)
	}
	if m.FieldCleared(audit.FieldCurrentValues) {
		fields = append(fields, audit.FieldCurrentValues)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditMutation) ClearField(name string) error {
	switch name {
	case audit.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case audit.FieldUserID:
		m.ClearUserID()
		return nil
	case audit.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case audit.FieldSessionID:
		m.ClearSessionID()
		return nil
	case audit.FieldResourceID:
		m.ClearResourceID()
		return nil
	case audit.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case audit.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case audit.FieldLocation:
		m.ClearLocation()
		return nil
	case audit.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case audit.FieldRequestID:
		m.ClearRequestID()
		return nil
	case audit.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case audit.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case audit.FieldDescription:
		m.ClearDescription()
		return nil
	case audit.FieldMetadata:
		m.ClearMetadata()
		return nil
	case audit.FieldOldValues:
		m.ClearOldValues()
		return nil
	case audit.FieldCurrentValues:
		m.ClearCurrentValues()
		return nil
	}
	return fmt.Errorf("unknown Audit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditMutation) ResetField(name string) error {
	switch name {
	case audit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case audit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case audit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case audit.FieldUserID:
		m.ResetUserID()
		return nil
	case audit.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case audit.FieldSessionID:
		m.ResetSessionID()
		return nil
	case audit.FieldAction:
		m.ResetAction()
		return nil
	case audit.FieldResourceType:
		m.ResetResourceType()
		return nil
	case audit.FieldResourceID:
		m.ResetResourceID()
		return nil
	case audit.FieldStatus:
		m.ResetStatus()
		return nil
	case audit.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case audit.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case audit.FieldLocation:
		m.ResetLocation()
		return nil
	case audit.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case audit.FieldRequestID:
		m.ResetRequestID()
		return nil
	case audit.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case audit.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case audit.FieldDescription:
		m.ResetDescription()
		return nil
	case audit.FieldMetadata:
		m.ResetMetadata()
		return nil
	case audit.FieldOldValues:
		m.ResetOldValues()
		return nil
	case audit.FieldCurrentValues:
		m.ResetCurrentValues()
		return nil
	case audit.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Audit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, audit.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, audit.EdgeOrganization)
	}
	if m.session != nil {
		edges = append(edges, audit.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case audit.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case audit.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case audit.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, audit.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, audit.EdgeOrganization)
	}
	if m.clearedsession {
		edges = append(edges, audit.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditMutation) EdgeCleared(name string) bool {
	switch name {
	case audit.EdgeUser:
		return m.cleareduser
	case audit.EdgeOrganization:
		return m.clearedorganization
	case audit.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditMutation) ClearEdge(name string) error {
	switch name {
	case audit.EdgeUser:
		m.ClearUser()
		return nil
	case audit.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case audit.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Audit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditMutation) ResetEdge(name string) error {
	switch name {
	case audit.EdgeUser:
		m.ResetUser()
		return nil
	case audit.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case audit.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown Audit edge %s", name)
}

// EmailTemplateMutation represents an operation that mutates the EmailTemplate nodes in the graph.
type EmailTemplateMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	subject             *string
	_type               *string
	html_content        *string
	text_content        *string
	active              *bool
	system              *bool
	locale              *string
	metadata            *map[string]interface{}
	clearedFields       map[string]struct{}
	organization        *xid.ID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*EmailTemplate, error)
	predicates          []predicate.EmailTemplate
}

var _ ent.Mutation = (*EmailTemplateMutation)(nil)

// emailtemplateOption allows management of the mutation configuration using functional options.
type emailtemplateOption func(*EmailTemplateMutation)

// newEmailTemplateMutation creates new mutation for the EmailTemplate entity.
func newEmailTemplateMutation(c config, op Op, opts ...emailtemplateOption) *EmailTemplateMutation {
	m := &EmailTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailTemplateID sets the ID field of the mutation.
func withEmailTemplateID(id xid.ID) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailTemplate
		)
		m.oldValue = func(ctx context.Context) (*EmailTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailTemplate sets the old EmailTemplate of the mutation.
func withEmailTemplate(node *EmailTemplate) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		m.oldValue = func(context.Context) (*EmailTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailTemplate entities.
func (m *EmailTemplateMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailTemplateMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailTemplateMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailTemplateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailTemplateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailTemplateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[emailtemplate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailTemplateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailTemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, emailtemplate.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *EmailTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailTemplateMutation) ResetName() {
	m.name = nil
}

// SetSubject sets the "subject" field.
func (m *EmailTemplateMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailTemplateMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailTemplateMutation) ResetSubject() {
	m.subject = nil
}

// SetType sets the "type" field.
func (m *EmailTemplateMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EmailTemplateMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EmailTemplateMutation) ResetType() {
	m._type = nil
}

// SetHTMLContent sets the "html_content" field.
func (m *EmailTemplateMutation) SetHTMLContent(s string) {
	m.html_content = &s
}

// HTMLContent returns the value of the "html_content" field in the mutation.
func (m *EmailTemplateMutation) HTMLContent() (r string, exists bool) {
	v := m.html_content
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLContent returns the old "html_content" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldHTMLContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLContent: %w", err)
	}
	return oldValue.HTMLContent, nil
}

// ResetHTMLContent resets all changes to the "html_content" field.
func (m *EmailTemplateMutation) ResetHTMLContent() {
	m.html_content = nil
}

// SetTextContent sets the "text_content" field.
func (m *EmailTemplateMutation) SetTextContent(s string) {
	m.text_content = &s
}

// TextContent returns the value of the "text_content" field in the mutation.
func (m *EmailTemplateMutation) TextContent() (r string, exists bool) {
	v := m.text_content
	if v == nil {
		return
	}
	return *v, true
}

// OldTextContent returns the old "text_content" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldTextContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextContent: %w", err)
	}
	return oldValue.TextContent, nil
}

// ClearTextContent clears the value of the "text_content" field.
func (m *EmailTemplateMutation) ClearTextContent() {
	m.text_content = nil
	m.clearedFields[emailtemplate.FieldTextContent] = struct{}{}
}

// TextContentCleared returns if the "text_content" field was cleared in this mutation.
func (m *EmailTemplateMutation) TextContentCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldTextContent]
	return ok
}

// ResetTextContent resets all changes to the "text_content" field.
func (m *EmailTemplateMutation) ResetTextContent() {
	m.text_content = nil
	delete(m.clearedFields, emailtemplate.FieldTextContent)
}

// SetOrganizationID sets the "organization_id" field.
func (m *EmailTemplateMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EmailTemplateMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *EmailTemplateMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[emailtemplate.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *EmailTemplateMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EmailTemplateMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, emailtemplate.FieldOrganizationID)
}

// SetActive sets the "active" field.
func (m *EmailTemplateMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *EmailTemplateMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *EmailTemplateMutation) ResetActive() {
	m.active = nil
}

// SetSystem sets the "system" field.
func (m *EmailTemplateMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *EmailTemplateMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *EmailTemplateMutation) ResetSystem() {
	m.system = nil
}

// SetLocale sets the "locale" field.
func (m *EmailTemplateMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *EmailTemplateMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *EmailTemplateMutation) ResetLocale() {
	m.locale = nil
}

// SetMetadata sets the "metadata" field.
func (m *EmailTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EmailTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EmailTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[emailtemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EmailTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EmailTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, emailtemplate.FieldMetadata)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EmailTemplateMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[emailtemplate.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EmailTemplateMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EmailTemplateMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EmailTemplateMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EmailTemplateMutation builder.
func (m *EmailTemplateMutation) Where(ps ...predicate.EmailTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailTemplate).
func (m *EmailTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailTemplateMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, emailtemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailtemplate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, emailtemplate.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, emailtemplate.FieldName)
	}
	if m.subject != nil {
		fields = append(fields, emailtemplate.FieldSubject)
	}
	if m._type != nil {
		fields = append(fields, emailtemplate.FieldType)
	}
	if m.html_content != nil {
		fields = append(fields, emailtemplate.FieldHTMLContent)
	}
	if m.text_content != nil {
		fields = append(fields, emailtemplate.FieldTextContent)
	}
	if m.organization != nil {
		fields = append(fields, emailtemplate.FieldOrganizationID)
	}
	if m.active != nil {
		fields = append(fields, emailtemplate.FieldActive)
	}
	if m.system != nil {
		fields = append(fields, emailtemplate.FieldSystem)
	}
	if m.locale != nil {
		fields = append(fields, emailtemplate.FieldLocale)
	}
	if m.metadata != nil {
		fields = append(fields, emailtemplate.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailtemplate.FieldCreatedAt:
		return m.CreatedAt()
	case emailtemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailtemplate.FieldDeletedAt:
		return m.DeletedAt()
	case emailtemplate.FieldName:
		return m.Name()
	case emailtemplate.FieldSubject:
		return m.Subject()
	case emailtemplate.FieldType:
		return m.GetType()
	case emailtemplate.FieldHTMLContent:
		return m.HTMLContent()
	case emailtemplate.FieldTextContent:
		return m.TextContent()
	case emailtemplate.FieldOrganizationID:
		return m.OrganizationID()
	case emailtemplate.FieldActive:
		return m.Active()
	case emailtemplate.FieldSystem:
		return m.System()
	case emailtemplate.FieldLocale:
		return m.Locale()
	case emailtemplate.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailtemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailtemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailtemplate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case emailtemplate.FieldName:
		return m.OldName(ctx)
	case emailtemplate.FieldSubject:
		return m.OldSubject(ctx)
	case emailtemplate.FieldType:
		return m.OldType(ctx)
	case emailtemplate.FieldHTMLContent:
		return m.OldHTMLContent(ctx)
	case emailtemplate.FieldTextContent:
		return m.OldTextContent(ctx)
	case emailtemplate.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case emailtemplate.FieldActive:
		return m.OldActive(ctx)
	case emailtemplate.FieldSystem:
		return m.OldSystem(ctx)
	case emailtemplate.FieldLocale:
		return m.OldLocale(ctx)
	case emailtemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown EmailTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailtemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailtemplate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case emailtemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailtemplate.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case emailtemplate.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case emailtemplate.FieldHTMLContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLContent(v)
		return nil
	case emailtemplate.FieldTextContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextContent(v)
		return nil
	case emailtemplate.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case emailtemplate.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case emailtemplate.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case emailtemplate.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case emailtemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailtemplate.FieldDeletedAt) {
		fields = append(fields, emailtemplate.FieldDeletedAt)
	}
	if m.FieldCleared(emailtemplate.FieldTextContent) {
		fields = append(fields, emailtemplate.FieldTextContent)
	}
	if m.FieldCleared(emailtemplate.FieldOrganizationID) {
		fields = append(fields, emailtemplate.FieldOrganizationID)
	}
	if m.FieldCleared(emailtemplate.FieldMetadata) {
		fields = append(fields, emailtemplate.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ClearField(name string) error {
	switch name {
	case emailtemplate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case emailtemplate.FieldTextContent:
		m.ClearTextContent()
		return nil
	case emailtemplate.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case emailtemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ResetField(name string) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailtemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailtemplate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case emailtemplate.FieldName:
		m.ResetName()
		return nil
	case emailtemplate.FieldSubject:
		m.ResetSubject()
		return nil
	case emailtemplate.FieldType:
		m.ResetType()
		return nil
	case emailtemplate.FieldHTMLContent:
		m.ResetHTMLContent()
		return nil
	case emailtemplate.FieldTextContent:
		m.ResetTextContent()
		return nil
	case emailtemplate.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case emailtemplate.FieldActive:
		m.ResetActive()
		return nil
	case emailtemplate.FieldSystem:
		m.ResetSystem()
		return nil
	case emailtemplate.FieldLocale:
		m.ResetLocale()
		return nil
	case emailtemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, emailtemplate.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailtemplate.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, emailtemplate.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case emailtemplate.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailTemplateMutation) ClearEdge(name string) error {
	switch name {
	case emailtemplate.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailTemplateMutation) ResetEdge(name string) error {
	switch name {
	case emailtemplate.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate edge %s", name)
}

// FeatureFlagMutation represents an operation that mutates the FeatureFlag nodes in the graph.
type FeatureFlagMutation struct {
	config
	op                           Op
	typ                          string
	id                           *xid.ID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	key                          *string
	description                  *string
	enabled                      *bool
	is_premium                   *bool
	component                    *featureflag.Component
	clearedFields                map[string]struct{}
	organization_features        map[xid.ID]struct{}
	removedorganization_features map[xid.ID]struct{}
	clearedorganization_features bool
	done                         bool
	oldValue                     func(context.Context) (*FeatureFlag, error)
	predicates                   []predicate.FeatureFlag
}

var _ ent.Mutation = (*FeatureFlagMutation)(nil)

// featureflagOption allows management of the mutation configuration using functional options.
type featureflagOption func(*FeatureFlagMutation)

// newFeatureFlagMutation creates new mutation for the FeatureFlag entity.
func newFeatureFlagMutation(c config, op Op, opts ...featureflagOption) *FeatureFlagMutation {
	m := &FeatureFlagMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureFlagID sets the ID field of the mutation.
func withFeatureFlagID(id xid.ID) featureflagOption {
	return func(m *FeatureFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureFlag
		)
		m.oldValue = func(ctx context.Context) (*FeatureFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureFlag sets the old FeatureFlag of the mutation.
func withFeatureFlag(node *FeatureFlag) featureflagOption {
	return func(m *FeatureFlagMutation) {
		m.oldValue = func(context.Context) (*FeatureFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureFlag entities.
func (m *FeatureFlagMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureFlagMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureFlagMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureFlagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureFlagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureFlagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureFlagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureFlagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureFlagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureFlagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureFlagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureFlagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featureflag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureFlagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featureflag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureFlagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featureflag.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *FeatureFlagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureFlagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureFlagMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *FeatureFlagMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FeatureFlagMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FeatureFlagMutation) ResetKey() {
	m.key = nil
}

// SetDescription sets the "description" field.
func (m *FeatureFlagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureFlagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeatureFlagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[featureflag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeatureFlagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[featureflag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureFlagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, featureflag.FieldDescription)
}

// SetEnabled sets the "enabled" field.
func (m *FeatureFlagMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FeatureFlagMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FeatureFlagMutation) ResetEnabled() {
	m.enabled = nil
}

// SetIsPremium sets the "is_premium" field.
func (m *FeatureFlagMutation) SetIsPremium(b bool) {
	m.is_premium = &b
}

// IsPremium returns the value of the "is_premium" field in the mutation.
func (m *FeatureFlagMutation) IsPremium() (r bool, exists bool) {
	v := m.is_premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_premium" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_premium" field.
func (m *FeatureFlagMutation) ResetIsPremium() {
	m.is_premium = nil
}

// SetComponent sets the "component" field.
func (m *FeatureFlagMutation) SetComponent(f featureflag.Component) {
	m.component = &f
}

// Component returns the value of the "component" field in the mutation.
func (m *FeatureFlagMutation) Component() (r featureflag.Component, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldComponent(ctx context.Context) (v featureflag.Component, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent resets all changes to the "component" field.
func (m *FeatureFlagMutation) ResetComponent() {
	m.component = nil
}

// AddOrganizationFeatureIDs adds the "organization_features" edge to the OrganizationFeature entity by ids.
func (m *FeatureFlagMutation) AddOrganizationFeatureIDs(ids ...xid.ID) {
	if m.organization_features == nil {
		m.organization_features = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.organization_features[ids[i]] = struct{}{}
	}
}

// ClearOrganizationFeatures clears the "organization_features" edge to the OrganizationFeature entity.
func (m *FeatureFlagMutation) ClearOrganizationFeatures() {
	m.clearedorganization_features = true
}

// OrganizationFeaturesCleared reports if the "organization_features" edge to the OrganizationFeature entity was cleared.
func (m *FeatureFlagMutation) OrganizationFeaturesCleared() bool {
	return m.clearedorganization_features
}

// RemoveOrganizationFeatureIDs removes the "organization_features" edge to the OrganizationFeature entity by IDs.
func (m *FeatureFlagMutation) RemoveOrganizationFeatureIDs(ids ...xid.ID) {
	if m.removedorganization_features == nil {
		m.removedorganization_features = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.organization_features, ids[i])
		m.removedorganization_features[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationFeatures returns the removed IDs of the "organization_features" edge to the OrganizationFeature entity.
func (m *FeatureFlagMutation) RemovedOrganizationFeaturesIDs() (ids []xid.ID) {
	for id := range m.removedorganization_features {
		ids = append(ids, id)
	}
	return
}

// OrganizationFeaturesIDs returns the "organization_features" edge IDs in the mutation.
func (m *FeatureFlagMutation) OrganizationFeaturesIDs() (ids []xid.ID) {
	for id := range m.organization_features {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationFeatures resets all changes to the "organization_features" edge.
func (m *FeatureFlagMutation) ResetOrganizationFeatures() {
	m.organization_features = nil
	m.clearedorganization_features = false
	m.removedorganization_features = nil
}

// Where appends a list predicates to the FeatureFlagMutation builder.
func (m *FeatureFlagMutation) Where(ps ...predicate.FeatureFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureFlag).
func (m *FeatureFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureFlagMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, featureflag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featureflag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, featureflag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, featureflag.FieldName)
	}
	if m.key != nil {
		fields = append(fields, featureflag.FieldKey)
	}
	if m.description != nil {
		fields = append(fields, featureflag.FieldDescription)
	}
	if m.enabled != nil {
		fields = append(fields, featureflag.FieldEnabled)
	}
	if m.is_premium != nil {
		fields = append(fields, featureflag.FieldIsPremium)
	}
	if m.component != nil {
		fields = append(fields, featureflag.FieldComponent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featureflag.FieldCreatedAt:
		return m.CreatedAt()
	case featureflag.FieldUpdatedAt:
		return m.UpdatedAt()
	case featureflag.FieldDeletedAt:
		return m.DeletedAt()
	case featureflag.FieldName:
		return m.Name()
	case featureflag.FieldKey:
		return m.Key()
	case featureflag.FieldDescription:
		return m.Description()
	case featureflag.FieldEnabled:
		return m.Enabled()
	case featureflag.FieldIsPremium:
		return m.IsPremium()
	case featureflag.FieldComponent:
		return m.Component()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featureflag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featureflag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case featureflag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case featureflag.FieldName:
		return m.OldName(ctx)
	case featureflag.FieldKey:
		return m.OldKey(ctx)
	case featureflag.FieldDescription:
		return m.OldDescription(ctx)
	case featureflag.FieldEnabled:
		return m.OldEnabled(ctx)
	case featureflag.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case featureflag.FieldComponent:
		return m.OldComponent(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featureflag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featureflag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case featureflag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case featureflag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case featureflag.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case featureflag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case featureflag.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case featureflag.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case featureflag.FieldComponent:
		v, ok := value.(featureflag.Component)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureFlagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureFlagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureFlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featureflag.FieldDeletedAt) {
		fields = append(fields, featureflag.FieldDeletedAt)
	}
	if m.FieldCleared(featureflag.FieldDescription) {
		fields = append(fields, featureflag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ClearField(name string) error {
	switch name {
	case featureflag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case featureflag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ResetField(name string) error {
	switch name {
	case featureflag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featureflag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case featureflag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case featureflag.FieldName:
		m.ResetName()
		return nil
	case featureflag.FieldKey:
		m.ResetKey()
		return nil
	case featureflag.FieldDescription:
		m.ResetDescription()
		return nil
	case featureflag.FieldEnabled:
		m.ResetEnabled()
		return nil
	case featureflag.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case featureflag.FieldComponent:
		m.ResetComponent()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization_features != nil {
		edges = append(edges, featureflag.EdgeOrganizationFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureFlagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featureflag.EdgeOrganizationFeatures:
		ids := make([]ent.Value, 0, len(m.organization_features))
		for id := range m.organization_features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganization_features != nil {
		edges = append(edges, featureflag.EdgeOrganizationFeatures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureFlagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featureflag.EdgeOrganizationFeatures:
		ids := make([]ent.Value, 0, len(m.removedorganization_features))
		for id := range m.removedorganization_features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization_features {
		edges = append(edges, featureflag.EdgeOrganizationFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureFlagMutation) EdgeCleared(name string) bool {
	switch name {
	case featureflag.EdgeOrganizationFeatures:
		return m.clearedorganization_features
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureFlagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureFlagMutation) ResetEdge(name string) error {
	switch name {
	case featureflag.EdgeOrganizationFeatures:
		m.ResetOrganizationFeatures()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag edge %s", name)
}

// IdentityProviderMutation represents an operation that mutates the IdentityProvider nodes in the graph.
type IdentityProviderMutation struct {
	config
	op                            Op
	typ                           string
	id                            *xid.ID
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	name                          *string
	provider_type                 *string
	client_id                     *string
	client_secret                 *string
	issuer                        *string
	authorization_endpoint        *string
	token_endpoint                *string
	userinfo_endpoint             *string
	jwks_uri                      *string
	metadata_url                  *string
	redirect_uri                  *string
	certificate                   *string
	private_key                   *string
	active                        *bool
	enabled                       *bool
	primary                       *bool
	auto_provision                *bool
	default_role                  *string
	domain                        *string
	icon_url                      *string
	button_text                   *string
	protocol                      *string
	domains                       *[]string
	appenddomains                 []string
	attributes_mapping            *map[string]string
	metadata                      *map[string]interface{}
	clearedFields                 map[string]struct{}
	organization                  *xid.ID
	clearedorganization           bool
	organization_providers        map[xid.ID]struct{}
	removedorganization_providers map[xid.ID]struct{}
	clearedorganization_providers bool
	done                          bool
	oldValue                      func(context.Context) (*IdentityProvider, error)
	predicates                    []predicate.IdentityProvider
}

var _ ent.Mutation = (*IdentityProviderMutation)(nil)

// identityproviderOption allows management of the mutation configuration using functional options.
type identityproviderOption func(*IdentityProviderMutation)

// newIdentityProviderMutation creates new mutation for the IdentityProvider entity.
func newIdentityProviderMutation(c config, op Op, opts ...identityproviderOption) *IdentityProviderMutation {
	m := &IdentityProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentityProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityProviderID sets the ID field of the mutation.
func withIdentityProviderID(id xid.ID) identityproviderOption {
	return func(m *IdentityProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *IdentityProvider
		)
		m.oldValue = func(ctx context.Context) (*IdentityProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdentityProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentityProvider sets the old IdentityProvider of the mutation.
func withIdentityProvider(node *IdentityProvider) identityproviderOption {
	return func(m *IdentityProviderMutation) {
		m.oldValue = func(context.Context) (*IdentityProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdentityProvider entities.
func (m *IdentityProviderMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityProviderMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityProviderMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdentityProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IdentityProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdentityProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdentityProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IdentityProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IdentityProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IdentityProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IdentityProviderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IdentityProviderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IdentityProviderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[identityprovider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IdentityProviderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IdentityProviderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, identityprovider.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *IdentityProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IdentityProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IdentityProviderMutation) ResetName() {
	m.name = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *IdentityProviderMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *IdentityProviderMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *IdentityProviderMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetProviderType sets the "provider_type" field.
func (m *IdentityProviderMutation) SetProviderType(s string) {
	m.provider_type = &s
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *IdentityProviderMutation) ProviderType() (r string, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldProviderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *IdentityProviderMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetClientID sets the "client_id" field.
func (m *IdentityProviderMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *IdentityProviderMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *IdentityProviderMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[identityprovider.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *IdentityProviderMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *IdentityProviderMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, identityprovider.FieldClientID)
}

// SetClientSecret sets the "client_secret" field.
func (m *IdentityProviderMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *IdentityProviderMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *IdentityProviderMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[identityprovider.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *IdentityProviderMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *IdentityProviderMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, identityprovider.FieldClientSecret)
}

// SetIssuer sets the "issuer" field.
func (m *IdentityProviderMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *IdentityProviderMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ClearIssuer clears the value of the "issuer" field.
func (m *IdentityProviderMutation) ClearIssuer() {
	m.issuer = nil
	m.clearedFields[identityprovider.FieldIssuer] = struct{}{}
}

// IssuerCleared returns if the "issuer" field was cleared in this mutation.
func (m *IdentityProviderMutation) IssuerCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldIssuer]
	return ok
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *IdentityProviderMutation) ResetIssuer() {
	m.issuer = nil
	delete(m.clearedFields, identityprovider.FieldIssuer)
}

// SetAuthorizationEndpoint sets the "authorization_endpoint" field.
func (m *IdentityProviderMutation) SetAuthorizationEndpoint(s string) {
	m.authorization_endpoint = &s
}

// AuthorizationEndpoint returns the value of the "authorization_endpoint" field in the mutation.
func (m *IdentityProviderMutation) AuthorizationEndpoint() (r string, exists bool) {
	v := m.authorization_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationEndpoint returns the old "authorization_endpoint" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldAuthorizationEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationEndpoint: %w", err)
	}
	return oldValue.AuthorizationEndpoint, nil
}

// ClearAuthorizationEndpoint clears the value of the "authorization_endpoint" field.
func (m *IdentityProviderMutation) ClearAuthorizationEndpoint() {
	m.authorization_endpoint = nil
	m.clearedFields[identityprovider.FieldAuthorizationEndpoint] = struct{}{}
}

// AuthorizationEndpointCleared returns if the "authorization_endpoint" field was cleared in this mutation.
func (m *IdentityProviderMutation) AuthorizationEndpointCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldAuthorizationEndpoint]
	return ok
}

// ResetAuthorizationEndpoint resets all changes to the "authorization_endpoint" field.
func (m *IdentityProviderMutation) ResetAuthorizationEndpoint() {
	m.authorization_endpoint = nil
	delete(m.clearedFields, identityprovider.FieldAuthorizationEndpoint)
}

// SetTokenEndpoint sets the "token_endpoint" field.
func (m *IdentityProviderMutation) SetTokenEndpoint(s string) {
	m.token_endpoint = &s
}

// TokenEndpoint returns the value of the "token_endpoint" field in the mutation.
func (m *IdentityProviderMutation) TokenEndpoint() (r string, exists bool) {
	v := m.token_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenEndpoint returns the old "token_endpoint" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldTokenEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenEndpoint: %w", err)
	}
	return oldValue.TokenEndpoint, nil
}

// ClearTokenEndpoint clears the value of the "token_endpoint" field.
func (m *IdentityProviderMutation) ClearTokenEndpoint() {
	m.token_endpoint = nil
	m.clearedFields[identityprovider.FieldTokenEndpoint] = struct{}{}
}

// TokenEndpointCleared returns if the "token_endpoint" field was cleared in this mutation.
func (m *IdentityProviderMutation) TokenEndpointCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldTokenEndpoint]
	return ok
}

// ResetTokenEndpoint resets all changes to the "token_endpoint" field.
func (m *IdentityProviderMutation) ResetTokenEndpoint() {
	m.token_endpoint = nil
	delete(m.clearedFields, identityprovider.FieldTokenEndpoint)
}

// SetUserinfoEndpoint sets the "userinfo_endpoint" field.
func (m *IdentityProviderMutation) SetUserinfoEndpoint(s string) {
	m.userinfo_endpoint = &s
}

// UserinfoEndpoint returns the value of the "userinfo_endpoint" field in the mutation.
func (m *IdentityProviderMutation) UserinfoEndpoint() (r string, exists bool) {
	v := m.userinfo_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldUserinfoEndpoint returns the old "userinfo_endpoint" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldUserinfoEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserinfoEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserinfoEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserinfoEndpoint: %w", err)
	}
	return oldValue.UserinfoEndpoint, nil
}

// ClearUserinfoEndpoint clears the value of the "userinfo_endpoint" field.
func (m *IdentityProviderMutation) ClearUserinfoEndpoint() {
	m.userinfo_endpoint = nil
	m.clearedFields[identityprovider.FieldUserinfoEndpoint] = struct{}{}
}

// UserinfoEndpointCleared returns if the "userinfo_endpoint" field was cleared in this mutation.
func (m *IdentityProviderMutation) UserinfoEndpointCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldUserinfoEndpoint]
	return ok
}

// ResetUserinfoEndpoint resets all changes to the "userinfo_endpoint" field.
func (m *IdentityProviderMutation) ResetUserinfoEndpoint() {
	m.userinfo_endpoint = nil
	delete(m.clearedFields, identityprovider.FieldUserinfoEndpoint)
}

// SetJwksURI sets the "jwks_uri" field.
func (m *IdentityProviderMutation) SetJwksURI(s string) {
	m.jwks_uri = &s
}

// JwksURI returns the value of the "jwks_uri" field in the mutation.
func (m *IdentityProviderMutation) JwksURI() (r string, exists bool) {
	v := m.jwks_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldJwksURI returns the old "jwks_uri" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldJwksURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJwksURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJwksURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJwksURI: %w", err)
	}
	return oldValue.JwksURI, nil
}

// ClearJwksURI clears the value of the "jwks_uri" field.
func (m *IdentityProviderMutation) ClearJwksURI() {
	m.jwks_uri = nil
	m.clearedFields[identityprovider.FieldJwksURI] = struct{}{}
}

// JwksURICleared returns if the "jwks_uri" field was cleared in this mutation.
func (m *IdentityProviderMutation) JwksURICleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldJwksURI]
	return ok
}

// ResetJwksURI resets all changes to the "jwks_uri" field.
func (m *IdentityProviderMutation) ResetJwksURI() {
	m.jwks_uri = nil
	delete(m.clearedFields, identityprovider.FieldJwksURI)
}

// SetMetadataURL sets the "metadata_url" field.
func (m *IdentityProviderMutation) SetMetadataURL(s string) {
	m.metadata_url = &s
}

// MetadataURL returns the value of the "metadata_url" field in the mutation.
func (m *IdentityProviderMutation) MetadataURL() (r string, exists bool) {
	v := m.metadata_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataURL returns the old "metadata_url" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldMetadataURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataURL: %w", err)
	}
	return oldValue.MetadataURL, nil
}

// ClearMetadataURL clears the value of the "metadata_url" field.
func (m *IdentityProviderMutation) ClearMetadataURL() {
	m.metadata_url = nil
	m.clearedFields[identityprovider.FieldMetadataURL] = struct{}{}
}

// MetadataURLCleared returns if the "metadata_url" field was cleared in this mutation.
func (m *IdentityProviderMutation) MetadataURLCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldMetadataURL]
	return ok
}

// ResetMetadataURL resets all changes to the "metadata_url" field.
func (m *IdentityProviderMutation) ResetMetadataURL() {
	m.metadata_url = nil
	delete(m.clearedFields, identityprovider.FieldMetadataURL)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *IdentityProviderMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *IdentityProviderMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *IdentityProviderMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[identityprovider.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *IdentityProviderMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *IdentityProviderMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, identityprovider.FieldRedirectURI)
}

// SetCertificate sets the "certificate" field.
func (m *IdentityProviderMutation) SetCertificate(s string) {
	m.certificate = &s
}

// Certificate returns the value of the "certificate" field in the mutation.
func (m *IdentityProviderMutation) Certificate() (r string, exists bool) {
	v := m.certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificate returns the old "certificate" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldCertificate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificate: %w", err)
	}
	return oldValue.Certificate, nil
}

// ClearCertificate clears the value of the "certificate" field.
func (m *IdentityProviderMutation) ClearCertificate() {
	m.certificate = nil
	m.clearedFields[identityprovider.FieldCertificate] = struct{}{}
}

// CertificateCleared returns if the "certificate" field was cleared in this mutation.
func (m *IdentityProviderMutation) CertificateCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldCertificate]
	return ok
}

// ResetCertificate resets all changes to the "certificate" field.
func (m *IdentityProviderMutation) ResetCertificate() {
	m.certificate = nil
	delete(m.clearedFields, identityprovider.FieldCertificate)
}

// SetPrivateKey sets the "private_key" field.
func (m *IdentityProviderMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *IdentityProviderMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ClearPrivateKey clears the value of the "private_key" field.
func (m *IdentityProviderMutation) ClearPrivateKey() {
	m.private_key = nil
	m.clearedFields[identityprovider.FieldPrivateKey] = struct{}{}
}

// PrivateKeyCleared returns if the "private_key" field was cleared in this mutation.
func (m *IdentityProviderMutation) PrivateKeyCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldPrivateKey]
	return ok
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *IdentityProviderMutation) ResetPrivateKey() {
	m.private_key = nil
	delete(m.clearedFields, identityprovider.FieldPrivateKey)
}

// SetActive sets the "active" field.
func (m *IdentityProviderMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *IdentityProviderMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *IdentityProviderMutation) ResetActive() {
	m.active = nil
}

// SetEnabled sets the "enabled" field.
func (m *IdentityProviderMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *IdentityProviderMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *IdentityProviderMutation) ResetEnabled() {
	m.enabled = nil
}

// SetPrimary sets the "primary" field.
func (m *IdentityProviderMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *IdentityProviderMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *IdentityProviderMutation) ResetPrimary() {
	m.primary = nil
}

// SetAutoProvision sets the "auto_provision" field.
func (m *IdentityProviderMutation) SetAutoProvision(b bool) {
	m.auto_provision = &b
}

// AutoProvision returns the value of the "auto_provision" field in the mutation.
func (m *IdentityProviderMutation) AutoProvision() (r bool, exists bool) {
	v := m.auto_provision
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoProvision returns the old "auto_provision" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldAutoProvision(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoProvision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoProvision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoProvision: %w", err)
	}
	return oldValue.AutoProvision, nil
}

// ResetAutoProvision resets all changes to the "auto_provision" field.
func (m *IdentityProviderMutation) ResetAutoProvision() {
	m.auto_provision = nil
}

// SetDefaultRole sets the "default_role" field.
func (m *IdentityProviderMutation) SetDefaultRole(s string) {
	m.default_role = &s
}

// DefaultRole returns the value of the "default_role" field in the mutation.
func (m *IdentityProviderMutation) DefaultRole() (r string, exists bool) {
	v := m.default_role
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRole returns the old "default_role" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldDefaultRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRole: %w", err)
	}
	return oldValue.DefaultRole, nil
}

// ClearDefaultRole clears the value of the "default_role" field.
func (m *IdentityProviderMutation) ClearDefaultRole() {
	m.default_role = nil
	m.clearedFields[identityprovider.FieldDefaultRole] = struct{}{}
}

// DefaultRoleCleared returns if the "default_role" field was cleared in this mutation.
func (m *IdentityProviderMutation) DefaultRoleCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldDefaultRole]
	return ok
}

// ResetDefaultRole resets all changes to the "default_role" field.
func (m *IdentityProviderMutation) ResetDefaultRole() {
	m.default_role = nil
	delete(m.clearedFields, identityprovider.FieldDefaultRole)
}

// SetDomain sets the "domain" field.
func (m *IdentityProviderMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *IdentityProviderMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *IdentityProviderMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[identityprovider.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *IdentityProviderMutation) DomainCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *IdentityProviderMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, identityprovider.FieldDomain)
}

// SetIconURL sets the "icon_url" field.
func (m *IdentityProviderMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *IdentityProviderMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *IdentityProviderMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[identityprovider.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *IdentityProviderMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *IdentityProviderMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, identityprovider.FieldIconURL)
}

// SetButtonText sets the "button_text" field.
func (m *IdentityProviderMutation) SetButtonText(s string) {
	m.button_text = &s
}

// ButtonText returns the value of the "button_text" field in the mutation.
func (m *IdentityProviderMutation) ButtonText() (r string, exists bool) {
	v := m.button_text
	if v == nil {
		return
	}
	return *v, true
}

// OldButtonText returns the old "button_text" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldButtonText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldButtonText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldButtonText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldButtonText: %w", err)
	}
	return oldValue.ButtonText, nil
}

// ClearButtonText clears the value of the "button_text" field.
func (m *IdentityProviderMutation) ClearButtonText() {
	m.button_text = nil
	m.clearedFields[identityprovider.FieldButtonText] = struct{}{}
}

// ButtonTextCleared returns if the "button_text" field was cleared in this mutation.
func (m *IdentityProviderMutation) ButtonTextCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldButtonText]
	return ok
}

// ResetButtonText resets all changes to the "button_text" field.
func (m *IdentityProviderMutation) ResetButtonText() {
	m.button_text = nil
	delete(m.clearedFields, identityprovider.FieldButtonText)
}

// SetProtocol sets the "protocol" field.
func (m *IdentityProviderMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *IdentityProviderMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ClearProtocol clears the value of the "protocol" field.
func (m *IdentityProviderMutation) ClearProtocol() {
	m.protocol = nil
	m.clearedFields[identityprovider.FieldProtocol] = struct{}{}
}

// ProtocolCleared returns if the "protocol" field was cleared in this mutation.
func (m *IdentityProviderMutation) ProtocolCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldProtocol]
	return ok
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *IdentityProviderMutation) ResetProtocol() {
	m.protocol = nil
	delete(m.clearedFields, identityprovider.FieldProtocol)
}

// SetDomains sets the "domains" field.
func (m *IdentityProviderMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *IdentityProviderMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *IdentityProviderMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *IdentityProviderMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *IdentityProviderMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[identityprovider.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *IdentityProviderMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *IdentityProviderMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, identityprovider.FieldDomains)
}

// SetAttributesMapping sets the "attributes_mapping" field.
func (m *IdentityProviderMutation) SetAttributesMapping(value map[string]string) {
	m.attributes_mapping = &value
}

// AttributesMapping returns the value of the "attributes_mapping" field in the mutation.
func (m *IdentityProviderMutation) AttributesMapping() (r map[string]string, exists bool) {
	v := m.attributes_mapping
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributesMapping returns the old "attributes_mapping" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldAttributesMapping(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributesMapping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributesMapping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributesMapping: %w", err)
	}
	return oldValue.AttributesMapping, nil
}

// ClearAttributesMapping clears the value of the "attributes_mapping" field.
func (m *IdentityProviderMutation) ClearAttributesMapping() {
	m.attributes_mapping = nil
	m.clearedFields[identityprovider.FieldAttributesMapping] = struct{}{}
}

// AttributesMappingCleared returns if the "attributes_mapping" field was cleared in this mutation.
func (m *IdentityProviderMutation) AttributesMappingCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldAttributesMapping]
	return ok
}

// ResetAttributesMapping resets all changes to the "attributes_mapping" field.
func (m *IdentityProviderMutation) ResetAttributesMapping() {
	m.attributes_mapping = nil
	delete(m.clearedFields, identityprovider.FieldAttributesMapping)
}

// SetMetadata sets the "metadata" field.
func (m *IdentityProviderMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IdentityProviderMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IdentityProviderMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[identityprovider.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IdentityProviderMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IdentityProviderMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, identityprovider.FieldMetadata)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *IdentityProviderMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[identityprovider.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *IdentityProviderMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *IdentityProviderMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *IdentityProviderMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddOrganizationProviderIDs adds the "organization_providers" edge to the OrganizationProvider entity by ids.
func (m *IdentityProviderMutation) AddOrganizationProviderIDs(ids ...xid.ID) {
	if m.organization_providers == nil {
		m.organization_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.organization_providers[ids[i]] = struct{}{}
	}
}

// ClearOrganizationProviders clears the "organization_providers" edge to the OrganizationProvider entity.
func (m *IdentityProviderMutation) ClearOrganizationProviders() {
	m.clearedorganization_providers = true
}

// OrganizationProvidersCleared reports if the "organization_providers" edge to the OrganizationProvider entity was cleared.
func (m *IdentityProviderMutation) OrganizationProvidersCleared() bool {
	return m.clearedorganization_providers
}

// RemoveOrganizationProviderIDs removes the "organization_providers" edge to the OrganizationProvider entity by IDs.
func (m *IdentityProviderMutation) RemoveOrganizationProviderIDs(ids ...xid.ID) {
	if m.removedorganization_providers == nil {
		m.removedorganization_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.organization_providers, ids[i])
		m.removedorganization_providers[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationProviders returns the removed IDs of the "organization_providers" edge to the OrganizationProvider entity.
func (m *IdentityProviderMutation) RemovedOrganizationProvidersIDs() (ids []xid.ID) {
	for id := range m.removedorganization_providers {
		ids = append(ids, id)
	}
	return
}

// OrganizationProvidersIDs returns the "organization_providers" edge IDs in the mutation.
func (m *IdentityProviderMutation) OrganizationProvidersIDs() (ids []xid.ID) {
	for id := range m.organization_providers {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationProviders resets all changes to the "organization_providers" edge.
func (m *IdentityProviderMutation) ResetOrganizationProviders() {
	m.organization_providers = nil
	m.clearedorganization_providers = false
	m.removedorganization_providers = nil
}

// Where appends a list predicates to the IdentityProviderMutation builder.
func (m *IdentityProviderMutation) Where(ps ...predicate.IdentityProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentityProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentityProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdentityProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentityProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentityProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdentityProvider).
func (m *IdentityProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityProviderMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, identityprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, identityprovider.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, identityprovider.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, identityprovider.FieldName)
	}
	if m.organization != nil {
		fields = append(fields, identityprovider.FieldOrganizationID)
	}
	if m.provider_type != nil {
		fields = append(fields, identityprovider.FieldProviderType)
	}
	if m.client_id != nil {
		fields = append(fields, identityprovider.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, identityprovider.FieldClientSecret)
	}
	if m.issuer != nil {
		fields = append(fields, identityprovider.FieldIssuer)
	}
	if m.authorization_endpoint != nil {
		fields = append(fields, identityprovider.FieldAuthorizationEndpoint)
	}
	if m.token_endpoint != nil {
		fields = append(fields, identityprovider.FieldTokenEndpoint)
	}
	if m.userinfo_endpoint != nil {
		fields = append(fields, identityprovider.FieldUserinfoEndpoint)
	}
	if m.jwks_uri != nil {
		fields = append(fields, identityprovider.FieldJwksURI)
	}
	if m.metadata_url != nil {
		fields = append(fields, identityprovider.FieldMetadataURL)
	}
	if m.redirect_uri != nil {
		fields = append(fields, identityprovider.FieldRedirectURI)
	}
	if m.certificate != nil {
		fields = append(fields, identityprovider.FieldCertificate)
	}
	if m.private_key != nil {
		fields = append(fields, identityprovider.FieldPrivateKey)
	}
	if m.active != nil {
		fields = append(fields, identityprovider.FieldActive)
	}
	if m.enabled != nil {
		fields = append(fields, identityprovider.FieldEnabled)
	}
	if m.primary != nil {
		fields = append(fields, identityprovider.FieldPrimary)
	}
	if m.auto_provision != nil {
		fields = append(fields, identityprovider.FieldAutoProvision)
	}
	if m.default_role != nil {
		fields = append(fields, identityprovider.FieldDefaultRole)
	}
	if m.domain != nil {
		fields = append(fields, identityprovider.FieldDomain)
	}
	if m.icon_url != nil {
		fields = append(fields, identityprovider.FieldIconURL)
	}
	if m.button_text != nil {
		fields = append(fields, identityprovider.FieldButtonText)
	}
	if m.protocol != nil {
		fields = append(fields, identityprovider.FieldProtocol)
	}
	if m.domains != nil {
		fields = append(fields, identityprovider.FieldDomains)
	}
	if m.attributes_mapping != nil {
		fields = append(fields, identityprovider.FieldAttributesMapping)
	}
	if m.metadata != nil {
		fields = append(fields, identityprovider.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identityprovider.FieldCreatedAt:
		return m.CreatedAt()
	case identityprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case identityprovider.FieldDeletedAt:
		return m.DeletedAt()
	case identityprovider.FieldName:
		return m.Name()
	case identityprovider.FieldOrganizationID:
		return m.OrganizationID()
	case identityprovider.FieldProviderType:
		return m.ProviderType()
	case identityprovider.FieldClientID:
		return m.ClientID()
	case identityprovider.FieldClientSecret:
		return m.ClientSecret()
	case identityprovider.FieldIssuer:
		return m.Issuer()
	case identityprovider.FieldAuthorizationEndpoint:
		return m.AuthorizationEndpoint()
	case identityprovider.FieldTokenEndpoint:
		return m.TokenEndpoint()
	case identityprovider.FieldUserinfoEndpoint:
		return m.UserinfoEndpoint()
	case identityprovider.FieldJwksURI:
		return m.JwksURI()
	case identityprovider.FieldMetadataURL:
		return m.MetadataURL()
	case identityprovider.FieldRedirectURI:
		return m.RedirectURI()
	case identityprovider.FieldCertificate:
		return m.Certificate()
	case identityprovider.FieldPrivateKey:
		return m.PrivateKey()
	case identityprovider.FieldActive:
		return m.Active()
	case identityprovider.FieldEnabled:
		return m.Enabled()
	case identityprovider.FieldPrimary:
		return m.Primary()
	case identityprovider.FieldAutoProvision:
		return m.AutoProvision()
	case identityprovider.FieldDefaultRole:
		return m.DefaultRole()
	case identityprovider.FieldDomain:
		return m.Domain()
	case identityprovider.FieldIconURL:
		return m.IconURL()
	case identityprovider.FieldButtonText:
		return m.ButtonText()
	case identityprovider.FieldProtocol:
		return m.Protocol()
	case identityprovider.FieldDomains:
		return m.Domains()
	case identityprovider.FieldAttributesMapping:
		return m.AttributesMapping()
	case identityprovider.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identityprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case identityprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case identityprovider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case identityprovider.FieldName:
		return m.OldName(ctx)
	case identityprovider.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case identityprovider.FieldProviderType:
		return m.OldProviderType(ctx)
	case identityprovider.FieldClientID:
		return m.OldClientID(ctx)
	case identityprovider.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case identityprovider.FieldIssuer:
		return m.OldIssuer(ctx)
	case identityprovider.FieldAuthorizationEndpoint:
		return m.OldAuthorizationEndpoint(ctx)
	case identityprovider.FieldTokenEndpoint:
		return m.OldTokenEndpoint(ctx)
	case identityprovider.FieldUserinfoEndpoint:
		return m.OldUserinfoEndpoint(ctx)
	case identityprovider.FieldJwksURI:
		return m.OldJwksURI(ctx)
	case identityprovider.FieldMetadataURL:
		return m.OldMetadataURL(ctx)
	case identityprovider.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case identityprovider.FieldCertificate:
		return m.OldCertificate(ctx)
	case identityprovider.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case identityprovider.FieldActive:
		return m.OldActive(ctx)
	case identityprovider.FieldEnabled:
		return m.OldEnabled(ctx)
	case identityprovider.FieldPrimary:
		return m.OldPrimary(ctx)
	case identityprovider.FieldAutoProvision:
		return m.OldAutoProvision(ctx)
	case identityprovider.FieldDefaultRole:
		return m.OldDefaultRole(ctx)
	case identityprovider.FieldDomain:
		return m.OldDomain(ctx)
	case identityprovider.FieldIconURL:
		return m.OldIconURL(ctx)
	case identityprovider.FieldButtonText:
		return m.OldButtonText(ctx)
	case identityprovider.FieldProtocol:
		return m.OldProtocol(ctx)
	case identityprovider.FieldDomains:
		return m.OldDomains(ctx)
	case identityprovider.FieldAttributesMapping:
		return m.OldAttributesMapping(ctx)
	case identityprovider.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown IdentityProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identityprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case identityprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case identityprovider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case identityprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case identityprovider.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case identityprovider.FieldProviderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case identityprovider.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case identityprovider.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case identityprovider.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case identityprovider.FieldAuthorizationEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationEndpoint(v)
		return nil
	case identityprovider.FieldTokenEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenEndpoint(v)
		return nil
	case identityprovider.FieldUserinfoEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserinfoEndpoint(v)
		return nil
	case identityprovider.FieldJwksURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJwksURI(v)
		return nil
	case identityprovider.FieldMetadataURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataURL(v)
		return nil
	case identityprovider.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case identityprovider.FieldCertificate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificate(v)
		return nil
	case identityprovider.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case identityprovider.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case identityprovider.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case identityprovider.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	case identityprovider.FieldAutoProvision:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoProvision(v)
		return nil
	case identityprovider.FieldDefaultRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRole(v)
		return nil
	case identityprovider.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case identityprovider.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case identityprovider.FieldButtonText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetButtonText(v)
		return nil
	case identityprovider.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case identityprovider.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case identityprovider.FieldAttributesMapping:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributesMapping(v)
		return nil
	case identityprovider.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IdentityProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(identityprovider.FieldDeletedAt) {
		fields = append(fields, identityprovider.FieldDeletedAt)
	}
	if m.FieldCleared(identityprovider.FieldClientID) {
		fields = append(fields, identityprovider.FieldClientID)
	}
	if m.FieldCleared(identityprovider.FieldClientSecret) {
		fields = append(fields, identityprovider.FieldClientSecret)
	}
	if m.FieldCleared(identityprovider.FieldIssuer) {
		fields = append(fields, identityprovider.FieldIssuer)
	}
	if m.FieldCleared(identityprovider.FieldAuthorizationEndpoint) {
		fields = append(fields, identityprovider.FieldAuthorizationEndpoint)
	}
	if m.FieldCleared(identityprovider.FieldTokenEndpoint) {
		fields = append(fields, identityprovider.FieldTokenEndpoint)
	}
	if m.FieldCleared(identityprovider.FieldUserinfoEndpoint) {
		fields = append(fields, identityprovider.FieldUserinfoEndpoint)
	}
	if m.FieldCleared(identityprovider.FieldJwksURI) {
		fields = append(fields, identityprovider.FieldJwksURI)
	}
	if m.FieldCleared(identityprovider.FieldMetadataURL) {
		fields = append(fields, identityprovider.FieldMetadataURL)
	}
	if m.FieldCleared(identityprovider.FieldRedirectURI) {
		fields = append(fields, identityprovider.FieldRedirectURI)
	}
	if m.FieldCleared(identityprovider.FieldCertificate) {
		fields = append(fields, identityprovider.FieldCertificate)
	}
	if m.FieldCleared(identityprovider.FieldPrivateKey) {
		fields = append(fields, identityprovider.FieldPrivateKey)
	}
	if m.FieldCleared(identityprovider.FieldDefaultRole) {
		fields = append(fields, identityprovider.FieldDefaultRole)
	}
	if m.FieldCleared(identityprovider.FieldDomain) {
		fields = append(fields, identityprovider.FieldDomain)
	}
	if m.FieldCleared(identityprovider.FieldIconURL) {
		fields = append(fields, identityprovider.FieldIconURL)
	}
	if m.FieldCleared(identityprovider.FieldButtonText) {
		fields = append(fields, identityprovider.FieldButtonText)
	}
	if m.FieldCleared(identityprovider.FieldProtocol) {
		fields = append(fields, identityprovider.FieldProtocol)
	}
	if m.FieldCleared(identityprovider.FieldDomains) {
		fields = append(fields, identityprovider.FieldDomains)
	}
	if m.FieldCleared(identityprovider.FieldAttributesMapping) {
		fields = append(fields, identityprovider.FieldAttributesMapping)
	}
	if m.FieldCleared(identityprovider.FieldMetadata) {
		fields = append(fields, identityprovider.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityProviderMutation) ClearField(name string) error {
	switch name {
	case identityprovider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case identityprovider.FieldClientID:
		m.ClearClientID()
		return nil
	case identityprovider.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case identityprovider.FieldIssuer:
		m.ClearIssuer()
		return nil
	case identityprovider.FieldAuthorizationEndpoint:
		m.ClearAuthorizationEndpoint()
		return nil
	case identityprovider.FieldTokenEndpoint:
		m.ClearTokenEndpoint()
		return nil
	case identityprovider.FieldUserinfoEndpoint:
		m.ClearUserinfoEndpoint()
		return nil
	case identityprovider.FieldJwksURI:
		m.ClearJwksURI()
		return nil
	case identityprovider.FieldMetadataURL:
		m.ClearMetadataURL()
		return nil
	case identityprovider.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	case identityprovider.FieldCertificate:
		m.ClearCertificate()
		return nil
	case identityprovider.FieldPrivateKey:
		m.ClearPrivateKey()
		return nil
	case identityprovider.FieldDefaultRole:
		m.ClearDefaultRole()
		return nil
	case identityprovider.FieldDomain:
		m.ClearDomain()
		return nil
	case identityprovider.FieldIconURL:
		m.ClearIconURL()
		return nil
	case identityprovider.FieldButtonText:
		m.ClearButtonText()
		return nil
	case identityprovider.FieldProtocol:
		m.ClearProtocol()
		return nil
	case identityprovider.FieldDomains:
		m.ClearDomains()
		return nil
	case identityprovider.FieldAttributesMapping:
		m.ClearAttributesMapping()
		return nil
	case identityprovider.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityProviderMutation) ResetField(name string) error {
	switch name {
	case identityprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case identityprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case identityprovider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case identityprovider.FieldName:
		m.ResetName()
		return nil
	case identityprovider.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case identityprovider.FieldProviderType:
		m.ResetProviderType()
		return nil
	case identityprovider.FieldClientID:
		m.ResetClientID()
		return nil
	case identityprovider.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case identityprovider.FieldIssuer:
		m.ResetIssuer()
		return nil
	case identityprovider.FieldAuthorizationEndpoint:
		m.ResetAuthorizationEndpoint()
		return nil
	case identityprovider.FieldTokenEndpoint:
		m.ResetTokenEndpoint()
		return nil
	case identityprovider.FieldUserinfoEndpoint:
		m.ResetUserinfoEndpoint()
		return nil
	case identityprovider.FieldJwksURI:
		m.ResetJwksURI()
		return nil
	case identityprovider.FieldMetadataURL:
		m.ResetMetadataURL()
		return nil
	case identityprovider.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case identityprovider.FieldCertificate:
		m.ResetCertificate()
		return nil
	case identityprovider.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case identityprovider.FieldActive:
		m.ResetActive()
		return nil
	case identityprovider.FieldEnabled:
		m.ResetEnabled()
		return nil
	case identityprovider.FieldPrimary:
		m.ResetPrimary()
		return nil
	case identityprovider.FieldAutoProvision:
		m.ResetAutoProvision()
		return nil
	case identityprovider.FieldDefaultRole:
		m.ResetDefaultRole()
		return nil
	case identityprovider.FieldDomain:
		m.ResetDomain()
		return nil
	case identityprovider.FieldIconURL:
		m.ResetIconURL()
		return nil
	case identityprovider.FieldButtonText:
		m.ResetButtonText()
		return nil
	case identityprovider.FieldProtocol:
		m.ResetProtocol()
		return nil
	case identityprovider.FieldDomains:
		m.ResetDomains()
		return nil
	case identityprovider.FieldAttributesMapping:
		m.ResetAttributesMapping()
		return nil
	case identityprovider.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, identityprovider.EdgeOrganization)
	}
	if m.organization_providers != nil {
		edges = append(edges, identityprovider.EdgeOrganizationProviders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identityprovider.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case identityprovider.EdgeOrganizationProviders:
		ids := make([]ent.Value, 0, len(m.organization_providers))
		for id := range m.organization_providers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorganization_providers != nil {
		edges = append(edges, identityprovider.EdgeOrganizationProviders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case identityprovider.EdgeOrganizationProviders:
		ids := make([]ent.Value, 0, len(m.removedorganization_providers))
		for id := range m.removedorganization_providers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, identityprovider.EdgeOrganization)
	}
	if m.clearedorganization_providers {
		edges = append(edges, identityprovider.EdgeOrganizationProviders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case identityprovider.EdgeOrganization:
		return m.clearedorganization
	case identityprovider.EdgeOrganizationProviders:
		return m.clearedorganization_providers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityProviderMutation) ClearEdge(name string) error {
	switch name {
	case identityprovider.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityProviderMutation) ResetEdge(name string) error {
	switch name {
	case identityprovider.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case identityprovider.EdgeOrganizationProviders:
		m.ResetOrganizationProviders()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider edge %s", name)
}

// MFAMutation represents an operation that mutates the MFA nodes in the graph.
type MFAMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	method             *string
	secret             *string
	verified           *bool
	active             *bool
	backup_codes       *[]string
	appendbackup_codes []string
	phone_number       *string
	email              *string
	last_used          *time.Time
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	user               *xid.ID
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*MFA, error)
	predicates         []predicate.MFA
}

var _ ent.Mutation = (*MFAMutation)(nil)

// mfaOption allows management of the mutation configuration using functional options.
type mfaOption func(*MFAMutation)

// newMFAMutation creates new mutation for the MFA entity.
func newMFAMutation(c config, op Op, opts ...mfaOption) *MFAMutation {
	m := &MFAMutation{
		config:        c,
		op:            op,
		typ:           TypeMFA,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMFAID sets the ID field of the mutation.
func withMFAID(id xid.ID) mfaOption {
	return func(m *MFAMutation) {
		var (
			err   error
			once  sync.Once
			value *MFA
		)
		m.oldValue = func(ctx context.Context) (*MFA, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MFA.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMFA sets the old MFA of the mutation.
func withMFA(node *MFA) mfaOption {
	return func(m *MFAMutation) {
		m.oldValue = func(context.Context) (*MFA, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MFAMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MFAMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MFA entities.
func (m *MFAMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MFAMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MFAMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MFA.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MFAMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MFAMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MFAMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MFAMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MFAMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MFAMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MFAMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MFAMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MFAMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mfa.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MFAMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mfa.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MFAMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mfa.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *MFAMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MFAMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MFAMutation) ResetUserID() {
	m.user = nil
}

// SetMethod sets the "method" field.
func (m *MFAMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *MFAMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *MFAMutation) ResetMethod() {
	m.method = nil
}

// SetSecret sets the "secret" field.
func (m *MFAMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *MFAMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *MFAMutation) ResetSecret() {
	m.secret = nil
}

// SetVerified sets the "verified" field.
func (m *MFAMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *MFAMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *MFAMutation) ResetVerified() {
	m.verified = nil
}

// SetActive sets the "active" field.
func (m *MFAMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *MFAMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *MFAMutation) ResetActive() {
	m.active = nil
}

// SetBackupCodes sets the "backup_codes" field.
func (m *MFAMutation) SetBackupCodes(s []string) {
	m.backup_codes = &s
	m.appendbackup_codes = nil
}

// BackupCodes returns the value of the "backup_codes" field in the mutation.
func (m *MFAMutation) BackupCodes() (r []string, exists bool) {
	v := m.backup_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupCodes returns the old "backup_codes" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldBackupCodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupCodes: %w", err)
	}
	return oldValue.BackupCodes, nil
}

// AppendBackupCodes adds s to the "backup_codes" field.
func (m *MFAMutation) AppendBackupCodes(s []string) {
	m.appendbackup_codes = append(m.appendbackup_codes, s...)
}

// AppendedBackupCodes returns the list of values that were appended to the "backup_codes" field in this mutation.
func (m *MFAMutation) AppendedBackupCodes() ([]string, bool) {
	if len(m.appendbackup_codes) == 0 {
		return nil, false
	}
	return m.appendbackup_codes, true
}

// ClearBackupCodes clears the value of the "backup_codes" field.
func (m *MFAMutation) ClearBackupCodes() {
	m.backup_codes = nil
	m.appendbackup_codes = nil
	m.clearedFields[mfa.FieldBackupCodes] = struct{}{}
}

// BackupCodesCleared returns if the "backup_codes" field was cleared in this mutation.
func (m *MFAMutation) BackupCodesCleared() bool {
	_, ok := m.clearedFields[mfa.FieldBackupCodes]
	return ok
}

// ResetBackupCodes resets all changes to the "backup_codes" field.
func (m *MFAMutation) ResetBackupCodes() {
	m.backup_codes = nil
	m.appendbackup_codes = nil
	delete(m.clearedFields, mfa.FieldBackupCodes)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *MFAMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *MFAMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *MFAMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[mfa.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *MFAMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[mfa.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *MFAMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, mfa.FieldPhoneNumber)
}

// SetEmail sets the "email" field.
func (m *MFAMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MFAMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MFAMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[mfa.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MFAMutation) EmailCleared() bool {
	_, ok := m.clearedFields[mfa.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MFAMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, mfa.FieldEmail)
}

// SetLastUsed sets the "last_used" field.
func (m *MFAMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *MFAMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *MFAMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[mfa.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *MFAMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[mfa.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *MFAMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, mfa.FieldLastUsed)
}

// SetMetadata sets the "metadata" field.
func (m *MFAMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MFAMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MFAMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[mfa.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MFAMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[mfa.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MFAMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, mfa.FieldMetadata)
}

// ClearUser clears the "user" edge to the User entity.
func (m *MFAMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mfa.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MFAMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MFAMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MFAMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MFAMutation builder.
func (m *MFAMutation) Where(ps ...predicate.MFA) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MFAMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MFAMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MFA, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MFAMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MFAMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MFA).
func (m *MFAMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MFAMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, mfa.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mfa.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mfa.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, mfa.FieldUserID)
	}
	if m.method != nil {
		fields = append(fields, mfa.FieldMethod)
	}
	if m.secret != nil {
		fields = append(fields, mfa.FieldSecret)
	}
	if m.verified != nil {
		fields = append(fields, mfa.FieldVerified)
	}
	if m.active != nil {
		fields = append(fields, mfa.FieldActive)
	}
	if m.backup_codes != nil {
		fields = append(fields, mfa.FieldBackupCodes)
	}
	if m.phone_number != nil {
		fields = append(fields, mfa.FieldPhoneNumber)
	}
	if m.email != nil {
		fields = append(fields, mfa.FieldEmail)
	}
	if m.last_used != nil {
		fields = append(fields, mfa.FieldLastUsed)
	}
	if m.metadata != nil {
		fields = append(fields, mfa.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MFAMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mfa.FieldCreatedAt:
		return m.CreatedAt()
	case mfa.FieldUpdatedAt:
		return m.UpdatedAt()
	case mfa.FieldDeletedAt:
		return m.DeletedAt()
	case mfa.FieldUserID:
		return m.UserID()
	case mfa.FieldMethod:
		return m.Method()
	case mfa.FieldSecret:
		return m.Secret()
	case mfa.FieldVerified:
		return m.Verified()
	case mfa.FieldActive:
		return m.Active()
	case mfa.FieldBackupCodes:
		return m.BackupCodes()
	case mfa.FieldPhoneNumber:
		return m.PhoneNumber()
	case mfa.FieldEmail:
		return m.Email()
	case mfa.FieldLastUsed:
		return m.LastUsed()
	case mfa.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MFAMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mfa.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mfa.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mfa.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mfa.FieldUserID:
		return m.OldUserID(ctx)
	case mfa.FieldMethod:
		return m.OldMethod(ctx)
	case mfa.FieldSecret:
		return m.OldSecret(ctx)
	case mfa.FieldVerified:
		return m.OldVerified(ctx)
	case mfa.FieldActive:
		return m.OldActive(ctx)
	case mfa.FieldBackupCodes:
		return m.OldBackupCodes(ctx)
	case mfa.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case mfa.FieldEmail:
		return m.OldEmail(ctx)
	case mfa.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case mfa.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown MFA field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFAMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mfa.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mfa.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mfa.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mfa.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mfa.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case mfa.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case mfa.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case mfa.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case mfa.FieldBackupCodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupCodes(v)
		return nil
	case mfa.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case mfa.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case mfa.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case mfa.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown MFA field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MFAMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MFAMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFAMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MFA numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MFAMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mfa.FieldDeletedAt) {
		fields = append(fields, mfa.FieldDeletedAt)
	}
	if m.FieldCleared(mfa.FieldBackupCodes) {
		fields = append(fields, mfa.FieldBackupCodes)
	}
	if m.FieldCleared(mfa.FieldPhoneNumber) {
		fields = append(fields, mfa.FieldPhoneNumber)
	}
	if m.FieldCleared(mfa.FieldEmail) {
		fields = append(fields, mfa.FieldEmail)
	}
	if m.FieldCleared(mfa.FieldLastUsed) {
		fields = append(fields, mfa.FieldLastUsed)
	}
	if m.FieldCleared(mfa.FieldMetadata) {
		fields = append(fields, mfa.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MFAMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MFAMutation) ClearField(name string) error {
	switch name {
	case mfa.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case mfa.FieldBackupCodes:
		m.ClearBackupCodes()
		return nil
	case mfa.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case mfa.FieldEmail:
		m.ClearEmail()
		return nil
	case mfa.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case mfa.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown MFA nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MFAMutation) ResetField(name string) error {
	switch name {
	case mfa.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mfa.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mfa.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mfa.FieldUserID:
		m.ResetUserID()
		return nil
	case mfa.FieldMethod:
		m.ResetMethod()
		return nil
	case mfa.FieldSecret:
		m.ResetSecret()
		return nil
	case mfa.FieldVerified:
		m.ResetVerified()
		return nil
	case mfa.FieldActive:
		m.ResetActive()
		return nil
	case mfa.FieldBackupCodes:
		m.ResetBackupCodes()
		return nil
	case mfa.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case mfa.FieldEmail:
		m.ResetEmail()
		return nil
	case mfa.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case mfa.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown MFA field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MFAMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, mfa.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MFAMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mfa.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MFAMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MFAMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MFAMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, mfa.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MFAMutation) EdgeCleared(name string) bool {
	switch name {
	case mfa.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MFAMutation) ClearEdge(name string) error {
	switch name {
	case mfa.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MFA unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MFAMutation) ResetEdge(name string) error {
	switch name {
	case mfa.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown MFA edge %s", name)
}

// MembershipMutation represents an operation that mutates the Membership nodes in the graph.
type MembershipMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	email               *string
	status              *model.MembershipStatus
	invited_at          *time.Time
	joined_at           *time.Time
	expires_at          *time.Time
	invitation_token    *string
	is_billing_contact  *bool
	is_primary_contact  *bool
	left_at             *time.Time
	metadata            *map[string]interface{}
	custom_fields       *map[string]interface{}
	clearedFields       map[string]struct{}
	user                *xid.ID
	cleareduser         bool
	organization        *xid.ID
	clearedorganization bool
	role                *xid.ID
	clearedrole         bool
	inviter             *xid.ID
	clearedinviter      bool
	done                bool
	oldValue            func(context.Context) (*Membership, error)
	predicates          []predicate.Membership
}

var _ ent.Mutation = (*MembershipMutation)(nil)

// membershipOption allows management of the mutation configuration using functional options.
type membershipOption func(*MembershipMutation)

// newMembershipMutation creates new mutation for the Membership entity.
func newMembershipMutation(c config, op Op, opts ...membershipOption) *MembershipMutation {
	m := &MembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipID sets the ID field of the mutation.
func withMembershipID(id xid.ID) membershipOption {
	return func(m *MembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *Membership
		)
		m.oldValue = func(ctx context.Context) (*Membership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Membership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembership sets the old Membership of the mutation.
func withMembership(node *Membership) membershipOption {
	return func(m *MembershipMutation) {
		m.oldValue = func(context.Context) (*Membership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Membership entities.
func (m *MembershipMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Membership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MembershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MembershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MembershipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MembershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MembershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MembershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MembershipMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MembershipMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MembershipMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[membership.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MembershipMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MembershipMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, membership.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *MembershipMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MembershipMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MembershipMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *MembershipMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *MembershipMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *MembershipMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetRoleID sets the "role_id" field.
func (m *MembershipMutation) SetRoleID(x xid.ID) {
	m.role = &x
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MembershipMutation) RoleID() (r xid.ID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldRoleID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MembershipMutation) ResetRoleID() {
	m.role = nil
}

// SetEmail sets the "email" field.
func (m *MembershipMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MembershipMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MembershipMutation) ResetEmail() {
	m.email = nil
}

// SetStatus sets the "status" field.
func (m *MembershipMutation) SetStatus(ms model.MembershipStatus) {
	m.status = &ms
}

// Status returns the value of the "status" field in the mutation.
func (m *MembershipMutation) Status() (r model.MembershipStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldStatus(ctx context.Context) (v model.MembershipStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MembershipMutation) ResetStatus() {
	m.status = nil
}

// SetInvitedBy sets the "invited_by" field.
func (m *MembershipMutation) SetInvitedBy(x xid.ID) {
	m.inviter = &x
}

// InvitedBy returns the value of the "invited_by" field in the mutation.
func (m *MembershipMutation) InvitedBy() (r xid.ID, exists bool) {
	v := m.inviter
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedBy returns the old "invited_by" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldInvitedBy(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedBy: %w", err)
	}
	return oldValue.InvitedBy, nil
}

// ClearInvitedBy clears the value of the "invited_by" field.
func (m *MembershipMutation) ClearInvitedBy() {
	m.inviter = nil
	m.clearedFields[membership.FieldInvitedBy] = struct{}{}
}

// InvitedByCleared returns if the "invited_by" field was cleared in this mutation.
func (m *MembershipMutation) InvitedByCleared() bool {
	_, ok := m.clearedFields[membership.FieldInvitedBy]
	return ok
}

// ResetInvitedBy resets all changes to the "invited_by" field.
func (m *MembershipMutation) ResetInvitedBy() {
	m.inviter = nil
	delete(m.clearedFields, membership.FieldInvitedBy)
}

// SetInvitedAt sets the "invited_at" field.
func (m *MembershipMutation) SetInvitedAt(t time.Time) {
	m.invited_at = &t
}

// InvitedAt returns the value of the "invited_at" field in the mutation.
func (m *MembershipMutation) InvitedAt() (r time.Time, exists bool) {
	v := m.invited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedAt returns the old "invited_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldInvitedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedAt: %w", err)
	}
	return oldValue.InvitedAt, nil
}

// ResetInvitedAt resets all changes to the "invited_at" field.
func (m *MembershipMutation) ResetInvitedAt() {
	m.invited_at = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *MembershipMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *MembershipMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldJoinedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ClearJoinedAt clears the value of the "joined_at" field.
func (m *MembershipMutation) ClearJoinedAt() {
	m.joined_at = nil
	m.clearedFields[membership.FieldJoinedAt] = struct{}{}
}

// JoinedAtCleared returns if the "joined_at" field was cleared in this mutation.
func (m *MembershipMutation) JoinedAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldJoinedAt]
	return ok
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *MembershipMutation) ResetJoinedAt() {
	m.joined_at = nil
	delete(m.clearedFields, membership.FieldJoinedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *MembershipMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *MembershipMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *MembershipMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[membership.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *MembershipMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *MembershipMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, membership.FieldExpiresAt)
}

// SetInvitationToken sets the "invitation_token" field.
func (m *MembershipMutation) SetInvitationToken(s string) {
	m.invitation_token = &s
}

// InvitationToken returns the value of the "invitation_token" field in the mutation.
func (m *MembershipMutation) InvitationToken() (r string, exists bool) {
	v := m.invitation_token
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationToken returns the old "invitation_token" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldInvitationToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationToken: %w", err)
	}
	return oldValue.InvitationToken, nil
}

// ClearInvitationToken clears the value of the "invitation_token" field.
func (m *MembershipMutation) ClearInvitationToken() {
	m.invitation_token = nil
	m.clearedFields[membership.FieldInvitationToken] = struct{}{}
}

// InvitationTokenCleared returns if the "invitation_token" field was cleared in this mutation.
func (m *MembershipMutation) InvitationTokenCleared() bool {
	_, ok := m.clearedFields[membership.FieldInvitationToken]
	return ok
}

// ResetInvitationToken resets all changes to the "invitation_token" field.
func (m *MembershipMutation) ResetInvitationToken() {
	m.invitation_token = nil
	delete(m.clearedFields, membership.FieldInvitationToken)
}

// SetIsBillingContact sets the "is_billing_contact" field.
func (m *MembershipMutation) SetIsBillingContact(b bool) {
	m.is_billing_contact = &b
}

// IsBillingContact returns the value of the "is_billing_contact" field in the mutation.
func (m *MembershipMutation) IsBillingContact() (r bool, exists bool) {
	v := m.is_billing_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBillingContact returns the old "is_billing_contact" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldIsBillingContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBillingContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBillingContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBillingContact: %w", err)
	}
	return oldValue.IsBillingContact, nil
}

// ResetIsBillingContact resets all changes to the "is_billing_contact" field.
func (m *MembershipMutation) ResetIsBillingContact() {
	m.is_billing_contact = nil
}

// SetIsPrimaryContact sets the "is_primary_contact" field.
func (m *MembershipMutation) SetIsPrimaryContact(b bool) {
	m.is_primary_contact = &b
}

// IsPrimaryContact returns the value of the "is_primary_contact" field in the mutation.
func (m *MembershipMutation) IsPrimaryContact() (r bool, exists bool) {
	v := m.is_primary_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimaryContact returns the old "is_primary_contact" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldIsPrimaryContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimaryContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimaryContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimaryContact: %w", err)
	}
	return oldValue.IsPrimaryContact, nil
}

// ResetIsPrimaryContact resets all changes to the "is_primary_contact" field.
func (m *MembershipMutation) ResetIsPrimaryContact() {
	m.is_primary_contact = nil
}

// SetLeftAt sets the "left_at" field.
func (m *MembershipMutation) SetLeftAt(t time.Time) {
	m.left_at = &t
}

// LeftAt returns the value of the "left_at" field in the mutation.
func (m *MembershipMutation) LeftAt() (r time.Time, exists bool) {
	v := m.left_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftAt returns the old "left_at" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldLeftAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftAt: %w", err)
	}
	return oldValue.LeftAt, nil
}

// ClearLeftAt clears the value of the "left_at" field.
func (m *MembershipMutation) ClearLeftAt() {
	m.left_at = nil
	m.clearedFields[membership.FieldLeftAt] = struct{}{}
}

// LeftAtCleared returns if the "left_at" field was cleared in this mutation.
func (m *MembershipMutation) LeftAtCleared() bool {
	_, ok := m.clearedFields[membership.FieldLeftAt]
	return ok
}

// ResetLeftAt resets all changes to the "left_at" field.
func (m *MembershipMutation) ResetLeftAt() {
	m.left_at = nil
	delete(m.clearedFields, membership.FieldLeftAt)
}

// SetMetadata sets the "metadata" field.
func (m *MembershipMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MembershipMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MembershipMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[membership.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MembershipMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[membership.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MembershipMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, membership.FieldMetadata)
}

// SetCustomFields sets the "custom_fields" field.
func (m *MembershipMutation) SetCustomFields(value map[string]interface{}) {
	m.custom_fields = &value
}

// CustomFields returns the value of the "custom_fields" field in the mutation.
func (m *MembershipMutation) CustomFields() (r map[string]interface{}, exists bool) {
	v := m.custom_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomFields returns the old "custom_fields" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCustomFields(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomFields: %w", err)
	}
	return oldValue.CustomFields, nil
}

// ClearCustomFields clears the value of the "custom_fields" field.
func (m *MembershipMutation) ClearCustomFields() {
	m.custom_fields = nil
	m.clearedFields[membership.FieldCustomFields] = struct{}{}
}

// CustomFieldsCleared returns if the "custom_fields" field was cleared in this mutation.
func (m *MembershipMutation) CustomFieldsCleared() bool {
	_, ok := m.clearedFields[membership.FieldCustomFields]
	return ok
}

// ResetCustomFields resets all changes to the "custom_fields" field.
func (m *MembershipMutation) ResetCustomFields() {
	m.custom_fields = nil
	delete(m.clearedFields, membership.FieldCustomFields)
}

// ClearUser clears the "user" edge to the User entity.
func (m *MembershipMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[membership.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MembershipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MembershipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *MembershipMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[membership.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *MembershipMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *MembershipMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *MembershipMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[membership.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *MembershipMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) RoleIDs() (ids []xid.ID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *MembershipMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetInviterID sets the "inviter" edge to the User entity by id.
func (m *MembershipMutation) SetInviterID(id xid.ID) {
	m.inviter = &id
}

// ClearInviter clears the "inviter" edge to the User entity.
func (m *MembershipMutation) ClearInviter() {
	m.clearedinviter = true
	m.clearedFields[membership.FieldInvitedBy] = struct{}{}
}

// InviterCleared reports if the "inviter" edge to the User entity was cleared.
func (m *MembershipMutation) InviterCleared() bool {
	return m.InvitedByCleared() || m.clearedinviter
}

// InviterID returns the "inviter" edge ID in the mutation.
func (m *MembershipMutation) InviterID() (id xid.ID, exists bool) {
	if m.inviter != nil {
		return *m.inviter, true
	}
	return
}

// InviterIDs returns the "inviter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviterID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) InviterIDs() (ids []xid.ID) {
	if id := m.inviter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInviter resets all changes to the "inviter" edge.
func (m *MembershipMutation) ResetInviter() {
	m.inviter = nil
	m.clearedinviter = false
}

// Where appends a list predicates to the MembershipMutation builder.
func (m *MembershipMutation) Where(ps ...predicate.Membership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Membership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Membership).
func (m *MembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, membership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membership.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, membership.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, membership.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, membership.FieldOrganizationID)
	}
	if m.role != nil {
		fields = append(fields, membership.FieldRoleID)
	}
	if m.email != nil {
		fields = append(fields, membership.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, membership.FieldStatus)
	}
	if m.inviter != nil {
		fields = append(fields, membership.FieldInvitedBy)
	}
	if m.invited_at != nil {
		fields = append(fields, membership.FieldInvitedAt)
	}
	if m.joined_at != nil {
		fields = append(fields, membership.FieldJoinedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, membership.FieldExpiresAt)
	}
	if m.invitation_token != nil {
		fields = append(fields, membership.FieldInvitationToken)
	}
	if m.is_billing_contact != nil {
		fields = append(fields, membership.FieldIsBillingContact)
	}
	if m.is_primary_contact != nil {
		fields = append(fields, membership.FieldIsPrimaryContact)
	}
	if m.left_at != nil {
		fields = append(fields, membership.FieldLeftAt)
	}
	if m.metadata != nil {
		fields = append(fields, membership.FieldMetadata)
	}
	if m.custom_fields != nil {
		fields = append(fields, membership.FieldCustomFields)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membership.FieldCreatedAt:
		return m.CreatedAt()
	case membership.FieldUpdatedAt:
		return m.UpdatedAt()
	case membership.FieldDeletedAt:
		return m.DeletedAt()
	case membership.FieldUserID:
		return m.UserID()
	case membership.FieldOrganizationID:
		return m.OrganizationID()
	case membership.FieldRoleID:
		return m.RoleID()
	case membership.FieldEmail:
		return m.Email()
	case membership.FieldStatus:
		return m.Status()
	case membership.FieldInvitedBy:
		return m.InvitedBy()
	case membership.FieldInvitedAt:
		return m.InvitedAt()
	case membership.FieldJoinedAt:
		return m.JoinedAt()
	case membership.FieldExpiresAt:
		return m.ExpiresAt()
	case membership.FieldInvitationToken:
		return m.InvitationToken()
	case membership.FieldIsBillingContact:
		return m.IsBillingContact()
	case membership.FieldIsPrimaryContact:
		return m.IsPrimaryContact()
	case membership.FieldLeftAt:
		return m.LeftAt()
	case membership.FieldMetadata:
		return m.Metadata()
	case membership.FieldCustomFields:
		return m.CustomFields()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membership.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case membership.FieldUserID:
		return m.OldUserID(ctx)
	case membership.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case membership.FieldRoleID:
		return m.OldRoleID(ctx)
	case membership.FieldEmail:
		return m.OldEmail(ctx)
	case membership.FieldStatus:
		return m.OldStatus(ctx)
	case membership.FieldInvitedBy:
		return m.OldInvitedBy(ctx)
	case membership.FieldInvitedAt:
		return m.OldInvitedAt(ctx)
	case membership.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case membership.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case membership.FieldInvitationToken:
		return m.OldInvitationToken(ctx)
	case membership.FieldIsBillingContact:
		return m.OldIsBillingContact(ctx)
	case membership.FieldIsPrimaryContact:
		return m.OldIsPrimaryContact(ctx)
	case membership.FieldLeftAt:
		return m.OldLeftAt(ctx)
	case membership.FieldMetadata:
		return m.OldMetadata(ctx)
	case membership.FieldCustomFields:
		return m.OldCustomFields(ctx)
	}
	return nil, fmt.Errorf("unknown Membership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membership.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case membership.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case membership.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case membership.FieldRoleID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case membership.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case membership.FieldStatus:
		v, ok := value.(model.MembershipStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membership.FieldInvitedBy:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedBy(v)
		return nil
	case membership.FieldInvitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedAt(v)
		return nil
	case membership.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case membership.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case membership.FieldInvitationToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationToken(v)
		return nil
	case membership.FieldIsBillingContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBillingContact(v)
		return nil
	case membership.FieldIsPrimaryContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimaryContact(v)
		return nil
	case membership.FieldLeftAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftAt(v)
		return nil
	case membership.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case membership.FieldCustomFields:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomFields(v)
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Membership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membership.FieldDeletedAt) {
		fields = append(fields, membership.FieldDeletedAt)
	}
	if m.FieldCleared(membership.FieldInvitedBy) {
		fields = append(fields, membership.FieldInvitedBy)
	}
	if m.FieldCleared(membership.FieldJoinedAt) {
		fields = append(fields, membership.FieldJoinedAt)
	}
	if m.FieldCleared(membership.FieldExpiresAt) {
		fields = append(fields, membership.FieldExpiresAt)
	}
	if m.FieldCleared(membership.FieldInvitationToken) {
		fields = append(fields, membership.FieldInvitationToken)
	}
	if m.FieldCleared(membership.FieldLeftAt) {
		fields = append(fields, membership.FieldLeftAt)
	}
	if m.FieldCleared(membership.FieldMetadata) {
		fields = append(fields, membership.FieldMetadata)
	}
	if m.FieldCleared(membership.FieldCustomFields) {
		fields = append(fields, membership.FieldCustomFields)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipMutation) ClearField(name string) error {
	switch name {
	case membership.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case membership.FieldInvitedBy:
		m.ClearInvitedBy()
		return nil
	case membership.FieldJoinedAt:
		m.ClearJoinedAt()
		return nil
	case membership.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case membership.FieldInvitationToken:
		m.ClearInvitationToken()
		return nil
	case membership.FieldLeftAt:
		m.ClearLeftAt()
		return nil
	case membership.FieldMetadata:
		m.ClearMetadata()
		return nil
	case membership.FieldCustomFields:
		m.ClearCustomFields()
		return nil
	}
	return fmt.Errorf("unknown Membership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipMutation) ResetField(name string) error {
	switch name {
	case membership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membership.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case membership.FieldUserID:
		m.ResetUserID()
		return nil
	case membership.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case membership.FieldRoleID:
		m.ResetRoleID()
		return nil
	case membership.FieldEmail:
		m.ResetEmail()
		return nil
	case membership.FieldStatus:
		m.ResetStatus()
		return nil
	case membership.FieldInvitedBy:
		m.ResetInvitedBy()
		return nil
	case membership.FieldInvitedAt:
		m.ResetInvitedAt()
		return nil
	case membership.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case membership.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case membership.FieldInvitationToken:
		m.ResetInvitationToken()
		return nil
	case membership.FieldIsBillingContact:
		m.ResetIsBillingContact()
		return nil
	case membership.FieldIsPrimaryContact:
		m.ResetIsPrimaryContact()
		return nil
	case membership.FieldLeftAt:
		m.ResetLeftAt()
		return nil
	case membership.FieldMetadata:
		m.ResetMetadata()
		return nil
	case membership.FieldCustomFields:
		m.ResetCustomFields()
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, membership.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, membership.EdgeOrganization)
	}
	if m.role != nil {
		edges = append(edges, membership.EdgeRole)
	}
	if m.inviter != nil {
		edges = append(edges, membership.EdgeInviter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membership.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case membership.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case membership.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case membership.EdgeInviter:
		if id := m.inviter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, membership.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, membership.EdgeOrganization)
	}
	if m.clearedrole {
		edges = append(edges, membership.EdgeRole)
	}
	if m.clearedinviter {
		edges = append(edges, membership.EdgeInviter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case membership.EdgeUser:
		return m.cleareduser
	case membership.EdgeOrganization:
		return m.clearedorganization
	case membership.EdgeRole:
		return m.clearedrole
	case membership.EdgeInviter:
		return m.clearedinviter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipMutation) ClearEdge(name string) error {
	switch name {
	case membership.EdgeUser:
		m.ClearUser()
		return nil
	case membership.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case membership.EdgeRole:
		m.ClearRole()
		return nil
	case membership.EdgeInviter:
		m.ClearInviter()
		return nil
	}
	return fmt.Errorf("unknown Membership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipMutation) ResetEdge(name string) error {
	switch name {
	case membership.EdgeUser:
		m.ResetUser()
		return nil
	case membership.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case membership.EdgeRole:
		m.ResetRole()
		return nil
	case membership.EdgeInviter:
		m.ResetInviter()
		return nil
	}
	return fmt.Errorf("unknown Membership edge %s", name)
}

// OAuthAuthorizationMutation represents an operation that mutates the OAuthAuthorization nodes in the graph.
type OAuthAuthorizationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *xid.ID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	organization_id       *xid.ID
	code                  *string
	code_challenge        *string
	code_challenge_method *string
	redirect_uri          *string
	scope_names           *[]string
	appendscope_names     []string
	used                  *bool
	used_at               *time.Time
	expires_at            *time.Time
	state                 *string
	nonce                 *string
	user_agent            *string
	ip_address            *string
	clearedFields         map[string]struct{}
	client                *xid.ID
	clearedclient         bool
	user                  *xid.ID
	cleareduser           bool
	scopes                map[xid.ID]struct{}
	removedscopes         map[xid.ID]struct{}
	clearedscopes         bool
	done                  bool
	oldValue              func(context.Context) (*OAuthAuthorization, error)
	predicates            []predicate.OAuthAuthorization
}

var _ ent.Mutation = (*OAuthAuthorizationMutation)(nil)

// oauthauthorizationOption allows management of the mutation configuration using functional options.
type oauthauthorizationOption func(*OAuthAuthorizationMutation)

// newOAuthAuthorizationMutation creates new mutation for the OAuthAuthorization entity.
func newOAuthAuthorizationMutation(c config, op Op, opts ...oauthauthorizationOption) *OAuthAuthorizationMutation {
	m := &OAuthAuthorizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthAuthorization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthAuthorizationID sets the ID field of the mutation.
func withOAuthAuthorizationID(id xid.ID) oauthauthorizationOption {
	return func(m *OAuthAuthorizationMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthAuthorization
		)
		m.oldValue = func(ctx context.Context) (*OAuthAuthorization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthAuthorization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthAuthorization sets the old OAuthAuthorization of the mutation.
func withOAuthAuthorization(node *OAuthAuthorization) oauthauthorizationOption {
	return func(m *OAuthAuthorizationMutation) {
		m.oldValue = func(context.Context) (*OAuthAuthorization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthAuthorizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthAuthorizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthAuthorization entities.
func (m *OAuthAuthorizationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthAuthorizationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthAuthorizationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthAuthorization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthAuthorizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthAuthorizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthAuthorizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthAuthorizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthAuthorizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthAuthorizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OAuthAuthorizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OAuthAuthorizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OAuthAuthorizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[oauthauthorization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OAuthAuthorizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, oauthauthorization.FieldDeletedAt)
}

// SetClientID sets the "client_id" field.
func (m *OAuthAuthorizationMutation) SetClientID(x xid.ID) {
	m.client = &x
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthAuthorizationMutation) ClientID() (r xid.ID, exists bool) {
	v := m.client
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldClientID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthAuthorizationMutation) ResetClientID() {
	m.client = nil
}

// SetUserID sets the "user_id" field.
func (m *OAuthAuthorizationMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OAuthAuthorizationMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OAuthAuthorizationMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OAuthAuthorizationMutation) SetOrganizationID(x xid.ID) {
	m.organization_id = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OAuthAuthorizationMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OAuthAuthorizationMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[oauthauthorization.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OAuthAuthorizationMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, oauthauthorization.FieldOrganizationID)
}

// SetCode sets the "code" field.
func (m *OAuthAuthorizationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OAuthAuthorizationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *OAuthAuthorizationMutation) ClearCode() {
	m.code = nil
	m.clearedFields[oauthauthorization.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) CodeCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *OAuthAuthorizationMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, oauthauthorization.FieldCode)
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *OAuthAuthorizationMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *OAuthAuthorizationMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ClearCodeChallenge clears the value of the "code_challenge" field.
func (m *OAuthAuthorizationMutation) ClearCodeChallenge() {
	m.code_challenge = nil
	m.clearedFields[oauthauthorization.FieldCodeChallenge] = struct{}{}
}

// CodeChallengeCleared returns if the "code_challenge" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) CodeChallengeCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldCodeChallenge]
	return ok
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *OAuthAuthorizationMutation) ResetCodeChallenge() {
	m.code_challenge = nil
	delete(m.clearedFields, oauthauthorization.FieldCodeChallenge)
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *OAuthAuthorizationMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *OAuthAuthorizationMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ClearCodeChallengeMethod clears the value of the "code_challenge_method" field.
func (m *OAuthAuthorizationMutation) ClearCodeChallengeMethod() {
	m.code_challenge_method = nil
	m.clearedFields[oauthauthorization.FieldCodeChallengeMethod] = struct{}{}
}

// CodeChallengeMethodCleared returns if the "code_challenge_method" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) CodeChallengeMethodCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldCodeChallengeMethod]
	return ok
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *OAuthAuthorizationMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
	delete(m.clearedFields, oauthauthorization.FieldCodeChallengeMethod)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *OAuthAuthorizationMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *OAuthAuthorizationMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *OAuthAuthorizationMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetScopeNames sets the "scope_names" field.
func (m *OAuthAuthorizationMutation) SetScopeNames(s []string) {
	m.scope_names = &s
	m.appendscope_names = nil
}

// ScopeNames returns the value of the "scope_names" field in the mutation.
func (m *OAuthAuthorizationMutation) ScopeNames() (r []string, exists bool) {
	v := m.scope_names
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeNames returns the old "scope_names" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldScopeNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeNames: %w", err)
	}
	return oldValue.ScopeNames, nil
}

// AppendScopeNames adds s to the "scope_names" field.
func (m *OAuthAuthorizationMutation) AppendScopeNames(s []string) {
	m.appendscope_names = append(m.appendscope_names, s...)
}

// AppendedScopeNames returns the list of values that were appended to the "scope_names" field in this mutation.
func (m *OAuthAuthorizationMutation) AppendedScopeNames() ([]string, bool) {
	if len(m.appendscope_names) == 0 {
		return nil, false
	}
	return m.appendscope_names, true
}

// ClearScopeNames clears the value of the "scope_names" field.
func (m *OAuthAuthorizationMutation) ClearScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	m.clearedFields[oauthauthorization.FieldScopeNames] = struct{}{}
}

// ScopeNamesCleared returns if the "scope_names" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) ScopeNamesCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldScopeNames]
	return ok
}

// ResetScopeNames resets all changes to the "scope_names" field.
func (m *OAuthAuthorizationMutation) ResetScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	delete(m.clearedFields, oauthauthorization.FieldScopeNames)
}

// SetUsed sets the "used" field.
func (m *OAuthAuthorizationMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *OAuthAuthorizationMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *OAuthAuthorizationMutation) ResetUsed() {
	m.used = nil
}

// SetUsedAt sets the "used_at" field.
func (m *OAuthAuthorizationMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *OAuthAuthorizationMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *OAuthAuthorizationMutation) ResetUsedAt() {
	m.used_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OAuthAuthorizationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OAuthAuthorizationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OAuthAuthorizationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetState sets the "state" field.
func (m *OAuthAuthorizationMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *OAuthAuthorizationMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *OAuthAuthorizationMutation) ClearState() {
	m.state = nil
	m.clearedFields[oauthauthorization.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) StateCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *OAuthAuthorizationMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, oauthauthorization.FieldState)
}

// SetNonce sets the "nonce" field.
func (m *OAuthAuthorizationMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *OAuthAuthorizationMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ClearNonce clears the value of the "nonce" field.
func (m *OAuthAuthorizationMutation) ClearNonce() {
	m.nonce = nil
	m.clearedFields[oauthauthorization.FieldNonce] = struct{}{}
}

// NonceCleared returns if the "nonce" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) NonceCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldNonce]
	return ok
}

// ResetNonce resets all changes to the "nonce" field.
func (m *OAuthAuthorizationMutation) ResetNonce() {
	m.nonce = nil
	delete(m.clearedFields, oauthauthorization.FieldNonce)
}

// SetUserAgent sets the "user_agent" field.
func (m *OAuthAuthorizationMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *OAuthAuthorizationMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *OAuthAuthorizationMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[oauthauthorization.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *OAuthAuthorizationMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, oauthauthorization.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *OAuthAuthorizationMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *OAuthAuthorizationMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *OAuthAuthorizationMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[oauthauthorization.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *OAuthAuthorizationMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, oauthauthorization.FieldIPAddress)
}

// ClearClient clears the "client" edge to the OAuthClient entity.
func (m *OAuthAuthorizationMutation) ClearClient() {
	m.clearedclient = true
	m.clearedFields[oauthauthorization.FieldClientID] = struct{}{}
}

// ClientCleared reports if the "client" edge to the OAuthClient entity was cleared.
func (m *OAuthAuthorizationMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *OAuthAuthorizationMutation) ClientIDs() (ids []xid.ID) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *OAuthAuthorizationMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OAuthAuthorizationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oauthauthorization.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OAuthAuthorizationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OAuthAuthorizationMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OAuthAuthorizationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddScopeIDs adds the "scopes" edge to the OAuthScope entity by ids.
func (m *OAuthAuthorizationMutation) AddScopeIDs(ids ...xid.ID) {
	if m.scopes == nil {
		m.scopes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the OAuthScope entity.
func (m *OAuthAuthorizationMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the OAuthScope entity was cleared.
func (m *OAuthAuthorizationMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the OAuthScope entity by IDs.
func (m *OAuthAuthorizationMutation) RemoveScopeIDs(ids ...xid.ID) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the OAuthScope entity.
func (m *OAuthAuthorizationMutation) RemovedScopesIDs() (ids []xid.ID) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *OAuthAuthorizationMutation) ScopesIDs() (ids []xid.ID) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *OAuthAuthorizationMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// Where appends a list predicates to the OAuthAuthorizationMutation builder.
func (m *OAuthAuthorizationMutation) Where(ps ...predicate.OAuthAuthorization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthAuthorizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthAuthorizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthAuthorization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthAuthorizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthAuthorizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthAuthorization).
func (m *OAuthAuthorizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthAuthorizationMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, oauthauthorization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthauthorization.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauthauthorization.FieldDeletedAt)
	}
	if m.client != nil {
		fields = append(fields, oauthauthorization.FieldClientID)
	}
	if m.user != nil {
		fields = append(fields, oauthauthorization.FieldUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, oauthauthorization.FieldOrganizationID)
	}
	if m.code != nil {
		fields = append(fields, oauthauthorization.FieldCode)
	}
	if m.code_challenge != nil {
		fields = append(fields, oauthauthorization.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, oauthauthorization.FieldCodeChallengeMethod)
	}
	if m.redirect_uri != nil {
		fields = append(fields, oauthauthorization.FieldRedirectURI)
	}
	if m.scope_names != nil {
		fields = append(fields, oauthauthorization.FieldScopeNames)
	}
	if m.used != nil {
		fields = append(fields, oauthauthorization.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, oauthauthorization.FieldUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, oauthauthorization.FieldExpiresAt)
	}
	if m.state != nil {
		fields = append(fields, oauthauthorization.FieldState)
	}
	if m.nonce != nil {
		fields = append(fields, oauthauthorization.FieldNonce)
	}
	if m.user_agent != nil {
		fields = append(fields, oauthauthorization.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, oauthauthorization.FieldIPAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthAuthorizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		return m.CreatedAt()
	case oauthauthorization.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthauthorization.FieldDeletedAt:
		return m.DeletedAt()
	case oauthauthorization.FieldClientID:
		return m.ClientID()
	case oauthauthorization.FieldUserID:
		return m.UserID()
	case oauthauthorization.FieldOrganizationID:
		return m.OrganizationID()
	case oauthauthorization.FieldCode:
		return m.Code()
	case oauthauthorization.FieldCodeChallenge:
		return m.CodeChallenge()
	case oauthauthorization.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case oauthauthorization.FieldRedirectURI:
		return m.RedirectURI()
	case oauthauthorization.FieldScopeNames:
		return m.ScopeNames()
	case oauthauthorization.FieldUsed:
		return m.Used()
	case oauthauthorization.FieldUsedAt:
		return m.UsedAt()
	case oauthauthorization.FieldExpiresAt:
		return m.ExpiresAt()
	case oauthauthorization.FieldState:
		return m.State()
	case oauthauthorization.FieldNonce:
		return m.Nonce()
	case oauthauthorization.FieldUserAgent:
		return m.UserAgent()
	case oauthauthorization.FieldIPAddress:
		return m.IPAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthAuthorizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthauthorization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthauthorization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauthauthorization.FieldClientID:
		return m.OldClientID(ctx)
	case oauthauthorization.FieldUserID:
		return m.OldUserID(ctx)
	case oauthauthorization.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case oauthauthorization.FieldCode:
		return m.OldCode(ctx)
	case oauthauthorization.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case oauthauthorization.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case oauthauthorization.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case oauthauthorization.FieldScopeNames:
		return m.OldScopeNames(ctx)
	case oauthauthorization.FieldUsed:
		return m.OldUsed(ctx)
	case oauthauthorization.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case oauthauthorization.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case oauthauthorization.FieldState:
		return m.OldState(ctx)
	case oauthauthorization.FieldNonce:
		return m.OldNonce(ctx)
	case oauthauthorization.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case oauthauthorization.FieldIPAddress:
		return m.OldIPAddress(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthAuthorization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthAuthorizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthauthorization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthauthorization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauthauthorization.FieldClientID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthauthorization.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthauthorization.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case oauthauthorization.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case oauthauthorization.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case oauthauthorization.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case oauthauthorization.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case oauthauthorization.FieldScopeNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeNames(v)
		return nil
	case oauthauthorization.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case oauthauthorization.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case oauthauthorization.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case oauthauthorization.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case oauthauthorization.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case oauthauthorization.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case oauthauthorization.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthAuthorizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthAuthorizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthAuthorizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthAuthorization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthAuthorizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthauthorization.FieldDeletedAt) {
		fields = append(fields, oauthauthorization.FieldDeletedAt)
	}
	if m.FieldCleared(oauthauthorization.FieldOrganizationID) {
		fields = append(fields, oauthauthorization.FieldOrganizationID)
	}
	if m.FieldCleared(oauthauthorization.FieldCode) {
		fields = append(fields, oauthauthorization.FieldCode)
	}
	if m.FieldCleared(oauthauthorization.FieldCodeChallenge) {
		fields = append(fields, oauthauthorization.FieldCodeChallenge)
	}
	if m.FieldCleared(oauthauthorization.FieldCodeChallengeMethod) {
		fields = append(fields, oauthauthorization.FieldCodeChallengeMethod)
	}
	if m.FieldCleared(oauthauthorization.FieldScopeNames) {
		fields = append(fields, oauthauthorization.FieldScopeNames)
	}
	if m.FieldCleared(oauthauthorization.FieldState) {
		fields = append(fields, oauthauthorization.FieldState)
	}
	if m.FieldCleared(oauthauthorization.FieldNonce) {
		fields = append(fields, oauthauthorization.FieldNonce)
	}
	if m.FieldCleared(oauthauthorization.FieldUserAgent) {
		fields = append(fields, oauthauthorization.FieldUserAgent)
	}
	if m.FieldCleared(oauthauthorization.FieldIPAddress) {
		fields = append(fields, oauthauthorization.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthAuthorizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthAuthorizationMutation) ClearField(name string) error {
	switch name {
	case oauthauthorization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case oauthauthorization.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case oauthauthorization.FieldCode:
		m.ClearCode()
		return nil
	case oauthauthorization.FieldCodeChallenge:
		m.ClearCodeChallenge()
		return nil
	case oauthauthorization.FieldCodeChallengeMethod:
		m.ClearCodeChallengeMethod()
		return nil
	case oauthauthorization.FieldScopeNames:
		m.ClearScopeNames()
		return nil
	case oauthauthorization.FieldState:
		m.ClearState()
		return nil
	case oauthauthorization.FieldNonce:
		m.ClearNonce()
		return nil
	case oauthauthorization.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case oauthauthorization.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthAuthorizationMutation) ResetField(name string) error {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthauthorization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthauthorization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauthauthorization.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthauthorization.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthauthorization.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case oauthauthorization.FieldCode:
		m.ResetCode()
		return nil
	case oauthauthorization.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case oauthauthorization.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case oauthauthorization.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case oauthauthorization.FieldScopeNames:
		m.ResetScopeNames()
		return nil
	case oauthauthorization.FieldUsed:
		m.ResetUsed()
		return nil
	case oauthauthorization.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case oauthauthorization.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case oauthauthorization.FieldState:
		m.ResetState()
		return nil
	case oauthauthorization.FieldNonce:
		m.ResetNonce()
		return nil
	case oauthauthorization.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case oauthauthorization.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthAuthorizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.client != nil {
		edges = append(edges, oauthauthorization.EdgeClient)
	}
	if m.user != nil {
		edges = append(edges, oauthauthorization.EdgeUser)
	}
	if m.scopes != nil {
		edges = append(edges, oauthauthorization.EdgeScopes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthAuthorizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthauthorization.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case oauthauthorization.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oauthauthorization.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthAuthorizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedscopes != nil {
		edges = append(edges, oauthauthorization.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthAuthorizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthauthorization.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthAuthorizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclient {
		edges = append(edges, oauthauthorization.EdgeClient)
	}
	if m.cleareduser {
		edges = append(edges, oauthauthorization.EdgeUser)
	}
	if m.clearedscopes {
		edges = append(edges, oauthauthorization.EdgeScopes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthAuthorizationMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthauthorization.EdgeClient:
		return m.clearedclient
	case oauthauthorization.EdgeUser:
		return m.cleareduser
	case oauthauthorization.EdgeScopes:
		return m.clearedscopes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthAuthorizationMutation) ClearEdge(name string) error {
	switch name {
	case oauthauthorization.EdgeClient:
		m.ClearClient()
		return nil
	case oauthauthorization.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthAuthorizationMutation) ResetEdge(name string) error {
	switch name {
	case oauthauthorization.EdgeClient:
		m.ResetClient()
		return nil
	case oauthauthorization.EdgeUser:
		m.ResetUser()
		return nil
	case oauthauthorization.EdgeScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization edge %s", name)
}

// OAuthClientMutation represents an operation that mutates the OAuthClient nodes in the graph.
type OAuthClientMutation struct {
	config
	op                              Op
	typ                             string
	id                              *xid.ID
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	client_id                       *string
	client_secret                   *string
	client_name                     *string
	client_description              *string
	client_uri                      *string
	logo_uri                        *string
	redirect_uris                   *[]string
	appendredirect_uris             []string
	post_logout_redirect_uris       *[]string
	appendpost_logout_redirect_uris []string
	public                          *bool
	active                          *bool
	allowed_cors_origins            *[]string
	appendallowed_cors_origins      []string
	allowed_grant_types             *[]string
	appendallowed_grant_types       []string
	token_expiry_seconds            *int
	addtoken_expiry_seconds         *int
	refresh_token_expiry_seconds    *int
	addrefresh_token_expiry_seconds *int
	auth_code_expiry_seconds        *int
	addauth_code_expiry_seconds     *int
	requires_pkce                   *bool
	requires_consent                *bool
	clearedFields                   map[string]struct{}
	organization                    *xid.ID
	clearedorganization             bool
	tokens                          map[xid.ID]struct{}
	removedtokens                   map[xid.ID]struct{}
	clearedtokens                   bool
	authorizations                  map[xid.ID]struct{}
	removedauthorizations           map[xid.ID]struct{}
	clearedauthorizations           bool
	scopes                          map[xid.ID]struct{}
	removedscopes                   map[xid.ID]struct{}
	clearedscopes                   bool
	done                            bool
	oldValue                        func(context.Context) (*OAuthClient, error)
	predicates                      []predicate.OAuthClient
}

var _ ent.Mutation = (*OAuthClientMutation)(nil)

// oauthclientOption allows management of the mutation configuration using functional options.
type oauthclientOption func(*OAuthClientMutation)

// newOAuthClientMutation creates new mutation for the OAuthClient entity.
func newOAuthClientMutation(c config, op Op, opts ...oauthclientOption) *OAuthClientMutation {
	m := &OAuthClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthClientID sets the ID field of the mutation.
func withOAuthClientID(id xid.ID) oauthclientOption {
	return func(m *OAuthClientMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthClient
		)
		m.oldValue = func(ctx context.Context) (*OAuthClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthClient sets the old OAuthClient of the mutation.
func withOAuthClient(node *OAuthClient) oauthclientOption {
	return func(m *OAuthClientMutation) {
		m.oldValue = func(context.Context) (*OAuthClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthClient entities.
func (m *OAuthClientMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthClientMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthClientMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OAuthClientMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OAuthClientMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OAuthClientMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[oauthclient.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OAuthClientMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OAuthClientMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, oauthclient.FieldDeletedAt)
}

// SetClientID sets the "client_id" field.
func (m *OAuthClientMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthClientMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthClientMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OAuthClientMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OAuthClientMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OAuthClientMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetClientName sets the "client_name" field.
func (m *OAuthClientMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *OAuthClientMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *OAuthClientMutation) ResetClientName() {
	m.client_name = nil
}

// SetClientDescription sets the "client_description" field.
func (m *OAuthClientMutation) SetClientDescription(s string) {
	m.client_description = &s
}

// ClientDescription returns the value of the "client_description" field in the mutation.
func (m *OAuthClientMutation) ClientDescription() (r string, exists bool) {
	v := m.client_description
	if v == nil {
		return
	}
	return *v, true
}

// OldClientDescription returns the old "client_description" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientDescription: %w", err)
	}
	return oldValue.ClientDescription, nil
}

// ClearClientDescription clears the value of the "client_description" field.
func (m *OAuthClientMutation) ClearClientDescription() {
	m.client_description = nil
	m.clearedFields[oauthclient.FieldClientDescription] = struct{}{}
}

// ClientDescriptionCleared returns if the "client_description" field was cleared in this mutation.
func (m *OAuthClientMutation) ClientDescriptionCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldClientDescription]
	return ok
}

// ResetClientDescription resets all changes to the "client_description" field.
func (m *OAuthClientMutation) ResetClientDescription() {
	m.client_description = nil
	delete(m.clearedFields, oauthclient.FieldClientDescription)
}

// SetClientURI sets the "client_uri" field.
func (m *OAuthClientMutation) SetClientURI(s string) {
	m.client_uri = &s
}

// ClientURI returns the value of the "client_uri" field in the mutation.
func (m *OAuthClientMutation) ClientURI() (r string, exists bool) {
	v := m.client_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldClientURI returns the old "client_uri" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientURI: %w", err)
	}
	return oldValue.ClientURI, nil
}

// ClearClientURI clears the value of the "client_uri" field.
func (m *OAuthClientMutation) ClearClientURI() {
	m.client_uri = nil
	m.clearedFields[oauthclient.FieldClientURI] = struct{}{}
}

// ClientURICleared returns if the "client_uri" field was cleared in this mutation.
func (m *OAuthClientMutation) ClientURICleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldClientURI]
	return ok
}

// ResetClientURI resets all changes to the "client_uri" field.
func (m *OAuthClientMutation) ResetClientURI() {
	m.client_uri = nil
	delete(m.clearedFields, oauthclient.FieldClientURI)
}

// SetLogoURI sets the "logo_uri" field.
func (m *OAuthClientMutation) SetLogoURI(s string) {
	m.logo_uri = &s
}

// LogoURI returns the value of the "logo_uri" field in the mutation.
func (m *OAuthClientMutation) LogoURI() (r string, exists bool) {
	v := m.logo_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURI returns the old "logo_uri" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldLogoURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURI: %w", err)
	}
	return oldValue.LogoURI, nil
}

// ClearLogoURI clears the value of the "logo_uri" field.
func (m *OAuthClientMutation) ClearLogoURI() {
	m.logo_uri = nil
	m.clearedFields[oauthclient.FieldLogoURI] = struct{}{}
}

// LogoURICleared returns if the "logo_uri" field was cleared in this mutation.
func (m *OAuthClientMutation) LogoURICleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldLogoURI]
	return ok
}

// ResetLogoURI resets all changes to the "logo_uri" field.
func (m *OAuthClientMutation) ResetLogoURI() {
	m.logo_uri = nil
	delete(m.clearedFields, oauthclient.FieldLogoURI)
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *OAuthClientMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *OAuthClientMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *OAuthClientMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *OAuthClientMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *OAuthClientMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
}

// SetPostLogoutRedirectUris sets the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) SetPostLogoutRedirectUris(s []string) {
	m.post_logout_redirect_uris = &s
	m.appendpost_logout_redirect_uris = nil
}

// PostLogoutRedirectUris returns the value of the "post_logout_redirect_uris" field in the mutation.
func (m *OAuthClientMutation) PostLogoutRedirectUris() (r []string, exists bool) {
	v := m.post_logout_redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldPostLogoutRedirectUris returns the old "post_logout_redirect_uris" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldPostLogoutRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostLogoutRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostLogoutRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostLogoutRedirectUris: %w", err)
	}
	return oldValue.PostLogoutRedirectUris, nil
}

// AppendPostLogoutRedirectUris adds s to the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) AppendPostLogoutRedirectUris(s []string) {
	m.appendpost_logout_redirect_uris = append(m.appendpost_logout_redirect_uris, s...)
}

// AppendedPostLogoutRedirectUris returns the list of values that were appended to the "post_logout_redirect_uris" field in this mutation.
func (m *OAuthClientMutation) AppendedPostLogoutRedirectUris() ([]string, bool) {
	if len(m.appendpost_logout_redirect_uris) == 0 {
		return nil, false
	}
	return m.appendpost_logout_redirect_uris, true
}

// ClearPostLogoutRedirectUris clears the value of the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) ClearPostLogoutRedirectUris() {
	m.post_logout_redirect_uris = nil
	m.appendpost_logout_redirect_uris = nil
	m.clearedFields[oauthclient.FieldPostLogoutRedirectUris] = struct{}{}
}

// PostLogoutRedirectUrisCleared returns if the "post_logout_redirect_uris" field was cleared in this mutation.
func (m *OAuthClientMutation) PostLogoutRedirectUrisCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldPostLogoutRedirectUris]
	return ok
}

// ResetPostLogoutRedirectUris resets all changes to the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) ResetPostLogoutRedirectUris() {
	m.post_logout_redirect_uris = nil
	m.appendpost_logout_redirect_uris = nil
	delete(m.clearedFields, oauthclient.FieldPostLogoutRedirectUris)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OAuthClientMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OAuthClientMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OAuthClientMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[oauthclient.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OAuthClientMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OAuthClientMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, oauthclient.FieldOrganizationID)
}

// SetPublic sets the "public" field.
func (m *OAuthClientMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *OAuthClientMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *OAuthClientMutation) ResetPublic() {
	m.public = nil
}

// SetActive sets the "active" field.
func (m *OAuthClientMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OAuthClientMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OAuthClientMutation) ResetActive() {
	m.active = nil
}

// SetAllowedCorsOrigins sets the "allowed_cors_origins" field.
func (m *OAuthClientMutation) SetAllowedCorsOrigins(s []string) {
	m.allowed_cors_origins = &s
	m.appendallowed_cors_origins = nil
}

// AllowedCorsOrigins returns the value of the "allowed_cors_origins" field in the mutation.
func (m *OAuthClientMutation) AllowedCorsOrigins() (r []string, exists bool) {
	v := m.allowed_cors_origins
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCorsOrigins returns the old "allowed_cors_origins" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAllowedCorsOrigins(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCorsOrigins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCorsOrigins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCorsOrigins: %w", err)
	}
	return oldValue.AllowedCorsOrigins, nil
}

// AppendAllowedCorsOrigins adds s to the "allowed_cors_origins" field.
func (m *OAuthClientMutation) AppendAllowedCorsOrigins(s []string) {
	m.appendallowed_cors_origins = append(m.appendallowed_cors_origins, s...)
}

// AppendedAllowedCorsOrigins returns the list of values that were appended to the "allowed_cors_origins" field in this mutation.
func (m *OAuthClientMutation) AppendedAllowedCorsOrigins() ([]string, bool) {
	if len(m.appendallowed_cors_origins) == 0 {
		return nil, false
	}
	return m.appendallowed_cors_origins, true
}

// ClearAllowedCorsOrigins clears the value of the "allowed_cors_origins" field.
func (m *OAuthClientMutation) ClearAllowedCorsOrigins() {
	m.allowed_cors_origins = nil
	m.appendallowed_cors_origins = nil
	m.clearedFields[oauthclient.FieldAllowedCorsOrigins] = struct{}{}
}

// AllowedCorsOriginsCleared returns if the "allowed_cors_origins" field was cleared in this mutation.
func (m *OAuthClientMutation) AllowedCorsOriginsCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldAllowedCorsOrigins]
	return ok
}

// ResetAllowedCorsOrigins resets all changes to the "allowed_cors_origins" field.
func (m *OAuthClientMutation) ResetAllowedCorsOrigins() {
	m.allowed_cors_origins = nil
	m.appendallowed_cors_origins = nil
	delete(m.clearedFields, oauthclient.FieldAllowedCorsOrigins)
}

// SetAllowedGrantTypes sets the "allowed_grant_types" field.
func (m *OAuthClientMutation) SetAllowedGrantTypes(s []string) {
	m.allowed_grant_types = &s
	m.appendallowed_grant_types = nil
}

// AllowedGrantTypes returns the value of the "allowed_grant_types" field in the mutation.
func (m *OAuthClientMutation) AllowedGrantTypes() (r []string, exists bool) {
	v := m.allowed_grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedGrantTypes returns the old "allowed_grant_types" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAllowedGrantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedGrantTypes: %w", err)
	}
	return oldValue.AllowedGrantTypes, nil
}

// AppendAllowedGrantTypes adds s to the "allowed_grant_types" field.
func (m *OAuthClientMutation) AppendAllowedGrantTypes(s []string) {
	m.appendallowed_grant_types = append(m.appendallowed_grant_types, s...)
}

// AppendedAllowedGrantTypes returns the list of values that were appended to the "allowed_grant_types" field in this mutation.
func (m *OAuthClientMutation) AppendedAllowedGrantTypes() ([]string, bool) {
	if len(m.appendallowed_grant_types) == 0 {
		return nil, false
	}
	return m.appendallowed_grant_types, true
}

// ResetAllowedGrantTypes resets all changes to the "allowed_grant_types" field.
func (m *OAuthClientMutation) ResetAllowedGrantTypes() {
	m.allowed_grant_types = nil
	m.appendallowed_grant_types = nil
}

// SetTokenExpirySeconds sets the "token_expiry_seconds" field.
func (m *OAuthClientMutation) SetTokenExpirySeconds(i int) {
	m.token_expiry_seconds = &i
	m.addtoken_expiry_seconds = nil
}

// TokenExpirySeconds returns the value of the "token_expiry_seconds" field in the mutation.
func (m *OAuthClientMutation) TokenExpirySeconds() (r int, exists bool) {
	v := m.token_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpirySeconds returns the old "token_expiry_seconds" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldTokenExpirySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpirySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpirySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpirySeconds: %w", err)
	}
	return oldValue.TokenExpirySeconds, nil
}

// AddTokenExpirySeconds adds i to the "token_expiry_seconds" field.
func (m *OAuthClientMutation) AddTokenExpirySeconds(i int) {
	if m.addtoken_expiry_seconds != nil {
		*m.addtoken_expiry_seconds += i
	} else {
		m.addtoken_expiry_seconds = &i
	}
}

// AddedTokenExpirySeconds returns the value that was added to the "token_expiry_seconds" field in this mutation.
func (m *OAuthClientMutation) AddedTokenExpirySeconds() (r int, exists bool) {
	v := m.addtoken_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenExpirySeconds resets all changes to the "token_expiry_seconds" field.
func (m *OAuthClientMutation) ResetTokenExpirySeconds() {
	m.token_expiry_seconds = nil
	m.addtoken_expiry_seconds = nil
}

// SetRefreshTokenExpirySeconds sets the "refresh_token_expiry_seconds" field.
func (m *OAuthClientMutation) SetRefreshTokenExpirySeconds(i int) {
	m.refresh_token_expiry_seconds = &i
	m.addrefresh_token_expiry_seconds = nil
}

// RefreshTokenExpirySeconds returns the value of the "refresh_token_expiry_seconds" field in the mutation.
func (m *OAuthClientMutation) RefreshTokenExpirySeconds() (r int, exists bool) {
	v := m.refresh_token_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenExpirySeconds returns the old "refresh_token_expiry_seconds" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRefreshTokenExpirySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenExpirySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenExpirySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenExpirySeconds: %w", err)
	}
	return oldValue.RefreshTokenExpirySeconds, nil
}

// AddRefreshTokenExpirySeconds adds i to the "refresh_token_expiry_seconds" field.
func (m *OAuthClientMutation) AddRefreshTokenExpirySeconds(i int) {
	if m.addrefresh_token_expiry_seconds != nil {
		*m.addrefresh_token_expiry_seconds += i
	} else {
		m.addrefresh_token_expiry_seconds = &i
	}
}

// AddedRefreshTokenExpirySeconds returns the value that was added to the "refresh_token_expiry_seconds" field in this mutation.
func (m *OAuthClientMutation) AddedRefreshTokenExpirySeconds() (r int, exists bool) {
	v := m.addrefresh_token_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefreshTokenExpirySeconds resets all changes to the "refresh_token_expiry_seconds" field.
func (m *OAuthClientMutation) ResetRefreshTokenExpirySeconds() {
	m.refresh_token_expiry_seconds = nil
	m.addrefresh_token_expiry_seconds = nil
}

// SetAuthCodeExpirySeconds sets the "auth_code_expiry_seconds" field.
func (m *OAuthClientMutation) SetAuthCodeExpirySeconds(i int) {
	m.auth_code_expiry_seconds = &i
	m.addauth_code_expiry_seconds = nil
}

// AuthCodeExpirySeconds returns the value of the "auth_code_expiry_seconds" field in the mutation.
func (m *OAuthClientMutation) AuthCodeExpirySeconds() (r int, exists bool) {
	v := m.auth_code_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthCodeExpirySeconds returns the old "auth_code_expiry_seconds" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAuthCodeExpirySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthCodeExpirySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthCodeExpirySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthCodeExpirySeconds: %w", err)
	}
	return oldValue.AuthCodeExpirySeconds, nil
}

// AddAuthCodeExpirySeconds adds i to the "auth_code_expiry_seconds" field.
func (m *OAuthClientMutation) AddAuthCodeExpirySeconds(i int) {
	if m.addauth_code_expiry_seconds != nil {
		*m.addauth_code_expiry_seconds += i
	} else {
		m.addauth_code_expiry_seconds = &i
	}
}

// AddedAuthCodeExpirySeconds returns the value that was added to the "auth_code_expiry_seconds" field in this mutation.
func (m *OAuthClientMutation) AddedAuthCodeExpirySeconds() (r int, exists bool) {
	v := m.addauth_code_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthCodeExpirySeconds resets all changes to the "auth_code_expiry_seconds" field.
func (m *OAuthClientMutation) ResetAuthCodeExpirySeconds() {
	m.auth_code_expiry_seconds = nil
	m.addauth_code_expiry_seconds = nil
}

// SetRequiresPkce sets the "requires_pkce" field.
func (m *OAuthClientMutation) SetRequiresPkce(b bool) {
	m.requires_pkce = &b
}

// RequiresPkce returns the value of the "requires_pkce" field in the mutation.
func (m *OAuthClientMutation) RequiresPkce() (r bool, exists bool) {
	v := m.requires_pkce
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresPkce returns the old "requires_pkce" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRequiresPkce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresPkce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresPkce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresPkce: %w", err)
	}
	return oldValue.RequiresPkce, nil
}

// ResetRequiresPkce resets all changes to the "requires_pkce" field.
func (m *OAuthClientMutation) ResetRequiresPkce() {
	m.requires_pkce = nil
}

// SetRequiresConsent sets the "requires_consent" field.
func (m *OAuthClientMutation) SetRequiresConsent(b bool) {
	m.requires_consent = &b
}

// RequiresConsent returns the value of the "requires_consent" field in the mutation.
func (m *OAuthClientMutation) RequiresConsent() (r bool, exists bool) {
	v := m.requires_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresConsent returns the old "requires_consent" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRequiresConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresConsent: %w", err)
	}
	return oldValue.RequiresConsent, nil
}

// ResetRequiresConsent resets all changes to the "requires_consent" field.
func (m *OAuthClientMutation) ResetRequiresConsent() {
	m.requires_consent = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OAuthClientMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[oauthclient.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OAuthClientMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OAuthClientMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OAuthClientMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddTokenIDs adds the "tokens" edge to the OAuthToken entity by ids.
func (m *OAuthClientMutation) AddTokenIDs(ids ...xid.ID) {
	if m.tokens == nil {
		m.tokens = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the OAuthToken entity.
func (m *OAuthClientMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the OAuthToken entity was cleared.
func (m *OAuthClientMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the OAuthToken entity by IDs.
func (m *OAuthClientMutation) RemoveTokenIDs(ids ...xid.ID) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the OAuthToken entity.
func (m *OAuthClientMutation) RemovedTokensIDs() (ids []xid.ID) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *OAuthClientMutation) TokensIDs() (ids []xid.ID) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *OAuthClientMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddAuthorizationIDs adds the "authorizations" edge to the OAuthAuthorization entity by ids.
func (m *OAuthClientMutation) AddAuthorizationIDs(ids ...xid.ID) {
	if m.authorizations == nil {
		m.authorizations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.authorizations[ids[i]] = struct{}{}
	}
}

// ClearAuthorizations clears the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthClientMutation) ClearAuthorizations() {
	m.clearedauthorizations = true
}

// AuthorizationsCleared reports if the "authorizations" edge to the OAuthAuthorization entity was cleared.
func (m *OAuthClientMutation) AuthorizationsCleared() bool {
	return m.clearedauthorizations
}

// RemoveAuthorizationIDs removes the "authorizations" edge to the OAuthAuthorization entity by IDs.
func (m *OAuthClientMutation) RemoveAuthorizationIDs(ids ...xid.ID) {
	if m.removedauthorizations == nil {
		m.removedauthorizations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.authorizations, ids[i])
		m.removedauthorizations[ids[i]] = struct{}{}
	}
}

// RemovedAuthorizations returns the removed IDs of the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthClientMutation) RemovedAuthorizationsIDs() (ids []xid.ID) {
	for id := range m.removedauthorizations {
		ids = append(ids, id)
	}
	return
}

// AuthorizationsIDs returns the "authorizations" edge IDs in the mutation.
func (m *OAuthClientMutation) AuthorizationsIDs() (ids []xid.ID) {
	for id := range m.authorizations {
		ids = append(ids, id)
	}
	return
}

// ResetAuthorizations resets all changes to the "authorizations" edge.
func (m *OAuthClientMutation) ResetAuthorizations() {
	m.authorizations = nil
	m.clearedauthorizations = false
	m.removedauthorizations = nil
}

// AddScopeIDs adds the "scopes" edge to the OAuthScope entity by ids.
func (m *OAuthClientMutation) AddScopeIDs(ids ...xid.ID) {
	if m.scopes == nil {
		m.scopes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the OAuthScope entity.
func (m *OAuthClientMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the OAuthScope entity was cleared.
func (m *OAuthClientMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the OAuthScope entity by IDs.
func (m *OAuthClientMutation) RemoveScopeIDs(ids ...xid.ID) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the OAuthScope entity.
func (m *OAuthClientMutation) RemovedScopesIDs() (ids []xid.ID) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *OAuthClientMutation) ScopesIDs() (ids []xid.ID) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *OAuthClientMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// Where appends a list predicates to the OAuthClientMutation builder.
func (m *OAuthClientMutation) Where(ps ...predicate.OAuthClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthClient).
func (m *OAuthClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthClientMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, oauthclient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthclient.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauthclient.FieldDeletedAt)
	}
	if m.client_id != nil {
		fields = append(fields, oauthclient.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthclient.FieldClientSecret)
	}
	if m.client_name != nil {
		fields = append(fields, oauthclient.FieldClientName)
	}
	if m.client_description != nil {
		fields = append(fields, oauthclient.FieldClientDescription)
	}
	if m.client_uri != nil {
		fields = append(fields, oauthclient.FieldClientURI)
	}
	if m.logo_uri != nil {
		fields = append(fields, oauthclient.FieldLogoURI)
	}
	if m.redirect_uris != nil {
		fields = append(fields, oauthclient.FieldRedirectUris)
	}
	if m.post_logout_redirect_uris != nil {
		fields = append(fields, oauthclient.FieldPostLogoutRedirectUris)
	}
	if m.organization != nil {
		fields = append(fields, oauthclient.FieldOrganizationID)
	}
	if m.public != nil {
		fields = append(fields, oauthclient.FieldPublic)
	}
	if m.active != nil {
		fields = append(fields, oauthclient.FieldActive)
	}
	if m.allowed_cors_origins != nil {
		fields = append(fields, oauthclient.FieldAllowedCorsOrigins)
	}
	if m.allowed_grant_types != nil {
		fields = append(fields, oauthclient.FieldAllowedGrantTypes)
	}
	if m.token_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldTokenExpirySeconds)
	}
	if m.refresh_token_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldRefreshTokenExpirySeconds)
	}
	if m.auth_code_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldAuthCodeExpirySeconds)
	}
	if m.requires_pkce != nil {
		fields = append(fields, oauthclient.FieldRequiresPkce)
	}
	if m.requires_consent != nil {
		fields = append(fields, oauthclient.FieldRequiresConsent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldCreatedAt:
		return m.CreatedAt()
	case oauthclient.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthclient.FieldDeletedAt:
		return m.DeletedAt()
	case oauthclient.FieldClientID:
		return m.ClientID()
	case oauthclient.FieldClientSecret:
		return m.ClientSecret()
	case oauthclient.FieldClientName:
		return m.ClientName()
	case oauthclient.FieldClientDescription:
		return m.ClientDescription()
	case oauthclient.FieldClientURI:
		return m.ClientURI()
	case oauthclient.FieldLogoURI:
		return m.LogoURI()
	case oauthclient.FieldRedirectUris:
		return m.RedirectUris()
	case oauthclient.FieldPostLogoutRedirectUris:
		return m.PostLogoutRedirectUris()
	case oauthclient.FieldOrganizationID:
		return m.OrganizationID()
	case oauthclient.FieldPublic:
		return m.Public()
	case oauthclient.FieldActive:
		return m.Active()
	case oauthclient.FieldAllowedCorsOrigins:
		return m.AllowedCorsOrigins()
	case oauthclient.FieldAllowedGrantTypes:
		return m.AllowedGrantTypes()
	case oauthclient.FieldTokenExpirySeconds:
		return m.TokenExpirySeconds()
	case oauthclient.FieldRefreshTokenExpirySeconds:
		return m.RefreshTokenExpirySeconds()
	case oauthclient.FieldAuthCodeExpirySeconds:
		return m.AuthCodeExpirySeconds()
	case oauthclient.FieldRequiresPkce:
		return m.RequiresPkce()
	case oauthclient.FieldRequiresConsent:
		return m.RequiresConsent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthclient.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauthclient.FieldClientID:
		return m.OldClientID(ctx)
	case oauthclient.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthclient.FieldClientName:
		return m.OldClientName(ctx)
	case oauthclient.FieldClientDescription:
		return m.OldClientDescription(ctx)
	case oauthclient.FieldClientURI:
		return m.OldClientURI(ctx)
	case oauthclient.FieldLogoURI:
		return m.OldLogoURI(ctx)
	case oauthclient.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case oauthclient.FieldPostLogoutRedirectUris:
		return m.OldPostLogoutRedirectUris(ctx)
	case oauthclient.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case oauthclient.FieldPublic:
		return m.OldPublic(ctx)
	case oauthclient.FieldActive:
		return m.OldActive(ctx)
	case oauthclient.FieldAllowedCorsOrigins:
		return m.OldAllowedCorsOrigins(ctx)
	case oauthclient.FieldAllowedGrantTypes:
		return m.OldAllowedGrantTypes(ctx)
	case oauthclient.FieldTokenExpirySeconds:
		return m.OldTokenExpirySeconds(ctx)
	case oauthclient.FieldRefreshTokenExpirySeconds:
		return m.OldRefreshTokenExpirySeconds(ctx)
	case oauthclient.FieldAuthCodeExpirySeconds:
		return m.OldAuthCodeExpirySeconds(ctx)
	case oauthclient.FieldRequiresPkce:
		return m.OldRequiresPkce(ctx)
	case oauthclient.FieldRequiresConsent:
		return m.OldRequiresConsent(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthclient.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauthclient.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthclient.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthclient.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case oauthclient.FieldClientDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientDescription(v)
		return nil
	case oauthclient.FieldClientURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientURI(v)
		return nil
	case oauthclient.FieldLogoURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURI(v)
		return nil
	case oauthclient.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case oauthclient.FieldPostLogoutRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostLogoutRedirectUris(v)
		return nil
	case oauthclient.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case oauthclient.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case oauthclient.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case oauthclient.FieldAllowedCorsOrigins:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCorsOrigins(v)
		return nil
	case oauthclient.FieldAllowedGrantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedGrantTypes(v)
		return nil
	case oauthclient.FieldTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldRefreshTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldAuthCodeExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthCodeExpirySeconds(v)
		return nil
	case oauthclient.FieldRequiresPkce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresPkce(v)
		return nil
	case oauthclient.FieldRequiresConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresConsent(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthClientMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldTokenExpirySeconds)
	}
	if m.addrefresh_token_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldRefreshTokenExpirySeconds)
	}
	if m.addauth_code_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldAuthCodeExpirySeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldTokenExpirySeconds:
		return m.AddedTokenExpirySeconds()
	case oauthclient.FieldRefreshTokenExpirySeconds:
		return m.AddedRefreshTokenExpirySeconds()
	case oauthclient.FieldAuthCodeExpirySeconds:
		return m.AddedAuthCodeExpirySeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldRefreshTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldAuthCodeExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthCodeExpirySeconds(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthclient.FieldDeletedAt) {
		fields = append(fields, oauthclient.FieldDeletedAt)
	}
	if m.FieldCleared(oauthclient.FieldClientDescription) {
		fields = append(fields, oauthclient.FieldClientDescription)
	}
	if m.FieldCleared(oauthclient.FieldClientURI) {
		fields = append(fields, oauthclient.FieldClientURI)
	}
	if m.FieldCleared(oauthclient.FieldLogoURI) {
		fields = append(fields, oauthclient.FieldLogoURI)
	}
	if m.FieldCleared(oauthclient.FieldPostLogoutRedirectUris) {
		fields = append(fields, oauthclient.FieldPostLogoutRedirectUris)
	}
	if m.FieldCleared(oauthclient.FieldOrganizationID) {
		fields = append(fields, oauthclient.FieldOrganizationID)
	}
	if m.FieldCleared(oauthclient.FieldAllowedCorsOrigins) {
		fields = append(fields, oauthclient.FieldAllowedCorsOrigins)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthClientMutation) ClearField(name string) error {
	switch name {
	case oauthclient.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case oauthclient.FieldClientDescription:
		m.ClearClientDescription()
		return nil
	case oauthclient.FieldClientURI:
		m.ClearClientURI()
		return nil
	case oauthclient.FieldLogoURI:
		m.ClearLogoURI()
		return nil
	case oauthclient.FieldPostLogoutRedirectUris:
		m.ClearPostLogoutRedirectUris()
		return nil
	case oauthclient.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case oauthclient.FieldAllowedCorsOrigins:
		m.ClearAllowedCorsOrigins()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthClientMutation) ResetField(name string) error {
	switch name {
	case oauthclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthclient.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauthclient.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthclient.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthclient.FieldClientName:
		m.ResetClientName()
		return nil
	case oauthclient.FieldClientDescription:
		m.ResetClientDescription()
		return nil
	case oauthclient.FieldClientURI:
		m.ResetClientURI()
		return nil
	case oauthclient.FieldLogoURI:
		m.ResetLogoURI()
		return nil
	case oauthclient.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case oauthclient.FieldPostLogoutRedirectUris:
		m.ResetPostLogoutRedirectUris()
		return nil
	case oauthclient.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case oauthclient.FieldPublic:
		m.ResetPublic()
		return nil
	case oauthclient.FieldActive:
		m.ResetActive()
		return nil
	case oauthclient.FieldAllowedCorsOrigins:
		m.ResetAllowedCorsOrigins()
		return nil
	case oauthclient.FieldAllowedGrantTypes:
		m.ResetAllowedGrantTypes()
		return nil
	case oauthclient.FieldTokenExpirySeconds:
		m.ResetTokenExpirySeconds()
		return nil
	case oauthclient.FieldRefreshTokenExpirySeconds:
		m.ResetRefreshTokenExpirySeconds()
		return nil
	case oauthclient.FieldAuthCodeExpirySeconds:
		m.ResetAuthCodeExpirySeconds()
		return nil
	case oauthclient.FieldRequiresPkce:
		m.ResetRequiresPkce()
		return nil
	case oauthclient.FieldRequiresConsent:
		m.ResetRequiresConsent()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, oauthclient.EdgeOrganization)
	}
	if m.tokens != nil {
		edges = append(edges, oauthclient.EdgeTokens)
	}
	if m.authorizations != nil {
		edges = append(edges, oauthclient.EdgeAuthorizations)
	}
	if m.scopes != nil {
		edges = append(edges, oauthclient.EdgeScopes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthclient.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case oauthclient.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.authorizations))
		for id := range m.authorizations {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtokens != nil {
		edges = append(edges, oauthclient.EdgeTokens)
	}
	if m.removedauthorizations != nil {
		edges = append(edges, oauthclient.EdgeAuthorizations)
	}
	if m.removedscopes != nil {
		edges = append(edges, oauthclient.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthClientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthclient.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.removedauthorizations))
		for id := range m.removedauthorizations {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, oauthclient.EdgeOrganization)
	}
	if m.clearedtokens {
		edges = append(edges, oauthclient.EdgeTokens)
	}
	if m.clearedauthorizations {
		edges = append(edges, oauthclient.EdgeAuthorizations)
	}
	if m.clearedscopes {
		edges = append(edges, oauthclient.EdgeScopes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthClientMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthclient.EdgeOrganization:
		return m.clearedorganization
	case oauthclient.EdgeTokens:
		return m.clearedtokens
	case oauthclient.EdgeAuthorizations:
		return m.clearedauthorizations
	case oauthclient.EdgeScopes:
		return m.clearedscopes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthClientMutation) ClearEdge(name string) error {
	switch name {
	case oauthclient.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthClientMutation) ResetEdge(name string) error {
	switch name {
	case oauthclient.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case oauthclient.EdgeTokens:
		m.ResetTokens()
		return nil
	case oauthclient.EdgeAuthorizations:
		m.ResetAuthorizations()
		return nil
	case oauthclient.EdgeScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient edge %s", name)
}

// OAuthScopeMutation represents an operation that mutates the OAuthScope nodes in the graph.
type OAuthScopeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *xid.ID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	description           *string
	default_scope         *bool
	public                *bool
	clearedFields         map[string]struct{}
	clients               map[xid.ID]struct{}
	removedclients        map[xid.ID]struct{}
	clearedclients        bool
	tokens                map[xid.ID]struct{}
	removedtokens         map[xid.ID]struct{}
	clearedtokens         bool
	authorizations        map[xid.ID]struct{}
	removedauthorizations map[xid.ID]struct{}
	clearedauthorizations bool
	done                  bool
	oldValue              func(context.Context) (*OAuthScope, error)
	predicates            []predicate.OAuthScope
}

var _ ent.Mutation = (*OAuthScopeMutation)(nil)

// oauthscopeOption allows management of the mutation configuration using functional options.
type oauthscopeOption func(*OAuthScopeMutation)

// newOAuthScopeMutation creates new mutation for the OAuthScope entity.
func newOAuthScopeMutation(c config, op Op, opts ...oauthscopeOption) *OAuthScopeMutation {
	m := &OAuthScopeMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthScope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthScopeID sets the ID field of the mutation.
func withOAuthScopeID(id xid.ID) oauthscopeOption {
	return func(m *OAuthScopeMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthScope
		)
		m.oldValue = func(ctx context.Context) (*OAuthScope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthScope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthScope sets the old OAuthScope of the mutation.
func withOAuthScope(node *OAuthScope) oauthscopeOption {
	return func(m *OAuthScopeMutation) {
		m.oldValue = func(context.Context) (*OAuthScope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthScopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthScopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthScope entities.
func (m *OAuthScopeMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthScopeMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthScopeMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthScope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthScopeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthScopeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthScopeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthScopeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthScopeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthScopeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OAuthScopeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OAuthScopeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OAuthScopeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[oauthscope.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OAuthScopeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[oauthscope.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OAuthScopeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, oauthscope.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *OAuthScopeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OAuthScopeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OAuthScopeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OAuthScopeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OAuthScopeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OAuthScopeMutation) ResetDescription() {
	m.description = nil
}

// SetDefaultScope sets the "default_scope" field.
func (m *OAuthScopeMutation) SetDefaultScope(b bool) {
	m.default_scope = &b
}

// DefaultScope returns the value of the "default_scope" field in the mutation.
func (m *OAuthScopeMutation) DefaultScope() (r bool, exists bool) {
	v := m.default_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultScope returns the old "default_scope" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldDefaultScope(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultScope: %w", err)
	}
	return oldValue.DefaultScope, nil
}

// ResetDefaultScope resets all changes to the "default_scope" field.
func (m *OAuthScopeMutation) ResetDefaultScope() {
	m.default_scope = nil
}

// SetPublic sets the "public" field.
func (m *OAuthScopeMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *OAuthScopeMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *OAuthScopeMutation) ResetPublic() {
	m.public = nil
}

// AddClientIDs adds the "clients" edge to the OAuthClient entity by ids.
func (m *OAuthScopeMutation) AddClientIDs(ids ...xid.ID) {
	if m.clients == nil {
		m.clients = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.clients[ids[i]] = struct{}{}
	}
}

// ClearClients clears the "clients" edge to the OAuthClient entity.
func (m *OAuthScopeMutation) ClearClients() {
	m.clearedclients = true
}

// ClientsCleared reports if the "clients" edge to the OAuthClient entity was cleared.
func (m *OAuthScopeMutation) ClientsCleared() bool {
	return m.clearedclients
}

// RemoveClientIDs removes the "clients" edge to the OAuthClient entity by IDs.
func (m *OAuthScopeMutation) RemoveClientIDs(ids ...xid.ID) {
	if m.removedclients == nil {
		m.removedclients = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.clients, ids[i])
		m.removedclients[ids[i]] = struct{}{}
	}
}

// RemovedClients returns the removed IDs of the "clients" edge to the OAuthClient entity.
func (m *OAuthScopeMutation) RemovedClientsIDs() (ids []xid.ID) {
	for id := range m.removedclients {
		ids = append(ids, id)
	}
	return
}

// ClientsIDs returns the "clients" edge IDs in the mutation.
func (m *OAuthScopeMutation) ClientsIDs() (ids []xid.ID) {
	for id := range m.clients {
		ids = append(ids, id)
	}
	return
}

// ResetClients resets all changes to the "clients" edge.
func (m *OAuthScopeMutation) ResetClients() {
	m.clients = nil
	m.clearedclients = false
	m.removedclients = nil
}

// AddTokenIDs adds the "tokens" edge to the OAuthToken entity by ids.
func (m *OAuthScopeMutation) AddTokenIDs(ids ...xid.ID) {
	if m.tokens == nil {
		m.tokens = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the OAuthToken entity.
func (m *OAuthScopeMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the OAuthToken entity was cleared.
func (m *OAuthScopeMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the OAuthToken entity by IDs.
func (m *OAuthScopeMutation) RemoveTokenIDs(ids ...xid.ID) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the OAuthToken entity.
func (m *OAuthScopeMutation) RemovedTokensIDs() (ids []xid.ID) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *OAuthScopeMutation) TokensIDs() (ids []xid.ID) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *OAuthScopeMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddAuthorizationIDs adds the "authorizations" edge to the OAuthAuthorization entity by ids.
func (m *OAuthScopeMutation) AddAuthorizationIDs(ids ...xid.ID) {
	if m.authorizations == nil {
		m.authorizations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.authorizations[ids[i]] = struct{}{}
	}
}

// ClearAuthorizations clears the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthScopeMutation) ClearAuthorizations() {
	m.clearedauthorizations = true
}

// AuthorizationsCleared reports if the "authorizations" edge to the OAuthAuthorization entity was cleared.
func (m *OAuthScopeMutation) AuthorizationsCleared() bool {
	return m.clearedauthorizations
}

// RemoveAuthorizationIDs removes the "authorizations" edge to the OAuthAuthorization entity by IDs.
func (m *OAuthScopeMutation) RemoveAuthorizationIDs(ids ...xid.ID) {
	if m.removedauthorizations == nil {
		m.removedauthorizations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.authorizations, ids[i])
		m.removedauthorizations[ids[i]] = struct{}{}
	}
}

// RemovedAuthorizations returns the removed IDs of the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthScopeMutation) RemovedAuthorizationsIDs() (ids []xid.ID) {
	for id := range m.removedauthorizations {
		ids = append(ids, id)
	}
	return
}

// AuthorizationsIDs returns the "authorizations" edge IDs in the mutation.
func (m *OAuthScopeMutation) AuthorizationsIDs() (ids []xid.ID) {
	for id := range m.authorizations {
		ids = append(ids, id)
	}
	return
}

// ResetAuthorizations resets all changes to the "authorizations" edge.
func (m *OAuthScopeMutation) ResetAuthorizations() {
	m.authorizations = nil
	m.clearedauthorizations = false
	m.removedauthorizations = nil
}

// Where appends a list predicates to the OAuthScopeMutation builder.
func (m *OAuthScopeMutation) Where(ps ...predicate.OAuthScope) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthScopeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthScopeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthScope, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthScopeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthScopeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthScope).
func (m *OAuthScopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthScopeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, oauthscope.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthscope.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauthscope.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, oauthscope.FieldName)
	}
	if m.description != nil {
		fields = append(fields, oauthscope.FieldDescription)
	}
	if m.default_scope != nil {
		fields = append(fields, oauthscope.FieldDefaultScope)
	}
	if m.public != nil {
		fields = append(fields, oauthscope.FieldPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthScopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthscope.FieldCreatedAt:
		return m.CreatedAt()
	case oauthscope.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthscope.FieldDeletedAt:
		return m.DeletedAt()
	case oauthscope.FieldName:
		return m.Name()
	case oauthscope.FieldDescription:
		return m.Description()
	case oauthscope.FieldDefaultScope:
		return m.DefaultScope()
	case oauthscope.FieldPublic:
		return m.Public()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthScopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthscope.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthscope.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthscope.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauthscope.FieldName:
		return m.OldName(ctx)
	case oauthscope.FieldDescription:
		return m.OldDescription(ctx)
	case oauthscope.FieldDefaultScope:
		return m.OldDefaultScope(ctx)
	case oauthscope.FieldPublic:
		return m.OldPublic(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthScope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthScopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthscope.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthscope.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthscope.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauthscope.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthscope.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case oauthscope.FieldDefaultScope:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultScope(v)
		return nil
	case oauthscope.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthScope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthScopeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthScopeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthScopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthScope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthScopeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthscope.FieldDeletedAt) {
		fields = append(fields, oauthscope.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthScopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthScopeMutation) ClearField(name string) error {
	switch name {
	case oauthscope.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown OAuthScope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthScopeMutation) ResetField(name string) error {
	switch name {
	case oauthscope.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthscope.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthscope.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauthscope.FieldName:
		m.ResetName()
		return nil
	case oauthscope.FieldDescription:
		m.ResetDescription()
		return nil
	case oauthscope.FieldDefaultScope:
		m.ResetDefaultScope()
		return nil
	case oauthscope.FieldPublic:
		m.ResetPublic()
		return nil
	}
	return fmt.Errorf("unknown OAuthScope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthScopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clients != nil {
		edges = append(edges, oauthscope.EdgeClients)
	}
	if m.tokens != nil {
		edges = append(edges, oauthscope.EdgeTokens)
	}
	if m.authorizations != nil {
		edges = append(edges, oauthscope.EdgeAuthorizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthScopeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthscope.EdgeClients:
		ids := make([]ent.Value, 0, len(m.clients))
		for id := range m.clients {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.authorizations))
		for id := range m.authorizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthScopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedclients != nil {
		edges = append(edges, oauthscope.EdgeClients)
	}
	if m.removedtokens != nil {
		edges = append(edges, oauthscope.EdgeTokens)
	}
	if m.removedauthorizations != nil {
		edges = append(edges, oauthscope.EdgeAuthorizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthScopeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthscope.EdgeClients:
		ids := make([]ent.Value, 0, len(m.removedclients))
		for id := range m.removedclients {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.removedauthorizations))
		for id := range m.removedauthorizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthScopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclients {
		edges = append(edges, oauthscope.EdgeClients)
	}
	if m.clearedtokens {
		edges = append(edges, oauthscope.EdgeTokens)
	}
	if m.clearedauthorizations {
		edges = append(edges, oauthscope.EdgeAuthorizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthScopeMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthscope.EdgeClients:
		return m.clearedclients
	case oauthscope.EdgeTokens:
		return m.clearedtokens
	case oauthscope.EdgeAuthorizations:
		return m.clearedauthorizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthScopeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthScope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthScopeMutation) ResetEdge(name string) error {
	switch name {
	case oauthscope.EdgeClients:
		m.ResetClients()
		return nil
	case oauthscope.EdgeTokens:
		m.ResetTokens()
		return nil
	case oauthscope.EdgeAuthorizations:
		m.ResetAuthorizations()
		return nil
	}
	return fmt.Errorf("unknown OAuthScope edge %s", name)
}

// OAuthTokenMutation represents an operation that mutates the OAuthToken nodes in the graph.
type OAuthTokenMutation struct {
	config
	op                       Op
	typ                      string
	id                       *xid.ID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	access_token             *string
	refresh_token            *string
	token_type               *string
	organization_id          *xid.ID
	scope_names              *[]string
	appendscope_names        []string
	expires_in               *int
	addexpires_in            *int
	expires_at               *time.Time
	refresh_token_expires_at *time.Time
	revoked                  *bool
	revoked_at               *time.Time
	ip_address               *string
	user_agent               *string
	clearedFields            map[string]struct{}
	client                   *xid.ID
	clearedclient            bool
	user                     *xid.ID
	cleareduser              bool
	scopes                   map[xid.ID]struct{}
	removedscopes            map[xid.ID]struct{}
	clearedscopes            bool
	done                     bool
	oldValue                 func(context.Context) (*OAuthToken, error)
	predicates               []predicate.OAuthToken
}

var _ ent.Mutation = (*OAuthTokenMutation)(nil)

// oauthtokenOption allows management of the mutation configuration using functional options.
type oauthtokenOption func(*OAuthTokenMutation)

// newOAuthTokenMutation creates new mutation for the OAuthToken entity.
func newOAuthTokenMutation(c config, op Op, opts ...oauthtokenOption) *OAuthTokenMutation {
	m := &OAuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthTokenID sets the ID field of the mutation.
func withOAuthTokenID(id xid.ID) oauthtokenOption {
	return func(m *OAuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthToken
		)
		m.oldValue = func(ctx context.Context) (*OAuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthToken sets the old OAuthToken of the mutation.
func withOAuthToken(node *OAuthToken) oauthtokenOption {
	return func(m *OAuthTokenMutation) {
		m.oldValue = func(context.Context) (*OAuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthToken entities.
func (m *OAuthTokenMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthTokenMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthTokenMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OAuthTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OAuthTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OAuthTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[oauthtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OAuthTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OAuthTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, oauthtoken.FieldDeletedAt)
}

// SetAccessToken sets the "access_token" field.
func (m *OAuthTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *OAuthTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *OAuthTokenMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *OAuthTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *OAuthTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *OAuthTokenMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[oauthtoken.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *OAuthTokenMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *OAuthTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, oauthtoken.FieldRefreshToken)
}

// SetTokenType sets the "token_type" field.
func (m *OAuthTokenMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *OAuthTokenMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *OAuthTokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetClientID sets the "client_id" field.
func (m *OAuthTokenMutation) SetClientID(x xid.ID) {
	m.client = &x
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthTokenMutation) ClientID() (r xid.ID, exists bool) {
	v := m.client
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldClientID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthTokenMutation) ResetClientID() {
	m.client = nil
}

// SetUserID sets the "user_id" field.
func (m *OAuthTokenMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OAuthTokenMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OAuthTokenMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OAuthTokenMutation) SetOrganizationID(x xid.ID) {
	m.organization_id = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OAuthTokenMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OAuthTokenMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[oauthtoken.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OAuthTokenMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OAuthTokenMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, oauthtoken.FieldOrganizationID)
}

// SetScopeNames sets the "scope_names" field.
func (m *OAuthTokenMutation) SetScopeNames(s []string) {
	m.scope_names = &s
	m.appendscope_names = nil
}

// ScopeNames returns the value of the "scope_names" field in the mutation.
func (m *OAuthTokenMutation) ScopeNames() (r []string, exists bool) {
	v := m.scope_names
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeNames returns the old "scope_names" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldScopeNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeNames: %w", err)
	}
	return oldValue.ScopeNames, nil
}

// AppendScopeNames adds s to the "scope_names" field.
func (m *OAuthTokenMutation) AppendScopeNames(s []string) {
	m.appendscope_names = append(m.appendscope_names, s...)
}

// AppendedScopeNames returns the list of values that were appended to the "scope_names" field in this mutation.
func (m *OAuthTokenMutation) AppendedScopeNames() ([]string, bool) {
	if len(m.appendscope_names) == 0 {
		return nil, false
	}
	return m.appendscope_names, true
}

// ClearScopeNames clears the value of the "scope_names" field.
func (m *OAuthTokenMutation) ClearScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	m.clearedFields[oauthtoken.FieldScopeNames] = struct{}{}
}

// ScopeNamesCleared returns if the "scope_names" field was cleared in this mutation.
func (m *OAuthTokenMutation) ScopeNamesCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldScopeNames]
	return ok
}

// ResetScopeNames resets all changes to the "scope_names" field.
func (m *OAuthTokenMutation) ResetScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	delete(m.clearedFields, oauthtoken.FieldScopeNames)
}

// SetExpiresIn sets the "expires_in" field.
func (m *OAuthTokenMutation) SetExpiresIn(i int) {
	m.expires_in = &i
	m.addexpires_in = nil
}

// ExpiresIn returns the value of the "expires_in" field in the mutation.
func (m *OAuthTokenMutation) ExpiresIn() (r int, exists bool) {
	v := m.expires_in
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresIn returns the old "expires_in" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldExpiresIn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresIn: %w", err)
	}
	return oldValue.ExpiresIn, nil
}

// AddExpiresIn adds i to the "expires_in" field.
func (m *OAuthTokenMutation) AddExpiresIn(i int) {
	if m.addexpires_in != nil {
		*m.addexpires_in += i
	} else {
		m.addexpires_in = &i
	}
}

// AddedExpiresIn returns the value that was added to the "expires_in" field in this mutation.
func (m *OAuthTokenMutation) AddedExpiresIn() (r int, exists bool) {
	v := m.addexpires_in
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresIn resets all changes to the "expires_in" field.
func (m *OAuthTokenMutation) ResetExpiresIn() {
	m.expires_in = nil
	m.addexpires_in = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OAuthTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OAuthTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OAuthTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRefreshTokenExpiresAt sets the "refresh_token_expires_at" field.
func (m *OAuthTokenMutation) SetRefreshTokenExpiresAt(t time.Time) {
	m.refresh_token_expires_at = &t
}

// RefreshTokenExpiresAt returns the value of the "refresh_token_expires_at" field in the mutation.
func (m *OAuthTokenMutation) RefreshTokenExpiresAt() (r time.Time, exists bool) {
	v := m.refresh_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenExpiresAt returns the old "refresh_token_expires_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRefreshTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenExpiresAt: %w", err)
	}
	return oldValue.RefreshTokenExpiresAt, nil
}

// ClearRefreshTokenExpiresAt clears the value of the "refresh_token_expires_at" field.
func (m *OAuthTokenMutation) ClearRefreshTokenExpiresAt() {
	m.refresh_token_expires_at = nil
	m.clearedFields[oauthtoken.FieldRefreshTokenExpiresAt] = struct{}{}
}

// RefreshTokenExpiresAtCleared returns if the "refresh_token_expires_at" field was cleared in this mutation.
func (m *OAuthTokenMutation) RefreshTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRefreshTokenExpiresAt]
	return ok
}

// ResetRefreshTokenExpiresAt resets all changes to the "refresh_token_expires_at" field.
func (m *OAuthTokenMutation) ResetRefreshTokenExpiresAt() {
	m.refresh_token_expires_at = nil
	delete(m.clearedFields, oauthtoken.FieldRefreshTokenExpiresAt)
}

// SetRevoked sets the "revoked" field.
func (m *OAuthTokenMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *OAuthTokenMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *OAuthTokenMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *OAuthTokenMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *OAuthTokenMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *OAuthTokenMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[oauthtoken.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *OAuthTokenMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *OAuthTokenMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, oauthtoken.FieldRevokedAt)
}

// SetIPAddress sets the "ip_address" field.
func (m *OAuthTokenMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *OAuthTokenMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *OAuthTokenMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[oauthtoken.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *OAuthTokenMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *OAuthTokenMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, oauthtoken.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *OAuthTokenMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *OAuthTokenMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *OAuthTokenMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[oauthtoken.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *OAuthTokenMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *OAuthTokenMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, oauthtoken.FieldUserAgent)
}

// ClearClient clears the "client" edge to the OAuthClient entity.
func (m *OAuthTokenMutation) ClearClient() {
	m.clearedclient = true
	m.clearedFields[oauthtoken.FieldClientID] = struct{}{}
}

// ClientCleared reports if the "client" edge to the OAuthClient entity was cleared.
func (m *OAuthTokenMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *OAuthTokenMutation) ClientIDs() (ids []xid.ID) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *OAuthTokenMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OAuthTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oauthtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OAuthTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OAuthTokenMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OAuthTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddScopeIDs adds the "scopes" edge to the OAuthScope entity by ids.
func (m *OAuthTokenMutation) AddScopeIDs(ids ...xid.ID) {
	if m.scopes == nil {
		m.scopes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the OAuthScope entity.
func (m *OAuthTokenMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the OAuthScope entity was cleared.
func (m *OAuthTokenMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the OAuthScope entity by IDs.
func (m *OAuthTokenMutation) RemoveScopeIDs(ids ...xid.ID) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the OAuthScope entity.
func (m *OAuthTokenMutation) RemovedScopesIDs() (ids []xid.ID) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *OAuthTokenMutation) ScopesIDs() (ids []xid.ID) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *OAuthTokenMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// Where appends a list predicates to the OAuthTokenMutation builder.
func (m *OAuthTokenMutation) Where(ps ...predicate.OAuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthToken).
func (m *OAuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, oauthtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthtoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauthtoken.FieldDeletedAt)
	}
	if m.access_token != nil {
		fields = append(fields, oauthtoken.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauthtoken.FieldRefreshToken)
	}
	if m.token_type != nil {
		fields = append(fields, oauthtoken.FieldTokenType)
	}
	if m.client != nil {
		fields = append(fields, oauthtoken.FieldClientID)
	}
	if m.user != nil {
		fields = append(fields, oauthtoken.FieldUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, oauthtoken.FieldOrganizationID)
	}
	if m.scope_names != nil {
		fields = append(fields, oauthtoken.FieldScopeNames)
	}
	if m.expires_in != nil {
		fields = append(fields, oauthtoken.FieldExpiresIn)
	}
	if m.expires_at != nil {
		fields = append(fields, oauthtoken.FieldExpiresAt)
	}
	if m.refresh_token_expires_at != nil {
		fields = append(fields, oauthtoken.FieldRefreshTokenExpiresAt)
	}
	if m.revoked != nil {
		fields = append(fields, oauthtoken.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, oauthtoken.FieldRevokedAt)
	}
	if m.ip_address != nil {
		fields = append(fields, oauthtoken.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, oauthtoken.FieldUserAgent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthtoken.FieldCreatedAt:
		return m.CreatedAt()
	case oauthtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthtoken.FieldDeletedAt:
		return m.DeletedAt()
	case oauthtoken.FieldAccessToken:
		return m.AccessToken()
	case oauthtoken.FieldRefreshToken:
		return m.RefreshToken()
	case oauthtoken.FieldTokenType:
		return m.TokenType()
	case oauthtoken.FieldClientID:
		return m.ClientID()
	case oauthtoken.FieldUserID:
		return m.UserID()
	case oauthtoken.FieldOrganizationID:
		return m.OrganizationID()
	case oauthtoken.FieldScopeNames:
		return m.ScopeNames()
	case oauthtoken.FieldExpiresIn:
		return m.ExpiresIn()
	case oauthtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case oauthtoken.FieldRefreshTokenExpiresAt:
		return m.RefreshTokenExpiresAt()
	case oauthtoken.FieldRevoked:
		return m.Revoked()
	case oauthtoken.FieldRevokedAt:
		return m.RevokedAt()
	case oauthtoken.FieldIPAddress:
		return m.IPAddress()
	case oauthtoken.FieldUserAgent:
		return m.UserAgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauthtoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case oauthtoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case oauthtoken.FieldTokenType:
		return m.OldTokenType(ctx)
	case oauthtoken.FieldClientID:
		return m.OldClientID(ctx)
	case oauthtoken.FieldUserID:
		return m.OldUserID(ctx)
	case oauthtoken.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case oauthtoken.FieldScopeNames:
		return m.OldScopeNames(ctx)
	case oauthtoken.FieldExpiresIn:
		return m.OldExpiresIn(ctx)
	case oauthtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case oauthtoken.FieldRefreshTokenExpiresAt:
		return m.OldRefreshTokenExpiresAt(ctx)
	case oauthtoken.FieldRevoked:
		return m.OldRevoked(ctx)
	case oauthtoken.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case oauthtoken.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case oauthtoken.FieldUserAgent:
		return m.OldUserAgent(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauthtoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case oauthtoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case oauthtoken.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case oauthtoken.FieldClientID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthtoken.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthtoken.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case oauthtoken.FieldScopeNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeNames(v)
		return nil
	case oauthtoken.FieldExpiresIn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresIn(v)
		return nil
	case oauthtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case oauthtoken.FieldRefreshTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenExpiresAt(v)
		return nil
	case oauthtoken.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case oauthtoken.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case oauthtoken.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case oauthtoken.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthTokenMutation) AddedFields() []string {
	var fields []string
	if m.addexpires_in != nil {
		fields = append(fields, oauthtoken.FieldExpiresIn)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthtoken.FieldExpiresIn:
		return m.AddedExpiresIn()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthtoken.FieldExpiresIn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresIn(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthtoken.FieldDeletedAt) {
		fields = append(fields, oauthtoken.FieldDeletedAt)
	}
	if m.FieldCleared(oauthtoken.FieldRefreshToken) {
		fields = append(fields, oauthtoken.FieldRefreshToken)
	}
	if m.FieldCleared(oauthtoken.FieldOrganizationID) {
		fields = append(fields, oauthtoken.FieldOrganizationID)
	}
	if m.FieldCleared(oauthtoken.FieldScopeNames) {
		fields = append(fields, oauthtoken.FieldScopeNames)
	}
	if m.FieldCleared(oauthtoken.FieldRefreshTokenExpiresAt) {
		fields = append(fields, oauthtoken.FieldRefreshTokenExpiresAt)
	}
	if m.FieldCleared(oauthtoken.FieldRevokedAt) {
		fields = append(fields, oauthtoken.FieldRevokedAt)
	}
	if m.FieldCleared(oauthtoken.FieldIPAddress) {
		fields = append(fields, oauthtoken.FieldIPAddress)
	}
	if m.FieldCleared(oauthtoken.FieldUserAgent) {
		fields = append(fields, oauthtoken.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthTokenMutation) ClearField(name string) error {
	switch name {
	case oauthtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case oauthtoken.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case oauthtoken.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case oauthtoken.FieldScopeNames:
		m.ClearScopeNames()
		return nil
	case oauthtoken.FieldRefreshTokenExpiresAt:
		m.ClearRefreshTokenExpiresAt()
		return nil
	case oauthtoken.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case oauthtoken.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case oauthtoken.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthTokenMutation) ResetField(name string) error {
	switch name {
	case oauthtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauthtoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case oauthtoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case oauthtoken.FieldTokenType:
		m.ResetTokenType()
		return nil
	case oauthtoken.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthtoken.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case oauthtoken.FieldScopeNames:
		m.ResetScopeNames()
		return nil
	case oauthtoken.FieldExpiresIn:
		m.ResetExpiresIn()
		return nil
	case oauthtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case oauthtoken.FieldRefreshTokenExpiresAt:
		m.ResetRefreshTokenExpiresAt()
		return nil
	case oauthtoken.FieldRevoked:
		m.ResetRevoked()
		return nil
	case oauthtoken.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case oauthtoken.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case oauthtoken.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.client != nil {
		edges = append(edges, oauthtoken.EdgeClient)
	}
	if m.user != nil {
		edges = append(edges, oauthtoken.EdgeUser)
	}
	if m.scopes != nil {
		edges = append(edges, oauthtoken.EdgeScopes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthtoken.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case oauthtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oauthtoken.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedscopes != nil {
		edges = append(edges, oauthtoken.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthtoken.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclient {
		edges = append(edges, oauthtoken.EdgeClient)
	}
	if m.cleareduser {
		edges = append(edges, oauthtoken.EdgeUser)
	}
	if m.clearedscopes {
		edges = append(edges, oauthtoken.EdgeScopes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthtoken.EdgeClient:
		return m.clearedclient
	case oauthtoken.EdgeUser:
		return m.cleareduser
	case oauthtoken.EdgeScopes:
		return m.clearedscopes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthTokenMutation) ClearEdge(name string) error {
	switch name {
	case oauthtoken.EdgeClient:
		m.ClearClient()
		return nil
	case oauthtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthTokenMutation) ResetEdge(name string) error {
	switch name {
	case oauthtoken.EdgeClient:
		m.ResetClient()
		return nil
	case oauthtoken.EdgeUser:
		m.ResetUser()
		return nil
	case oauthtoken.EdgeScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *xid.ID
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	name                            *string
	slug                            *string
	domains                         *[]string
	appenddomains                   []string
	verified_domains                *[]string
	appendverified_domains          []string
	domain                          *string
	logo_url                        *string
	plan                            *string
	active                          *bool
	metadata                        *map[string]interface{}
	trial_ends_at                   *time.Time
	trial_used                      *bool
	owner_id                        *xid.ID
	org_type                        *model.OrgType
	is_platform_organization        *bool
	external_user_limit             *int
	addexternal_user_limit          *int
	end_user_limit                  *int
	addend_user_limit               *int
	sso_enabled                     *bool
	sso_domain                      *string
	subscription_id                 *string
	customer_id                     *string
	subscription_status             *organization.SubscriptionStatus
	auth_service_enabled            *bool
	auth_config                     *map[string]interface{}
	auth_domain                     *string
	api_request_limit               *int
	addapi_request_limit            *int
	api_requests_used               *int
	addapi_requests_used            *int
	current_external_users          *int
	addcurrent_external_users       *int
	current_end_users               *int
	addcurrent_end_users            *int
	clearedFields                   map[string]struct{}
	users                           map[xid.ID]struct{}
	removedusers                    map[xid.ID]struct{}
	clearedusers                    bool
	memberships                     map[xid.ID]struct{}
	removedmemberships              map[xid.ID]struct{}
	clearedmemberships              bool
	sms_templates                   map[xid.ID]struct{}
	removedsms_templates            map[xid.ID]struct{}
	clearedsms_templates            bool
	email_templates                 map[xid.ID]struct{}
	removedemail_templates          map[xid.ID]struct{}
	clearedemail_templates          bool
	api_keys                        map[xid.ID]struct{}
	removedapi_keys                 map[xid.ID]struct{}
	clearedapi_keys                 bool
	webhooks                        map[xid.ID]struct{}
	removedwebhooks                 map[xid.ID]struct{}
	clearedwebhooks                 bool
	feature_flags                   map[xid.ID]struct{}
	removedfeature_flags            map[xid.ID]struct{}
	clearedfeature_flags            bool
	identity_providers              map[xid.ID]struct{}
	removedidentity_providers       map[xid.ID]struct{}
	clearedidentity_providers       bool
	oauth_clients                   map[xid.ID]struct{}
	removedoauth_clients            map[xid.ID]struct{}
	clearedoauth_clients            bool
	roles                           map[xid.ID]struct{}
	removedroles                    map[xid.ID]struct{}
	clearedroles                    bool
	user_role_contexts              map[xid.ID]struct{}
	removeduser_role_contexts       map[xid.ID]struct{}
	cleareduser_role_contexts       bool
	user_permission_contexts        map[xid.ID]struct{}
	removeduser_permission_contexts map[xid.ID]struct{}
	cleareduser_permission_contexts bool
	audit_logs                      map[xid.ID]struct{}
	removedaudit_logs               map[xid.ID]struct{}
	clearedaudit_logs               bool
	organization_providers          map[xid.ID]struct{}
	removedorganization_providers   map[xid.ID]struct{}
	clearedorganization_providers   bool
	activities                      map[xid.ID]struct{}
	removedactivities               map[xid.ID]struct{}
	clearedactivities               bool
	done                            bool
	oldValue                        func(context.Context) (*Organization, error)
	predicates                      []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id xid.ID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organization.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrganizationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrganizationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrganizationMutation) ResetSlug() {
	m.slug = nil
}

// SetDomains sets the "domains" field.
func (m *OrganizationMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *OrganizationMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *OrganizationMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *OrganizationMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *OrganizationMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[organization.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *OrganizationMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[organization.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *OrganizationMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, organization.FieldDomains)
}

// SetVerifiedDomains sets the "verified_domains" field.
func (m *OrganizationMutation) SetVerifiedDomains(s []string) {
	m.verified_domains = &s
	m.appendverified_domains = nil
}

// VerifiedDomains returns the value of the "verified_domains" field in the mutation.
func (m *OrganizationMutation) VerifiedDomains() (r []string, exists bool) {
	v := m.verified_domains
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedDomains returns the old "verified_domains" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldVerifiedDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedDomains: %w", err)
	}
	return oldValue.VerifiedDomains, nil
}

// AppendVerifiedDomains adds s to the "verified_domains" field.
func (m *OrganizationMutation) AppendVerifiedDomains(s []string) {
	m.appendverified_domains = append(m.appendverified_domains, s...)
}

// AppendedVerifiedDomains returns the list of values that were appended to the "verified_domains" field in this mutation.
func (m *OrganizationMutation) AppendedVerifiedDomains() ([]string, bool) {
	if len(m.appendverified_domains) == 0 {
		return nil, false
	}
	return m.appendverified_domains, true
}

// ClearVerifiedDomains clears the value of the "verified_domains" field.
func (m *OrganizationMutation) ClearVerifiedDomains() {
	m.verified_domains = nil
	m.appendverified_domains = nil
	m.clearedFields[organization.FieldVerifiedDomains] = struct{}{}
}

// VerifiedDomainsCleared returns if the "verified_domains" field was cleared in this mutation.
func (m *OrganizationMutation) VerifiedDomainsCleared() bool {
	_, ok := m.clearedFields[organization.FieldVerifiedDomains]
	return ok
}

// ResetVerifiedDomains resets all changes to the "verified_domains" field.
func (m *OrganizationMutation) ResetVerifiedDomains() {
	m.verified_domains = nil
	m.appendverified_domains = nil
	delete(m.clearedFields, organization.FieldVerifiedDomains)
}

// SetDomain sets the "domain" field.
func (m *OrganizationMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *OrganizationMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *OrganizationMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[organization.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *OrganizationMutation) DomainCleared() bool {
	_, ok := m.clearedFields[organization.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *OrganizationMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, organization.FieldDomain)
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetPlan sets the "plan" field.
func (m *OrganizationMutation) SetPlan(s string) {
	m.plan = &s
}

// Plan returns the value of the "plan" field in the mutation.
func (m *OrganizationMutation) Plan() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlan returns the old "plan" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlan: %w", err)
	}
	return oldValue.Plan, nil
}

// ResetPlan resets all changes to the "plan" field.
func (m *OrganizationMutation) ResetPlan() {
	m.plan = nil
}

// SetActive sets the "active" field.
func (m *OrganizationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OrganizationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OrganizationMutation) ResetActive() {
	m.active = nil
}

// SetMetadata sets the "metadata" field.
func (m *OrganizationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *OrganizationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *OrganizationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[organization.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *OrganizationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[organization.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *OrganizationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, organization.FieldMetadata)
}

// SetTrialEndsAt sets the "trial_ends_at" field.
func (m *OrganizationMutation) SetTrialEndsAt(t time.Time) {
	m.trial_ends_at = &t
}

// TrialEndsAt returns the value of the "trial_ends_at" field in the mutation.
func (m *OrganizationMutation) TrialEndsAt() (r time.Time, exists bool) {
	v := m.trial_ends_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialEndsAt returns the old "trial_ends_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTrialEndsAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialEndsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialEndsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialEndsAt: %w", err)
	}
	return oldValue.TrialEndsAt, nil
}

// ClearTrialEndsAt clears the value of the "trial_ends_at" field.
func (m *OrganizationMutation) ClearTrialEndsAt() {
	m.trial_ends_at = nil
	m.clearedFields[organization.FieldTrialEndsAt] = struct{}{}
}

// TrialEndsAtCleared returns if the "trial_ends_at" field was cleared in this mutation.
func (m *OrganizationMutation) TrialEndsAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldTrialEndsAt]
	return ok
}

// ResetTrialEndsAt resets all changes to the "trial_ends_at" field.
func (m *OrganizationMutation) ResetTrialEndsAt() {
	m.trial_ends_at = nil
	delete(m.clearedFields, organization.FieldTrialEndsAt)
}

// SetTrialUsed sets the "trial_used" field.
func (m *OrganizationMutation) SetTrialUsed(b bool) {
	m.trial_used = &b
}

// TrialUsed returns the value of the "trial_used" field in the mutation.
func (m *OrganizationMutation) TrialUsed() (r bool, exists bool) {
	v := m.trial_used
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialUsed returns the old "trial_used" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTrialUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialUsed: %w", err)
	}
	return oldValue.TrialUsed, nil
}

// ResetTrialUsed resets all changes to the "trial_used" field.
func (m *OrganizationMutation) ResetTrialUsed() {
	m.trial_used = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *OrganizationMutation) SetOwnerID(x xid.ID) {
	m.owner_id = &x
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrganizationMutation) OwnerID() (r xid.ID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOwnerID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OrganizationMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[organization.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OrganizationMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrganizationMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, organization.FieldOwnerID)
}

// SetOrgType sets the "org_type" field.
func (m *OrganizationMutation) SetOrgType(mt model.OrgType) {
	m.org_type = &mt
}

// OrgType returns the value of the "org_type" field in the mutation.
func (m *OrganizationMutation) OrgType() (r model.OrgType, exists bool) {
	v := m.org_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgType returns the old "org_type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOrgType(ctx context.Context) (v model.OrgType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgType: %w", err)
	}
	return oldValue.OrgType, nil
}

// ResetOrgType resets all changes to the "org_type" field.
func (m *OrganizationMutation) ResetOrgType() {
	m.org_type = nil
}

// SetIsPlatformOrganization sets the "is_platform_organization" field.
func (m *OrganizationMutation) SetIsPlatformOrganization(b bool) {
	m.is_platform_organization = &b
}

// IsPlatformOrganization returns the value of the "is_platform_organization" field in the mutation.
func (m *OrganizationMutation) IsPlatformOrganization() (r bool, exists bool) {
	v := m.is_platform_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPlatformOrganization returns the old "is_platform_organization" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldIsPlatformOrganization(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPlatformOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPlatformOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPlatformOrganization: %w", err)
	}
	return oldValue.IsPlatformOrganization, nil
}

// ResetIsPlatformOrganization resets all changes to the "is_platform_organization" field.
func (m *OrganizationMutation) ResetIsPlatformOrganization() {
	m.is_platform_organization = nil
}

// SetExternalUserLimit sets the "external_user_limit" field.
func (m *OrganizationMutation) SetExternalUserLimit(i int) {
	m.external_user_limit = &i
	m.addexternal_user_limit = nil
}

// ExternalUserLimit returns the value of the "external_user_limit" field in the mutation.
func (m *OrganizationMutation) ExternalUserLimit() (r int, exists bool) {
	v := m.external_user_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalUserLimit returns the old "external_user_limit" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldExternalUserLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalUserLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalUserLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalUserLimit: %w", err)
	}
	return oldValue.ExternalUserLimit, nil
}

// AddExternalUserLimit adds i to the "external_user_limit" field.
func (m *OrganizationMutation) AddExternalUserLimit(i int) {
	if m.addexternal_user_limit != nil {
		*m.addexternal_user_limit += i
	} else {
		m.addexternal_user_limit = &i
	}
}

// AddedExternalUserLimit returns the value that was added to the "external_user_limit" field in this mutation.
func (m *OrganizationMutation) AddedExternalUserLimit() (r int, exists bool) {
	v := m.addexternal_user_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetExternalUserLimit resets all changes to the "external_user_limit" field.
func (m *OrganizationMutation) ResetExternalUserLimit() {
	m.external_user_limit = nil
	m.addexternal_user_limit = nil
}

// SetEndUserLimit sets the "end_user_limit" field.
func (m *OrganizationMutation) SetEndUserLimit(i int) {
	m.end_user_limit = &i
	m.addend_user_limit = nil
}

// EndUserLimit returns the value of the "end_user_limit" field in the mutation.
func (m *OrganizationMutation) EndUserLimit() (r int, exists bool) {
	v := m.end_user_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldEndUserLimit returns the old "end_user_limit" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldEndUserLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndUserLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndUserLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndUserLimit: %w", err)
	}
	return oldValue.EndUserLimit, nil
}

// AddEndUserLimit adds i to the "end_user_limit" field.
func (m *OrganizationMutation) AddEndUserLimit(i int) {
	if m.addend_user_limit != nil {
		*m.addend_user_limit += i
	} else {
		m.addend_user_limit = &i
	}
}

// AddedEndUserLimit returns the value that was added to the "end_user_limit" field in this mutation.
func (m *OrganizationMutation) AddedEndUserLimit() (r int, exists bool) {
	v := m.addend_user_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndUserLimit resets all changes to the "end_user_limit" field.
func (m *OrganizationMutation) ResetEndUserLimit() {
	m.end_user_limit = nil
	m.addend_user_limit = nil
}

// SetSSOEnabled sets the "sso_enabled" field.
func (m *OrganizationMutation) SetSSOEnabled(b bool) {
	m.sso_enabled = &b
}

// SSOEnabled returns the value of the "sso_enabled" field in the mutation.
func (m *OrganizationMutation) SSOEnabled() (r bool, exists bool) {
	v := m.sso_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOEnabled returns the old "sso_enabled" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSSOEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOEnabled: %w", err)
	}
	return oldValue.SSOEnabled, nil
}

// ResetSSOEnabled resets all changes to the "sso_enabled" field.
func (m *OrganizationMutation) ResetSSOEnabled() {
	m.sso_enabled = nil
}

// SetSSODomain sets the "sso_domain" field.
func (m *OrganizationMutation) SetSSODomain(s string) {
	m.sso_domain = &s
}

// SSODomain returns the value of the "sso_domain" field in the mutation.
func (m *OrganizationMutation) SSODomain() (r string, exists bool) {
	v := m.sso_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldSSODomain returns the old "sso_domain" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSSODomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSODomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSODomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSODomain: %w", err)
	}
	return oldValue.SSODomain, nil
}

// ClearSSODomain clears the value of the "sso_domain" field.
func (m *OrganizationMutation) ClearSSODomain() {
	m.sso_domain = nil
	m.clearedFields[organization.FieldSSODomain] = struct{}{}
}

// SSODomainCleared returns if the "sso_domain" field was cleared in this mutation.
func (m *OrganizationMutation) SSODomainCleared() bool {
	_, ok := m.clearedFields[organization.FieldSSODomain]
	return ok
}

// ResetSSODomain resets all changes to the "sso_domain" field.
func (m *OrganizationMutation) ResetSSODomain() {
	m.sso_domain = nil
	delete(m.clearedFields, organization.FieldSSODomain)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *OrganizationMutation) SetSubscriptionID(s string) {
	m.subscription_id = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *OrganizationMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *OrganizationMutation) ClearSubscriptionID() {
	m.subscription_id = nil
	m.clearedFields[organization.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *OrganizationMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *OrganizationMutation) ResetSubscriptionID() {
	m.subscription_id = nil
	delete(m.clearedFields, organization.FieldSubscriptionID)
}

// SetCustomerID sets the "customer_id" field.
func (m *OrganizationMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *OrganizationMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *OrganizationMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[organization.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *OrganizationMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *OrganizationMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, organization.FieldCustomerID)
}

// SetSubscriptionStatus sets the "subscription_status" field.
func (m *OrganizationMutation) SetSubscriptionStatus(os organization.SubscriptionStatus) {
	m.subscription_status = &os
}

// SubscriptionStatus returns the value of the "subscription_status" field in the mutation.
func (m *OrganizationMutation) SubscriptionStatus() (r organization.SubscriptionStatus, exists bool) {
	v := m.subscription_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionStatus returns the old "subscription_status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSubscriptionStatus(ctx context.Context) (v organization.SubscriptionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionStatus: %w", err)
	}
	return oldValue.SubscriptionStatus, nil
}

// ResetSubscriptionStatus resets all changes to the "subscription_status" field.
func (m *OrganizationMutation) ResetSubscriptionStatus() {
	m.subscription_status = nil
}

// SetAuthServiceEnabled sets the "auth_service_enabled" field.
func (m *OrganizationMutation) SetAuthServiceEnabled(b bool) {
	m.auth_service_enabled = &b
}

// AuthServiceEnabled returns the value of the "auth_service_enabled" field in the mutation.
func (m *OrganizationMutation) AuthServiceEnabled() (r bool, exists bool) {
	v := m.auth_service_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthServiceEnabled returns the old "auth_service_enabled" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAuthServiceEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthServiceEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthServiceEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthServiceEnabled: %w", err)
	}
	return oldValue.AuthServiceEnabled, nil
}

// ResetAuthServiceEnabled resets all changes to the "auth_service_enabled" field.
func (m *OrganizationMutation) ResetAuthServiceEnabled() {
	m.auth_service_enabled = nil
}

// SetAuthConfig sets the "auth_config" field.
func (m *OrganizationMutation) SetAuthConfig(value map[string]interface{}) {
	m.auth_config = &value
}

// AuthConfig returns the value of the "auth_config" field in the mutation.
func (m *OrganizationMutation) AuthConfig() (r map[string]interface{}, exists bool) {
	v := m.auth_config
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthConfig returns the old "auth_config" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAuthConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthConfig: %w", err)
	}
	return oldValue.AuthConfig, nil
}

// ClearAuthConfig clears the value of the "auth_config" field.
func (m *OrganizationMutation) ClearAuthConfig() {
	m.auth_config = nil
	m.clearedFields[organization.FieldAuthConfig] = struct{}{}
}

// AuthConfigCleared returns if the "auth_config" field was cleared in this mutation.
func (m *OrganizationMutation) AuthConfigCleared() bool {
	_, ok := m.clearedFields[organization.FieldAuthConfig]
	return ok
}

// ResetAuthConfig resets all changes to the "auth_config" field.
func (m *OrganizationMutation) ResetAuthConfig() {
	m.auth_config = nil
	delete(m.clearedFields, organization.FieldAuthConfig)
}

// SetAuthDomain sets the "auth_domain" field.
func (m *OrganizationMutation) SetAuthDomain(s string) {
	m.auth_domain = &s
}

// AuthDomain returns the value of the "auth_domain" field in the mutation.
func (m *OrganizationMutation) AuthDomain() (r string, exists bool) {
	v := m.auth_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthDomain returns the old "auth_domain" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAuthDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthDomain: %w", err)
	}
	return oldValue.AuthDomain, nil
}

// ClearAuthDomain clears the value of the "auth_domain" field.
func (m *OrganizationMutation) ClearAuthDomain() {
	m.auth_domain = nil
	m.clearedFields[organization.FieldAuthDomain] = struct{}{}
}

// AuthDomainCleared returns if the "auth_domain" field was cleared in this mutation.
func (m *OrganizationMutation) AuthDomainCleared() bool {
	_, ok := m.clearedFields[organization.FieldAuthDomain]
	return ok
}

// ResetAuthDomain resets all changes to the "auth_domain" field.
func (m *OrganizationMutation) ResetAuthDomain() {
	m.auth_domain = nil
	delete(m.clearedFields, organization.FieldAuthDomain)
}

// SetAPIRequestLimit sets the "api_request_limit" field.
func (m *OrganizationMutation) SetAPIRequestLimit(i int) {
	m.api_request_limit = &i
	m.addapi_request_limit = nil
}

// APIRequestLimit returns the value of the "api_request_limit" field in the mutation.
func (m *OrganizationMutation) APIRequestLimit() (r int, exists bool) {
	v := m.api_request_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIRequestLimit returns the old "api_request_limit" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAPIRequestLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIRequestLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIRequestLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIRequestLimit: %w", err)
	}
	return oldValue.APIRequestLimit, nil
}

// AddAPIRequestLimit adds i to the "api_request_limit" field.
func (m *OrganizationMutation) AddAPIRequestLimit(i int) {
	if m.addapi_request_limit != nil {
		*m.addapi_request_limit += i
	} else {
		m.addapi_request_limit = &i
	}
}

// AddedAPIRequestLimit returns the value that was added to the "api_request_limit" field in this mutation.
func (m *OrganizationMutation) AddedAPIRequestLimit() (r int, exists bool) {
	v := m.addapi_request_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetAPIRequestLimit resets all changes to the "api_request_limit" field.
func (m *OrganizationMutation) ResetAPIRequestLimit() {
	m.api_request_limit = nil
	m.addapi_request_limit = nil
}

// SetAPIRequestsUsed sets the "api_requests_used" field.
func (m *OrganizationMutation) SetAPIRequestsUsed(i int) {
	m.api_requests_used = &i
	m.addapi_requests_used = nil
}

// APIRequestsUsed returns the value of the "api_requests_used" field in the mutation.
func (m *OrganizationMutation) APIRequestsUsed() (r int, exists bool) {
	v := m.api_requests_used
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIRequestsUsed returns the old "api_requests_used" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAPIRequestsUsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIRequestsUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIRequestsUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIRequestsUsed: %w", err)
	}
	return oldValue.APIRequestsUsed, nil
}

// AddAPIRequestsUsed adds i to the "api_requests_used" field.
func (m *OrganizationMutation) AddAPIRequestsUsed(i int) {
	if m.addapi_requests_used != nil {
		*m.addapi_requests_used += i
	} else {
		m.addapi_requests_used = &i
	}
}

// AddedAPIRequestsUsed returns the value that was added to the "api_requests_used" field in this mutation.
func (m *OrganizationMutation) AddedAPIRequestsUsed() (r int, exists bool) {
	v := m.addapi_requests_used
	if v == nil {
		return
	}
	return *v, true
}

// ResetAPIRequestsUsed resets all changes to the "api_requests_used" field.
func (m *OrganizationMutation) ResetAPIRequestsUsed() {
	m.api_requests_used = nil
	m.addapi_requests_used = nil
}

// SetCurrentExternalUsers sets the "current_external_users" field.
func (m *OrganizationMutation) SetCurrentExternalUsers(i int) {
	m.current_external_users = &i
	m.addcurrent_external_users = nil
}

// CurrentExternalUsers returns the value of the "current_external_users" field in the mutation.
func (m *OrganizationMutation) CurrentExternalUsers() (r int, exists bool) {
	v := m.current_external_users
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentExternalUsers returns the old "current_external_users" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCurrentExternalUsers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentExternalUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentExternalUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentExternalUsers: %w", err)
	}
	return oldValue.CurrentExternalUsers, nil
}

// AddCurrentExternalUsers adds i to the "current_external_users" field.
func (m *OrganizationMutation) AddCurrentExternalUsers(i int) {
	if m.addcurrent_external_users != nil {
		*m.addcurrent_external_users += i
	} else {
		m.addcurrent_external_users = &i
	}
}

// AddedCurrentExternalUsers returns the value that was added to the "current_external_users" field in this mutation.
func (m *OrganizationMutation) AddedCurrentExternalUsers() (r int, exists bool) {
	v := m.addcurrent_external_users
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentExternalUsers resets all changes to the "current_external_users" field.
func (m *OrganizationMutation) ResetCurrentExternalUsers() {
	m.current_external_users = nil
	m.addcurrent_external_users = nil
}

// SetCurrentEndUsers sets the "current_end_users" field.
func (m *OrganizationMutation) SetCurrentEndUsers(i int) {
	m.current_end_users = &i
	m.addcurrent_end_users = nil
}

// CurrentEndUsers returns the value of the "current_end_users" field in the mutation.
func (m *OrganizationMutation) CurrentEndUsers() (r int, exists bool) {
	v := m.current_end_users
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentEndUsers returns the old "current_end_users" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCurrentEndUsers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentEndUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentEndUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentEndUsers: %w", err)
	}
	return oldValue.CurrentEndUsers, nil
}

// AddCurrentEndUsers adds i to the "current_end_users" field.
func (m *OrganizationMutation) AddCurrentEndUsers(i int) {
	if m.addcurrent_end_users != nil {
		*m.addcurrent_end_users += i
	} else {
		m.addcurrent_end_users = &i
	}
}

// AddedCurrentEndUsers returns the value that was added to the "current_end_users" field in this mutation.
func (m *OrganizationMutation) AddedCurrentEndUsers() (r int, exists bool) {
	v := m.addcurrent_end_users
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentEndUsers resets all changes to the "current_end_users" field.
func (m *OrganizationMutation) ResetCurrentEndUsers() {
	m.current_end_users = nil
	m.addcurrent_end_users = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...xid.ID) {
	if m.users == nil {
		m.users = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...xid.ID) {
	if m.removedusers == nil {
		m.removedusers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []xid.ID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []xid.ID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddMembershipIDs adds the "memberships" edge to the Membership entity by ids.
func (m *OrganizationMutation) AddMembershipIDs(ids ...xid.ID) {
	if m.memberships == nil {
		m.memberships = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the Membership entity.
func (m *OrganizationMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the Membership entity was cleared.
func (m *OrganizationMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the Membership entity by IDs.
func (m *OrganizationMutation) RemoveMembershipIDs(ids ...xid.ID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the Membership entity.
func (m *OrganizationMutation) RemovedMembershipsIDs() (ids []xid.ID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *OrganizationMutation) MembershipsIDs() (ids []xid.ID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *OrganizationMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddSmsTemplateIDs adds the "sms_templates" edge to the SMSTemplate entity by ids.
func (m *OrganizationMutation) AddSmsTemplateIDs(ids ...xid.ID) {
	if m.sms_templates == nil {
		m.sms_templates = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.sms_templates[ids[i]] = struct{}{}
	}
}

// ClearSmsTemplates clears the "sms_templates" edge to the SMSTemplate entity.
func (m *OrganizationMutation) ClearSmsTemplates() {
	m.clearedsms_templates = true
}

// SmsTemplatesCleared reports if the "sms_templates" edge to the SMSTemplate entity was cleared.
func (m *OrganizationMutation) SmsTemplatesCleared() bool {
	return m.clearedsms_templates
}

// RemoveSmsTemplateIDs removes the "sms_templates" edge to the SMSTemplate entity by IDs.
func (m *OrganizationMutation) RemoveSmsTemplateIDs(ids ...xid.ID) {
	if m.removedsms_templates == nil {
		m.removedsms_templates = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.sms_templates, ids[i])
		m.removedsms_templates[ids[i]] = struct{}{}
	}
}

// RemovedSmsTemplates returns the removed IDs of the "sms_templates" edge to the SMSTemplate entity.
func (m *OrganizationMutation) RemovedSmsTemplatesIDs() (ids []xid.ID) {
	for id := range m.removedsms_templates {
		ids = append(ids, id)
	}
	return
}

// SmsTemplatesIDs returns the "sms_templates" edge IDs in the mutation.
func (m *OrganizationMutation) SmsTemplatesIDs() (ids []xid.ID) {
	for id := range m.sms_templates {
		ids = append(ids, id)
	}
	return
}

// ResetSmsTemplates resets all changes to the "sms_templates" edge.
func (m *OrganizationMutation) ResetSmsTemplates() {
	m.sms_templates = nil
	m.clearedsms_templates = false
	m.removedsms_templates = nil
}

// AddEmailTemplateIDs adds the "email_templates" edge to the EmailTemplate entity by ids.
func (m *OrganizationMutation) AddEmailTemplateIDs(ids ...xid.ID) {
	if m.email_templates == nil {
		m.email_templates = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.email_templates[ids[i]] = struct{}{}
	}
}

// ClearEmailTemplates clears the "email_templates" edge to the EmailTemplate entity.
func (m *OrganizationMutation) ClearEmailTemplates() {
	m.clearedemail_templates = true
}

// EmailTemplatesCleared reports if the "email_templates" edge to the EmailTemplate entity was cleared.
func (m *OrganizationMutation) EmailTemplatesCleared() bool {
	return m.clearedemail_templates
}

// RemoveEmailTemplateIDs removes the "email_templates" edge to the EmailTemplate entity by IDs.
func (m *OrganizationMutation) RemoveEmailTemplateIDs(ids ...xid.ID) {
	if m.removedemail_templates == nil {
		m.removedemail_templates = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.email_templates, ids[i])
		m.removedemail_templates[ids[i]] = struct{}{}
	}
}

// RemovedEmailTemplates returns the removed IDs of the "email_templates" edge to the EmailTemplate entity.
func (m *OrganizationMutation) RemovedEmailTemplatesIDs() (ids []xid.ID) {
	for id := range m.removedemail_templates {
		ids = append(ids, id)
	}
	return
}

// EmailTemplatesIDs returns the "email_templates" edge IDs in the mutation.
func (m *OrganizationMutation) EmailTemplatesIDs() (ids []xid.ID) {
	for id := range m.email_templates {
		ids = append(ids, id)
	}
	return
}

// ResetEmailTemplates resets all changes to the "email_templates" edge.
func (m *OrganizationMutation) ResetEmailTemplates() {
	m.email_templates = nil
	m.clearedemail_templates = false
	m.removedemail_templates = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *OrganizationMutation) AddAPIKeyIDs(ids ...xid.ID) {
	if m.api_keys == nil {
		m.api_keys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *OrganizationMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *OrganizationMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *OrganizationMutation) RemoveAPIKeyIDs(ids ...xid.ID) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *OrganizationMutation) RemovedAPIKeysIDs() (ids []xid.ID) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *OrganizationMutation) APIKeysIDs() (ids []xid.ID) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *OrganizationMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddWebhookIDs adds the "webhooks" edge to the Webhook entity by ids.
func (m *OrganizationMutation) AddWebhookIDs(ids ...xid.ID) {
	if m.webhooks == nil {
		m.webhooks = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.webhooks[ids[i]] = struct{}{}
	}
}

// ClearWebhooks clears the "webhooks" edge to the Webhook entity.
func (m *OrganizationMutation) ClearWebhooks() {
	m.clearedwebhooks = true
}

// WebhooksCleared reports if the "webhooks" edge to the Webhook entity was cleared.
func (m *OrganizationMutation) WebhooksCleared() bool {
	return m.clearedwebhooks
}

// RemoveWebhookIDs removes the "webhooks" edge to the Webhook entity by IDs.
func (m *OrganizationMutation) RemoveWebhookIDs(ids ...xid.ID) {
	if m.removedwebhooks == nil {
		m.removedwebhooks = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.webhooks, ids[i])
		m.removedwebhooks[ids[i]] = struct{}{}
	}
}

// RemovedWebhooks returns the removed IDs of the "webhooks" edge to the Webhook entity.
func (m *OrganizationMutation) RemovedWebhooksIDs() (ids []xid.ID) {
	for id := range m.removedwebhooks {
		ids = append(ids, id)
	}
	return
}

// WebhooksIDs returns the "webhooks" edge IDs in the mutation.
func (m *OrganizationMutation) WebhooksIDs() (ids []xid.ID) {
	for id := range m.webhooks {
		ids = append(ids, id)
	}
	return
}

// ResetWebhooks resets all changes to the "webhooks" edge.
func (m *OrganizationMutation) ResetWebhooks() {
	m.webhooks = nil
	m.clearedwebhooks = false
	m.removedwebhooks = nil
}

// AddFeatureFlagIDs adds the "feature_flags" edge to the OrganizationFeature entity by ids.
func (m *OrganizationMutation) AddFeatureFlagIDs(ids ...xid.ID) {
	if m.feature_flags == nil {
		m.feature_flags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.feature_flags[ids[i]] = struct{}{}
	}
}

// ClearFeatureFlags clears the "feature_flags" edge to the OrganizationFeature entity.
func (m *OrganizationMutation) ClearFeatureFlags() {
	m.clearedfeature_flags = true
}

// FeatureFlagsCleared reports if the "feature_flags" edge to the OrganizationFeature entity was cleared.
func (m *OrganizationMutation) FeatureFlagsCleared() bool {
	return m.clearedfeature_flags
}

// RemoveFeatureFlagIDs removes the "feature_flags" edge to the OrganizationFeature entity by IDs.
func (m *OrganizationMutation) RemoveFeatureFlagIDs(ids ...xid.ID) {
	if m.removedfeature_flags == nil {
		m.removedfeature_flags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.feature_flags, ids[i])
		m.removedfeature_flags[ids[i]] = struct{}{}
	}
}

// RemovedFeatureFlags returns the removed IDs of the "feature_flags" edge to the OrganizationFeature entity.
func (m *OrganizationMutation) RemovedFeatureFlagsIDs() (ids []xid.ID) {
	for id := range m.removedfeature_flags {
		ids = append(ids, id)
	}
	return
}

// FeatureFlagsIDs returns the "feature_flags" edge IDs in the mutation.
func (m *OrganizationMutation) FeatureFlagsIDs() (ids []xid.ID) {
	for id := range m.feature_flags {
		ids = append(ids, id)
	}
	return
}

// ResetFeatureFlags resets all changes to the "feature_flags" edge.
func (m *OrganizationMutation) ResetFeatureFlags() {
	m.feature_flags = nil
	m.clearedfeature_flags = false
	m.removedfeature_flags = nil
}

// AddIdentityProviderIDs adds the "identity_providers" edge to the IdentityProvider entity by ids.
func (m *OrganizationMutation) AddIdentityProviderIDs(ids ...xid.ID) {
	if m.identity_providers == nil {
		m.identity_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.identity_providers[ids[i]] = struct{}{}
	}
}

// ClearIdentityProviders clears the "identity_providers" edge to the IdentityProvider entity.
func (m *OrganizationMutation) ClearIdentityProviders() {
	m.clearedidentity_providers = true
}

// IdentityProvidersCleared reports if the "identity_providers" edge to the IdentityProvider entity was cleared.
func (m *OrganizationMutation) IdentityProvidersCleared() bool {
	return m.clearedidentity_providers
}

// RemoveIdentityProviderIDs removes the "identity_providers" edge to the IdentityProvider entity by IDs.
func (m *OrganizationMutation) RemoveIdentityProviderIDs(ids ...xid.ID) {
	if m.removedidentity_providers == nil {
		m.removedidentity_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.identity_providers, ids[i])
		m.removedidentity_providers[ids[i]] = struct{}{}
	}
}

// RemovedIdentityProviders returns the removed IDs of the "identity_providers" edge to the IdentityProvider entity.
func (m *OrganizationMutation) RemovedIdentityProvidersIDs() (ids []xid.ID) {
	for id := range m.removedidentity_providers {
		ids = append(ids, id)
	}
	return
}

// IdentityProvidersIDs returns the "identity_providers" edge IDs in the mutation.
func (m *OrganizationMutation) IdentityProvidersIDs() (ids []xid.ID) {
	for id := range m.identity_providers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentityProviders resets all changes to the "identity_providers" edge.
func (m *OrganizationMutation) ResetIdentityProviders() {
	m.identity_providers = nil
	m.clearedidentity_providers = false
	m.removedidentity_providers = nil
}

// AddOauthClientIDs adds the "oauth_clients" edge to the OAuthClient entity by ids.
func (m *OrganizationMutation) AddOauthClientIDs(ids ...xid.ID) {
	if m.oauth_clients == nil {
		m.oauth_clients = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.oauth_clients[ids[i]] = struct{}{}
	}
}

// ClearOauthClients clears the "oauth_clients" edge to the OAuthClient entity.
func (m *OrganizationMutation) ClearOauthClients() {
	m.clearedoauth_clients = true
}

// OauthClientsCleared reports if the "oauth_clients" edge to the OAuthClient entity was cleared.
func (m *OrganizationMutation) OauthClientsCleared() bool {
	return m.clearedoauth_clients
}

// RemoveOauthClientIDs removes the "oauth_clients" edge to the OAuthClient entity by IDs.
func (m *OrganizationMutation) RemoveOauthClientIDs(ids ...xid.ID) {
	if m.removedoauth_clients == nil {
		m.removedoauth_clients = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.oauth_clients, ids[i])
		m.removedoauth_clients[ids[i]] = struct{}{}
	}
}

// RemovedOauthClients returns the removed IDs of the "oauth_clients" edge to the OAuthClient entity.
func (m *OrganizationMutation) RemovedOauthClientsIDs() (ids []xid.ID) {
	for id := range m.removedoauth_clients {
		ids = append(ids, id)
	}
	return
}

// OauthClientsIDs returns the "oauth_clients" edge IDs in the mutation.
func (m *OrganizationMutation) OauthClientsIDs() (ids []xid.ID) {
	for id := range m.oauth_clients {
		ids = append(ids, id)
	}
	return
}

// ResetOauthClients resets all changes to the "oauth_clients" edge.
func (m *OrganizationMutation) ResetOauthClients() {
	m.oauth_clients = nil
	m.clearedoauth_clients = false
	m.removedoauth_clients = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *OrganizationMutation) AddRoleIDs(ids ...xid.ID) {
	if m.roles == nil {
		m.roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *OrganizationMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *OrganizationMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *OrganizationMutation) RemoveRoleIDs(ids ...xid.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *OrganizationMutation) RemovedRolesIDs() (ids []xid.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *OrganizationMutation) RolesIDs() (ids []xid.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *OrganizationMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUserRoleContextIDs adds the "user_role_contexts" edge to the UserRole entity by ids.
func (m *OrganizationMutation) AddUserRoleContextIDs(ids ...xid.ID) {
	if m.user_role_contexts == nil {
		m.user_role_contexts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.user_role_contexts[ids[i]] = struct{}{}
	}
}

// ClearUserRoleContexts clears the "user_role_contexts" edge to the UserRole entity.
func (m *OrganizationMutation) ClearUserRoleContexts() {
	m.cleareduser_role_contexts = true
}

// UserRoleContextsCleared reports if the "user_role_contexts" edge to the UserRole entity was cleared.
func (m *OrganizationMutation) UserRoleContextsCleared() bool {
	return m.cleareduser_role_contexts
}

// RemoveUserRoleContextIDs removes the "user_role_contexts" edge to the UserRole entity by IDs.
func (m *OrganizationMutation) RemoveUserRoleContextIDs(ids ...xid.ID) {
	if m.removeduser_role_contexts == nil {
		m.removeduser_role_contexts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.user_role_contexts, ids[i])
		m.removeduser_role_contexts[ids[i]] = struct{}{}
	}
}

// RemovedUserRoleContexts returns the removed IDs of the "user_role_contexts" edge to the UserRole entity.
func (m *OrganizationMutation) RemovedUserRoleContextsIDs() (ids []xid.ID) {
	for id := range m.removeduser_role_contexts {
		ids = append(ids, id)
	}
	return
}

// UserRoleContextsIDs returns the "user_role_contexts" edge IDs in the mutation.
func (m *OrganizationMutation) UserRoleContextsIDs() (ids []xid.ID) {
	for id := range m.user_role_contexts {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoleContexts resets all changes to the "user_role_contexts" edge.
func (m *OrganizationMutation) ResetUserRoleContexts() {
	m.user_role_contexts = nil
	m.cleareduser_role_contexts = false
	m.removeduser_role_contexts = nil
}

// AddUserPermissionContextIDs adds the "user_permission_contexts" edge to the UserPermission entity by ids.
func (m *OrganizationMutation) AddUserPermissionContextIDs(ids ...xid.ID) {
	if m.user_permission_contexts == nil {
		m.user_permission_contexts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.user_permission_contexts[ids[i]] = struct{}{}
	}
}

// ClearUserPermissionContexts clears the "user_permission_contexts" edge to the UserPermission entity.
func (m *OrganizationMutation) ClearUserPermissionContexts() {
	m.cleareduser_permission_contexts = true
}

// UserPermissionContextsCleared reports if the "user_permission_contexts" edge to the UserPermission entity was cleared.
func (m *OrganizationMutation) UserPermissionContextsCleared() bool {
	return m.cleareduser_permission_contexts
}

// RemoveUserPermissionContextIDs removes the "user_permission_contexts" edge to the UserPermission entity by IDs.
func (m *OrganizationMutation) RemoveUserPermissionContextIDs(ids ...xid.ID) {
	if m.removeduser_permission_contexts == nil {
		m.removeduser_permission_contexts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.user_permission_contexts, ids[i])
		m.removeduser_permission_contexts[ids[i]] = struct{}{}
	}
}

// RemovedUserPermissionContexts returns the removed IDs of the "user_permission_contexts" edge to the UserPermission entity.
func (m *OrganizationMutation) RemovedUserPermissionContextsIDs() (ids []xid.ID) {
	for id := range m.removeduser_permission_contexts {
		ids = append(ids, id)
	}
	return
}

// UserPermissionContextsIDs returns the "user_permission_contexts" edge IDs in the mutation.
func (m *OrganizationMutation) UserPermissionContextsIDs() (ids []xid.ID) {
	for id := range m.user_permission_contexts {
		ids = append(ids, id)
	}
	return
}

// ResetUserPermissionContexts resets all changes to the "user_permission_contexts" edge.
func (m *OrganizationMutation) ResetUserPermissionContexts() {
	m.user_permission_contexts = nil
	m.cleareduser_permission_contexts = false
	m.removeduser_permission_contexts = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the Audit entity by ids.
func (m *OrganizationMutation) AddAuditLogIDs(ids ...xid.ID) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the Audit entity.
func (m *OrganizationMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the Audit entity was cleared.
func (m *OrganizationMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the Audit entity by IDs.
func (m *OrganizationMutation) RemoveAuditLogIDs(ids ...xid.ID) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the Audit entity.
func (m *OrganizationMutation) RemovedAuditLogsIDs() (ids []xid.ID) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *OrganizationMutation) AuditLogsIDs() (ids []xid.ID) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *OrganizationMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddOrganizationProviderIDs adds the "organization_providers" edge to the OrganizationProvider entity by ids.
func (m *OrganizationMutation) AddOrganizationProviderIDs(ids ...xid.ID) {
	if m.organization_providers == nil {
		m.organization_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.organization_providers[ids[i]] = struct{}{}
	}
}

// ClearOrganizationProviders clears the "organization_providers" edge to the OrganizationProvider entity.
func (m *OrganizationMutation) ClearOrganizationProviders() {
	m.clearedorganization_providers = true
}

// OrganizationProvidersCleared reports if the "organization_providers" edge to the OrganizationProvider entity was cleared.
func (m *OrganizationMutation) OrganizationProvidersCleared() bool {
	return m.clearedorganization_providers
}

// RemoveOrganizationProviderIDs removes the "organization_providers" edge to the OrganizationProvider entity by IDs.
func (m *OrganizationMutation) RemoveOrganizationProviderIDs(ids ...xid.ID) {
	if m.removedorganization_providers == nil {
		m.removedorganization_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.organization_providers, ids[i])
		m.removedorganization_providers[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationProviders returns the removed IDs of the "organization_providers" edge to the OrganizationProvider entity.
func (m *OrganizationMutation) RemovedOrganizationProvidersIDs() (ids []xid.ID) {
	for id := range m.removedorganization_providers {
		ids = append(ids, id)
	}
	return
}

// OrganizationProvidersIDs returns the "organization_providers" edge IDs in the mutation.
func (m *OrganizationMutation) OrganizationProvidersIDs() (ids []xid.ID) {
	for id := range m.organization_providers {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationProviders resets all changes to the "organization_providers" edge.
func (m *OrganizationMutation) ResetOrganizationProviders() {
	m.organization_providers = nil
	m.clearedorganization_providers = false
	m.removedorganization_providers = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *OrganizationMutation) AddActivityIDs(ids ...xid.ID) {
	if m.activities == nil {
		m.activities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *OrganizationMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *OrganizationMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *OrganizationMutation) RemoveActivityIDs(ids ...xid.ID) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *OrganizationMutation) RemovedActivitiesIDs() (ids []xid.ID) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *OrganizationMutation) ActivitiesIDs() (ids []xid.ID) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *OrganizationMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, organization.FieldSlug)
	}
	if m.domains != nil {
		fields = append(fields, organization.FieldDomains)
	}
	if m.verified_domains != nil {
		fields = append(fields, organization.FieldVerifiedDomains)
	}
	if m.domain != nil {
		fields = append(fields, organization.FieldDomain)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.plan != nil {
		fields = append(fields, organization.FieldPlan)
	}
	if m.active != nil {
		fields = append(fields, organization.FieldActive)
	}
	if m.metadata != nil {
		fields = append(fields, organization.FieldMetadata)
	}
	if m.trial_ends_at != nil {
		fields = append(fields, organization.FieldTrialEndsAt)
	}
	if m.trial_used != nil {
		fields = append(fields, organization.FieldTrialUsed)
	}
	if m.owner_id != nil {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.org_type != nil {
		fields = append(fields, organization.FieldOrgType)
	}
	if m.is_platform_organization != nil {
		fields = append(fields, organization.FieldIsPlatformOrganization)
	}
	if m.external_user_limit != nil {
		fields = append(fields, organization.FieldExternalUserLimit)
	}
	if m.end_user_limit != nil {
		fields = append(fields, organization.FieldEndUserLimit)
	}
	if m.sso_enabled != nil {
		fields = append(fields, organization.FieldSSOEnabled)
	}
	if m.sso_domain != nil {
		fields = append(fields, organization.FieldSSODomain)
	}
	if m.subscription_id != nil {
		fields = append(fields, organization.FieldSubscriptionID)
	}
	if m.customer_id != nil {
		fields = append(fields, organization.FieldCustomerID)
	}
	if m.subscription_status != nil {
		fields = append(fields, organization.FieldSubscriptionStatus)
	}
	if m.auth_service_enabled != nil {
		fields = append(fields, organization.FieldAuthServiceEnabled)
	}
	if m.auth_config != nil {
		fields = append(fields, organization.FieldAuthConfig)
	}
	if m.auth_domain != nil {
		fields = append(fields, organization.FieldAuthDomain)
	}
	if m.api_request_limit != nil {
		fields = append(fields, organization.FieldAPIRequestLimit)
	}
	if m.api_requests_used != nil {
		fields = append(fields, organization.FieldAPIRequestsUsed)
	}
	if m.current_external_users != nil {
		fields = append(fields, organization.FieldCurrentExternalUsers)
	}
	if m.current_end_users != nil {
		fields = append(fields, organization.FieldCurrentEndUsers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldDeletedAt:
		return m.DeletedAt()
	case organization.FieldName:
		return m.Name()
	case organization.FieldSlug:
		return m.Slug()
	case organization.FieldDomains:
		return m.Domains()
	case organization.FieldVerifiedDomains:
		return m.VerifiedDomains()
	case organization.FieldDomain:
		return m.Domain()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldPlan:
		return m.Plan()
	case organization.FieldActive:
		return m.Active()
	case organization.FieldMetadata:
		return m.Metadata()
	case organization.FieldTrialEndsAt:
		return m.TrialEndsAt()
	case organization.FieldTrialUsed:
		return m.TrialUsed()
	case organization.FieldOwnerID:
		return m.OwnerID()
	case organization.FieldOrgType:
		return m.OrgType()
	case organization.FieldIsPlatformOrganization:
		return m.IsPlatformOrganization()
	case organization.FieldExternalUserLimit:
		return m.ExternalUserLimit()
	case organization.FieldEndUserLimit:
		return m.EndUserLimit()
	case organization.FieldSSOEnabled:
		return m.SSOEnabled()
	case organization.FieldSSODomain:
		return m.SSODomain()
	case organization.FieldSubscriptionID:
		return m.SubscriptionID()
	case organization.FieldCustomerID:
		return m.CustomerID()
	case organization.FieldSubscriptionStatus:
		return m.SubscriptionStatus()
	case organization.FieldAuthServiceEnabled:
		return m.AuthServiceEnabled()
	case organization.FieldAuthConfig:
		return m.AuthConfig()
	case organization.FieldAuthDomain:
		return m.AuthDomain()
	case organization.FieldAPIRequestLimit:
		return m.APIRequestLimit()
	case organization.FieldAPIRequestsUsed:
		return m.APIRequestsUsed()
	case organization.FieldCurrentExternalUsers:
		return m.CurrentExternalUsers()
	case organization.FieldCurrentEndUsers:
		return m.CurrentEndUsers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldSlug:
		return m.OldSlug(ctx)
	case organization.FieldDomains:
		return m.OldDomains(ctx)
	case organization.FieldVerifiedDomains:
		return m.OldVerifiedDomains(ctx)
	case organization.FieldDomain:
		return m.OldDomain(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldPlan:
		return m.OldPlan(ctx)
	case organization.FieldActive:
		return m.OldActive(ctx)
	case organization.FieldMetadata:
		return m.OldMetadata(ctx)
	case organization.FieldTrialEndsAt:
		return m.OldTrialEndsAt(ctx)
	case organization.FieldTrialUsed:
		return m.OldTrialUsed(ctx)
	case organization.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case organization.FieldOrgType:
		return m.OldOrgType(ctx)
	case organization.FieldIsPlatformOrganization:
		return m.OldIsPlatformOrganization(ctx)
	case organization.FieldExternalUserLimit:
		return m.OldExternalUserLimit(ctx)
	case organization.FieldEndUserLimit:
		return m.OldEndUserLimit(ctx)
	case organization.FieldSSOEnabled:
		return m.OldSSOEnabled(ctx)
	case organization.FieldSSODomain:
		return m.OldSSODomain(ctx)
	case organization.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case organization.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case organization.FieldSubscriptionStatus:
		return m.OldSubscriptionStatus(ctx)
	case organization.FieldAuthServiceEnabled:
		return m.OldAuthServiceEnabled(ctx)
	case organization.FieldAuthConfig:
		return m.OldAuthConfig(ctx)
	case organization.FieldAuthDomain:
		return m.OldAuthDomain(ctx)
	case organization.FieldAPIRequestLimit:
		return m.OldAPIRequestLimit(ctx)
	case organization.FieldAPIRequestsUsed:
		return m.OldAPIRequestsUsed(ctx)
	case organization.FieldCurrentExternalUsers:
		return m.OldCurrentExternalUsers(ctx)
	case organization.FieldCurrentEndUsers:
		return m.OldCurrentEndUsers(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case organization.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case organization.FieldVerifiedDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedDomains(v)
		return nil
	case organization.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlan(v)
		return nil
	case organization.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case organization.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case organization.FieldTrialEndsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialEndsAt(v)
		return nil
	case organization.FieldTrialUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialUsed(v)
		return nil
	case organization.FieldOwnerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case organization.FieldOrgType:
		v, ok := value.(model.OrgType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgType(v)
		return nil
	case organization.FieldIsPlatformOrganization:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPlatformOrganization(v)
		return nil
	case organization.FieldExternalUserLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalUserLimit(v)
		return nil
	case organization.FieldEndUserLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndUserLimit(v)
		return nil
	case organization.FieldSSOEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOEnabled(v)
		return nil
	case organization.FieldSSODomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSODomain(v)
		return nil
	case organization.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case organization.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case organization.FieldSubscriptionStatus:
		v, ok := value.(organization.SubscriptionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionStatus(v)
		return nil
	case organization.FieldAuthServiceEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthServiceEnabled(v)
		return nil
	case organization.FieldAuthConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthConfig(v)
		return nil
	case organization.FieldAuthDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthDomain(v)
		return nil
	case organization.FieldAPIRequestLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIRequestLimit(v)
		return nil
	case organization.FieldAPIRequestsUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIRequestsUsed(v)
		return nil
	case organization.FieldCurrentExternalUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentExternalUsers(v)
		return nil
	case organization.FieldCurrentEndUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentEndUsers(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addexternal_user_limit != nil {
		fields = append(fields, organization.FieldExternalUserLimit)
	}
	if m.addend_user_limit != nil {
		fields = append(fields, organization.FieldEndUserLimit)
	}
	if m.addapi_request_limit != nil {
		fields = append(fields, organization.FieldAPIRequestLimit)
	}
	if m.addapi_requests_used != nil {
		fields = append(fields, organization.FieldAPIRequestsUsed)
	}
	if m.addcurrent_external_users != nil {
		fields = append(fields, organization.FieldCurrentExternalUsers)
	}
	if m.addcurrent_end_users != nil {
		fields = append(fields, organization.FieldCurrentEndUsers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldExternalUserLimit:
		return m.AddedExternalUserLimit()
	case organization.FieldEndUserLimit:
		return m.AddedEndUserLimit()
	case organization.FieldAPIRequestLimit:
		return m.AddedAPIRequestLimit()
	case organization.FieldAPIRequestsUsed:
		return m.AddedAPIRequestsUsed()
	case organization.FieldCurrentExternalUsers:
		return m.AddedCurrentExternalUsers()
	case organization.FieldCurrentEndUsers:
		return m.AddedCurrentEndUsers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldExternalUserLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExternalUserLimit(v)
		return nil
	case organization.FieldEndUserLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndUserLimit(v)
		return nil
	case organization.FieldAPIRequestLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAPIRequestLimit(v)
		return nil
	case organization.FieldAPIRequestsUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAPIRequestsUsed(v)
		return nil
	case organization.FieldCurrentExternalUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentExternalUsers(v)
		return nil
	case organization.FieldCurrentEndUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentEndUsers(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldDeletedAt) {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.FieldCleared(organization.FieldDomains) {
		fields = append(fields, organization.FieldDomains)
	}
	if m.FieldCleared(organization.FieldVerifiedDomains) {
		fields = append(fields, organization.FieldVerifiedDomains)
	}
	if m.FieldCleared(organization.FieldDomain) {
		fields = append(fields, organization.FieldDomain)
	}
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.FieldCleared(organization.FieldMetadata) {
		fields = append(fields, organization.FieldMetadata)
	}
	if m.FieldCleared(organization.FieldTrialEndsAt) {
		fields = append(fields, organization.FieldTrialEndsAt)
	}
	if m.FieldCleared(organization.FieldOwnerID) {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.FieldCleared(organization.FieldSSODomain) {
		fields = append(fields, organization.FieldSSODomain)
	}
	if m.FieldCleared(organization.FieldSubscriptionID) {
		fields = append(fields, organization.FieldSubscriptionID)
	}
	if m.FieldCleared(organization.FieldCustomerID) {
		fields = append(fields, organization.FieldCustomerID)
	}
	if m.FieldCleared(organization.FieldAuthConfig) {
		fields = append(fields, organization.FieldAuthConfig)
	}
	if m.FieldCleared(organization.FieldAuthDomain) {
		fields = append(fields, organization.FieldAuthDomain)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organization.FieldDomains:
		m.ClearDomains()
		return nil
	case organization.FieldVerifiedDomains:
		m.ClearVerifiedDomains()
		return nil
	case organization.FieldDomain:
		m.ClearDomain()
		return nil
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case organization.FieldMetadata:
		m.ClearMetadata()
		return nil
	case organization.FieldTrialEndsAt:
		m.ClearTrialEndsAt()
		return nil
	case organization.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case organization.FieldSSODomain:
		m.ClearSSODomain()
		return nil
	case organization.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case organization.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case organization.FieldAuthConfig:
		m.ClearAuthConfig()
		return nil
	case organization.FieldAuthDomain:
		m.ClearAuthDomain()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldSlug:
		m.ResetSlug()
		return nil
	case organization.FieldDomains:
		m.ResetDomains()
		return nil
	case organization.FieldVerifiedDomains:
		m.ResetVerifiedDomains()
		return nil
	case organization.FieldDomain:
		m.ResetDomain()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldPlan:
		m.ResetPlan()
		return nil
	case organization.FieldActive:
		m.ResetActive()
		return nil
	case organization.FieldMetadata:
		m.ResetMetadata()
		return nil
	case organization.FieldTrialEndsAt:
		m.ResetTrialEndsAt()
		return nil
	case organization.FieldTrialUsed:
		m.ResetTrialUsed()
		return nil
	case organization.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case organization.FieldOrgType:
		m.ResetOrgType()
		return nil
	case organization.FieldIsPlatformOrganization:
		m.ResetIsPlatformOrganization()
		return nil
	case organization.FieldExternalUserLimit:
		m.ResetExternalUserLimit()
		return nil
	case organization.FieldEndUserLimit:
		m.ResetEndUserLimit()
		return nil
	case organization.FieldSSOEnabled:
		m.ResetSSOEnabled()
		return nil
	case organization.FieldSSODomain:
		m.ResetSSODomain()
		return nil
	case organization.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case organization.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case organization.FieldSubscriptionStatus:
		m.ResetSubscriptionStatus()
		return nil
	case organization.FieldAuthServiceEnabled:
		m.ResetAuthServiceEnabled()
		return nil
	case organization.FieldAuthConfig:
		m.ResetAuthConfig()
		return nil
	case organization.FieldAuthDomain:
		m.ResetAuthDomain()
		return nil
	case organization.FieldAPIRequestLimit:
		m.ResetAPIRequestLimit()
		return nil
	case organization.FieldAPIRequestsUsed:
		m.ResetAPIRequestsUsed()
		return nil
	case organization.FieldCurrentExternalUsers:
		m.ResetCurrentExternalUsers()
		return nil
	case organization.FieldCurrentEndUsers:
		m.ResetCurrentEndUsers()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.memberships != nil {
		edges = append(edges, organization.EdgeMemberships)
	}
	if m.sms_templates != nil {
		edges = append(edges, organization.EdgeSmsTemplates)
	}
	if m.email_templates != nil {
		edges = append(edges, organization.EdgeEmailTemplates)
	}
	if m.api_keys != nil {
		edges = append(edges, organization.EdgeAPIKeys)
	}
	if m.webhooks != nil {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.feature_flags != nil {
		edges = append(edges, organization.EdgeFeatureFlags)
	}
	if m.identity_providers != nil {
		edges = append(edges, organization.EdgeIdentityProviders)
	}
	if m.oauth_clients != nil {
		edges = append(edges, organization.EdgeOauthClients)
	}
	if m.roles != nil {
		edges = append(edges, organization.EdgeRoles)
	}
	if m.user_role_contexts != nil {
		edges = append(edges, organization.EdgeUserRoleContexts)
	}
	if m.user_permission_contexts != nil {
		edges = append(edges, organization.EdgeUserPermissionContexts)
	}
	if m.audit_logs != nil {
		edges = append(edges, organization.EdgeAuditLogs)
	}
	if m.organization_providers != nil {
		edges = append(edges, organization.EdgeOrganizationProviders)
	}
	if m.activities != nil {
		edges = append(edges, organization.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSmsTemplates:
		ids := make([]ent.Value, 0, len(m.sms_templates))
		for id := range m.sms_templates {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEmailTemplates:
		ids := make([]ent.Value, 0, len(m.email_templates))
		for id := range m.email_templates {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.webhooks))
		for id := range m.webhooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFeatureFlags:
		ids := make([]ent.Value, 0, len(m.feature_flags))
		for id := range m.feature_flags {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIdentityProviders:
		ids := make([]ent.Value, 0, len(m.identity_providers))
		for id := range m.identity_providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOauthClients:
		ids := make([]ent.Value, 0, len(m.oauth_clients))
		for id := range m.oauth_clients {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUserRoleContexts:
		ids := make([]ent.Value, 0, len(m.user_role_contexts))
		for id := range m.user_role_contexts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUserPermissionContexts:
		ids := make([]ent.Value, 0, len(m.user_permission_contexts))
		for id := range m.user_permission_contexts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationProviders:
		ids := make([]ent.Value, 0, len(m.organization_providers))
		for id := range m.organization_providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedmemberships != nil {
		edges = append(edges, organization.EdgeMemberships)
	}
	if m.removedsms_templates != nil {
		edges = append(edges, organization.EdgeSmsTemplates)
	}
	if m.removedemail_templates != nil {
		edges = append(edges, organization.EdgeEmailTemplates)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, organization.EdgeAPIKeys)
	}
	if m.removedwebhooks != nil {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.removedfeature_flags != nil {
		edges = append(edges, organization.EdgeFeatureFlags)
	}
	if m.removedidentity_providers != nil {
		edges = append(edges, organization.EdgeIdentityProviders)
	}
	if m.removedoauth_clients != nil {
		edges = append(edges, organization.EdgeOauthClients)
	}
	if m.removedroles != nil {
		edges = append(edges, organization.EdgeRoles)
	}
	if m.removeduser_role_contexts != nil {
		edges = append(edges, organization.EdgeUserRoleContexts)
	}
	if m.removeduser_permission_contexts != nil {
		edges = append(edges, organization.EdgeUserPermissionContexts)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, organization.EdgeAuditLogs)
	}
	if m.removedorganization_providers != nil {
		edges = append(edges, organization.EdgeOrganizationProviders)
	}
	if m.removedactivities != nil {
		edges = append(edges, organization.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSmsTemplates:
		ids := make([]ent.Value, 0, len(m.removedsms_templates))
		for id := range m.removedsms_templates {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEmailTemplates:
		ids := make([]ent.Value, 0, len(m.removedemail_templates))
		for id := range m.removedemail_templates {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.removedwebhooks))
		for id := range m.removedwebhooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFeatureFlags:
		ids := make([]ent.Value, 0, len(m.removedfeature_flags))
		for id := range m.removedfeature_flags {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIdentityProviders:
		ids := make([]ent.Value, 0, len(m.removedidentity_providers))
		for id := range m.removedidentity_providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOauthClients:
		ids := make([]ent.Value, 0, len(m.removedoauth_clients))
		for id := range m.removedoauth_clients {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUserRoleContexts:
		ids := make([]ent.Value, 0, len(m.removeduser_role_contexts))
		for id := range m.removeduser_role_contexts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUserPermissionContexts:
		ids := make([]ent.Value, 0, len(m.removeduser_permission_contexts))
		for id := range m.removeduser_permission_contexts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationProviders:
		ids := make([]ent.Value, 0, len(m.removedorganization_providers))
		for id := range m.removedorganization_providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedmemberships {
		edges = append(edges, organization.EdgeMemberships)
	}
	if m.clearedsms_templates {
		edges = append(edges, organization.EdgeSmsTemplates)
	}
	if m.clearedemail_templates {
		edges = append(edges, organization.EdgeEmailTemplates)
	}
	if m.clearedapi_keys {
		edges = append(edges, organization.EdgeAPIKeys)
	}
	if m.clearedwebhooks {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.clearedfeature_flags {
		edges = append(edges, organization.EdgeFeatureFlags)
	}
	if m.clearedidentity_providers {
		edges = append(edges, organization.EdgeIdentityProviders)
	}
	if m.clearedoauth_clients {
		edges = append(edges, organization.EdgeOauthClients)
	}
	if m.clearedroles {
		edges = append(edges, organization.EdgeRoles)
	}
	if m.cleareduser_role_contexts {
		edges = append(edges, organization.EdgeUserRoleContexts)
	}
	if m.cleareduser_permission_contexts {
		edges = append(edges, organization.EdgeUserPermissionContexts)
	}
	if m.clearedaudit_logs {
		edges = append(edges, organization.EdgeAuditLogs)
	}
	if m.clearedorganization_providers {
		edges = append(edges, organization.EdgeOrganizationProviders)
	}
	if m.clearedactivities {
		edges = append(edges, organization.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeMemberships:
		return m.clearedmemberships
	case organization.EdgeSmsTemplates:
		return m.clearedsms_templates
	case organization.EdgeEmailTemplates:
		return m.clearedemail_templates
	case organization.EdgeAPIKeys:
		return m.clearedapi_keys
	case organization.EdgeWebhooks:
		return m.clearedwebhooks
	case organization.EdgeFeatureFlags:
		return m.clearedfeature_flags
	case organization.EdgeIdentityProviders:
		return m.clearedidentity_providers
	case organization.EdgeOauthClients:
		return m.clearedoauth_clients
	case organization.EdgeRoles:
		return m.clearedroles
	case organization.EdgeUserRoleContexts:
		return m.cleareduser_role_contexts
	case organization.EdgeUserPermissionContexts:
		return m.cleareduser_permission_contexts
	case organization.EdgeAuditLogs:
		return m.clearedaudit_logs
	case organization.EdgeOrganizationProviders:
		return m.clearedorganization_providers
	case organization.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case organization.EdgeSmsTemplates:
		m.ResetSmsTemplates()
		return nil
	case organization.EdgeEmailTemplates:
		m.ResetEmailTemplates()
		return nil
	case organization.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case organization.EdgeWebhooks:
		m.ResetWebhooks()
		return nil
	case organization.EdgeFeatureFlags:
		m.ResetFeatureFlags()
		return nil
	case organization.EdgeIdentityProviders:
		m.ResetIdentityProviders()
		return nil
	case organization.EdgeOauthClients:
		m.ResetOauthClients()
		return nil
	case organization.EdgeRoles:
		m.ResetRoles()
		return nil
	case organization.EdgeUserRoleContexts:
		m.ResetUserRoleContexts()
		return nil
	case organization.EdgeUserPermissionContexts:
		m.ResetUserPermissionContexts()
		return nil
	case organization.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case organization.EdgeOrganizationProviders:
		m.ResetOrganizationProviders()
		return nil
	case organization.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationFeatureMutation represents an operation that mutates the OrganizationFeature nodes in the graph.
type OrganizationFeatureMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	enabled             *bool
	settings            *map[string]interface{}
	clearedFields       map[string]struct{}
	organization        *xid.ID
	clearedorganization bool
	feature             *xid.ID
	clearedfeature      bool
	done                bool
	oldValue            func(context.Context) (*OrganizationFeature, error)
	predicates          []predicate.OrganizationFeature
}

var _ ent.Mutation = (*OrganizationFeatureMutation)(nil)

// organizationfeatureOption allows management of the mutation configuration using functional options.
type organizationfeatureOption func(*OrganizationFeatureMutation)

// newOrganizationFeatureMutation creates new mutation for the OrganizationFeature entity.
func newOrganizationFeatureMutation(c config, op Op, opts ...organizationfeatureOption) *OrganizationFeatureMutation {
	m := &OrganizationFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationFeatureID sets the ID field of the mutation.
func withOrganizationFeatureID(id xid.ID) organizationfeatureOption {
	return func(m *OrganizationFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationFeature
		)
		m.oldValue = func(ctx context.Context) (*OrganizationFeature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationFeature sets the old OrganizationFeature of the mutation.
func withOrganizationFeature(node *OrganizationFeature) organizationfeatureOption {
	return func(m *OrganizationFeatureMutation) {
		m.oldValue = func(context.Context) (*OrganizationFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationFeature entities.
func (m *OrganizationFeatureMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationFeatureMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationFeatureMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationFeature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationFeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationFeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationFeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationFeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationFeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationFeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationFeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationFeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationFeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationfeature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationFeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationfeature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationFeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationfeature.FieldDeletedAt)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationFeatureMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationFeatureMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationFeatureMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *OrganizationFeatureMutation) SetFeatureID(x xid.ID) {
	m.feature = &x
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *OrganizationFeatureMutation) FeatureID() (r xid.ID, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldFeatureID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *OrganizationFeatureMutation) ResetFeatureID() {
	m.feature = nil
}

// SetEnabled sets the "enabled" field.
func (m *OrganizationFeatureMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *OrganizationFeatureMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *OrganizationFeatureMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSettings sets the "settings" field.
func (m *OrganizationFeatureMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *OrganizationFeatureMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *OrganizationFeatureMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[organizationfeature.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *OrganizationFeatureMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[organizationfeature.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *OrganizationFeatureMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, organizationfeature.FieldSettings)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationFeatureMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationfeature.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationFeatureMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationFeatureMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationFeatureMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearFeature clears the "feature" edge to the FeatureFlag entity.
func (m *OrganizationFeatureMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[organizationfeature.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the FeatureFlag entity was cleared.
func (m *OrganizationFeatureMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *OrganizationFeatureMutation) FeatureIDs() (ids []xid.ID) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *OrganizationFeatureMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the OrganizationFeatureMutation builder.
func (m *OrganizationFeatureMutation) Where(ps ...predicate.OrganizationFeature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationFeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationFeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationFeature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationFeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationFeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationFeature).
func (m *OrganizationFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationFeatureMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, organizationfeature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationfeature.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationfeature.FieldDeletedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationfeature.FieldOrganizationID)
	}
	if m.feature != nil {
		fields = append(fields, organizationfeature.FieldFeatureID)
	}
	if m.enabled != nil {
		fields = append(fields, organizationfeature.FieldEnabled)
	}
	if m.settings != nil {
		fields = append(fields, organizationfeature.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationFeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationfeature.FieldCreatedAt:
		return m.CreatedAt()
	case organizationfeature.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationfeature.FieldDeletedAt:
		return m.DeletedAt()
	case organizationfeature.FieldOrganizationID:
		return m.OrganizationID()
	case organizationfeature.FieldFeatureID:
		return m.FeatureID()
	case organizationfeature.FieldEnabled:
		return m.Enabled()
	case organizationfeature.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationfeature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationfeature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationfeature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationfeature.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationfeature.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case organizationfeature.FieldEnabled:
		return m.OldEnabled(ctx)
	case organizationfeature.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationfeature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationfeature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationfeature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationfeature.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationfeature.FieldFeatureID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case organizationfeature.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case organizationfeature.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationFeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationFeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationFeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationFeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationfeature.FieldDeletedAt) {
		fields = append(fields, organizationfeature.FieldDeletedAt)
	}
	if m.FieldCleared(organizationfeature.FieldSettings) {
		fields = append(fields, organizationfeature.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationFeatureMutation) ClearField(name string) error {
	switch name {
	case organizationfeature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationfeature.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationFeatureMutation) ResetField(name string) error {
	switch name {
	case organizationfeature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationfeature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationfeature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationfeature.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationfeature.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case organizationfeature.FieldEnabled:
		m.ResetEnabled()
		return nil
	case organizationfeature.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationfeature.EdgeOrganization)
	}
	if m.feature != nil {
		edges = append(edges, organizationfeature.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationfeature.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationfeature.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationFeatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationfeature.EdgeOrganization)
	}
	if m.clearedfeature {
		edges = append(edges, organizationfeature.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationfeature.EdgeOrganization:
		return m.clearedorganization
	case organizationfeature.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationFeatureMutation) ClearEdge(name string) error {
	switch name {
	case organizationfeature.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationfeature.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationFeatureMutation) ResetEdge(name string) error {
	switch name {
	case organizationfeature.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationfeature.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature edge %s", name)
}

// OrganizationProviderMutation represents an operation that mutates the OrganizationProvider nodes in the graph.
type OrganizationProviderMutation struct {
	config
	op                       Op
	typ                      string
	id                       *xid.ID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	template_key             *string
	custom_config            *map[string]interface{}
	enabled_at               *time.Time
	last_used                *time.Time
	usage_count              *int
	addusage_count           *int
	enabled                  *bool
	success_rate             *float64
	addsuccess_rate          *float64
	total_logins             *int
	addtotal_logins          *int
	successful_logins        *int
	addsuccessful_logins     *int
	failed_logins            *int
	addfailed_logins         *int
	last_success             *time.Time
	last_failure             *time.Time
	config_errors            *int
	addconfig_errors         *int
	average_response_time    *float64
	addaverage_response_time *float64
	analytics_data           *map[string]interface{}
	metadata                 *map[string]interface{}
	clearedFields            map[string]struct{}
	organization             *xid.ID
	clearedorganization      bool
	provider                 *xid.ID
	clearedprovider          bool
	template                 *xid.ID
	clearedtemplate          bool
	done                     bool
	oldValue                 func(context.Context) (*OrganizationProvider, error)
	predicates               []predicate.OrganizationProvider
}

var _ ent.Mutation = (*OrganizationProviderMutation)(nil)

// organizationproviderOption allows management of the mutation configuration using functional options.
type organizationproviderOption func(*OrganizationProviderMutation)

// newOrganizationProviderMutation creates new mutation for the OrganizationProvider entity.
func newOrganizationProviderMutation(c config, op Op, opts ...organizationproviderOption) *OrganizationProviderMutation {
	m := &OrganizationProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationProviderID sets the ID field of the mutation.
func withOrganizationProviderID(id xid.ID) organizationproviderOption {
	return func(m *OrganizationProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationProvider
		)
		m.oldValue = func(ctx context.Context) (*OrganizationProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationProvider sets the old OrganizationProvider of the mutation.
func withOrganizationProvider(node *OrganizationProvider) organizationproviderOption {
	return func(m *OrganizationProviderMutation) {
		m.oldValue = func(context.Context) (*OrganizationProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationProvider entities.
func (m *OrganizationProviderMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationProviderMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationProviderMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationProviderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationProviderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationProviderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationprovider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationProviderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationProviderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationprovider.FieldDeletedAt)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationProviderMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationProviderMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationProviderMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetProviderID sets the "provider_id" field.
func (m *OrganizationProviderMutation) SetProviderID(x xid.ID) {
	m.provider = &x
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *OrganizationProviderMutation) ProviderID() (r xid.ID, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldProviderID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *OrganizationProviderMutation) ResetProviderID() {
	m.provider = nil
}

// SetTemplateID sets the "template_id" field.
func (m *OrganizationProviderMutation) SetTemplateID(x xid.ID) {
	m.template = &x
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *OrganizationProviderMutation) TemplateID() (r xid.ID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldTemplateID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *OrganizationProviderMutation) ResetTemplateID() {
	m.template = nil
}

// SetTemplateKey sets the "template_key" field.
func (m *OrganizationProviderMutation) SetTemplateKey(s string) {
	m.template_key = &s
}

// TemplateKey returns the value of the "template_key" field in the mutation.
func (m *OrganizationProviderMutation) TemplateKey() (r string, exists bool) {
	v := m.template_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateKey returns the old "template_key" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldTemplateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateKey: %w", err)
	}
	return oldValue.TemplateKey, nil
}

// ResetTemplateKey resets all changes to the "template_key" field.
func (m *OrganizationProviderMutation) ResetTemplateKey() {
	m.template_key = nil
}

// SetCustomConfig sets the "custom_config" field.
func (m *OrganizationProviderMutation) SetCustomConfig(value map[string]interface{}) {
	m.custom_config = &value
}

// CustomConfig returns the value of the "custom_config" field in the mutation.
func (m *OrganizationProviderMutation) CustomConfig() (r map[string]interface{}, exists bool) {
	v := m.custom_config
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomConfig returns the old "custom_config" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldCustomConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomConfig: %w", err)
	}
	return oldValue.CustomConfig, nil
}

// ClearCustomConfig clears the value of the "custom_config" field.
func (m *OrganizationProviderMutation) ClearCustomConfig() {
	m.custom_config = nil
	m.clearedFields[organizationprovider.FieldCustomConfig] = struct{}{}
}

// CustomConfigCleared returns if the "custom_config" field was cleared in this mutation.
func (m *OrganizationProviderMutation) CustomConfigCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldCustomConfig]
	return ok
}

// ResetCustomConfig resets all changes to the "custom_config" field.
func (m *OrganizationProviderMutation) ResetCustomConfig() {
	m.custom_config = nil
	delete(m.clearedFields, organizationprovider.FieldCustomConfig)
}

// SetEnabledAt sets the "enabled_at" field.
func (m *OrganizationProviderMutation) SetEnabledAt(t time.Time) {
	m.enabled_at = &t
}

// EnabledAt returns the value of the "enabled_at" field in the mutation.
func (m *OrganizationProviderMutation) EnabledAt() (r time.Time, exists bool) {
	v := m.enabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabledAt returns the old "enabled_at" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldEnabledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabledAt: %w", err)
	}
	return oldValue.EnabledAt, nil
}

// ResetEnabledAt resets all changes to the "enabled_at" field.
func (m *OrganizationProviderMutation) ResetEnabledAt() {
	m.enabled_at = nil
}

// SetLastUsed sets the "last_used" field.
func (m *OrganizationProviderMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *OrganizationProviderMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *OrganizationProviderMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[organizationprovider.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *OrganizationProviderMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *OrganizationProviderMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, organizationprovider.FieldLastUsed)
}

// SetUsageCount sets the "usage_count" field.
func (m *OrganizationProviderMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *OrganizationProviderMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *OrganizationProviderMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *OrganizationProviderMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *OrganizationProviderMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetEnabled sets the "enabled" field.
func (m *OrganizationProviderMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *OrganizationProviderMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *OrganizationProviderMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSuccessRate sets the "success_rate" field.
func (m *OrganizationProviderMutation) SetSuccessRate(f float64) {
	m.success_rate = &f
	m.addsuccess_rate = nil
}

// SuccessRate returns the value of the "success_rate" field in the mutation.
func (m *OrganizationProviderMutation) SuccessRate() (r float64, exists bool) {
	v := m.success_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessRate returns the old "success_rate" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldSuccessRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessRate: %w", err)
	}
	return oldValue.SuccessRate, nil
}

// AddSuccessRate adds f to the "success_rate" field.
func (m *OrganizationProviderMutation) AddSuccessRate(f float64) {
	if m.addsuccess_rate != nil {
		*m.addsuccess_rate += f
	} else {
		m.addsuccess_rate = &f
	}
}

// AddedSuccessRate returns the value that was added to the "success_rate" field in this mutation.
func (m *OrganizationProviderMutation) AddedSuccessRate() (r float64, exists bool) {
	v := m.addsuccess_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessRate resets all changes to the "success_rate" field.
func (m *OrganizationProviderMutation) ResetSuccessRate() {
	m.success_rate = nil
	m.addsuccess_rate = nil
}

// SetTotalLogins sets the "total_logins" field.
func (m *OrganizationProviderMutation) SetTotalLogins(i int) {
	m.total_logins = &i
	m.addtotal_logins = nil
}

// TotalLogins returns the value of the "total_logins" field in the mutation.
func (m *OrganizationProviderMutation) TotalLogins() (r int, exists bool) {
	v := m.total_logins
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalLogins returns the old "total_logins" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldTotalLogins(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalLogins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalLogins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalLogins: %w", err)
	}
	return oldValue.TotalLogins, nil
}

// AddTotalLogins adds i to the "total_logins" field.
func (m *OrganizationProviderMutation) AddTotalLogins(i int) {
	if m.addtotal_logins != nil {
		*m.addtotal_logins += i
	} else {
		m.addtotal_logins = &i
	}
}

// AddedTotalLogins returns the value that was added to the "total_logins" field in this mutation.
func (m *OrganizationProviderMutation) AddedTotalLogins() (r int, exists bool) {
	v := m.addtotal_logins
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalLogins resets all changes to the "total_logins" field.
func (m *OrganizationProviderMutation) ResetTotalLogins() {
	m.total_logins = nil
	m.addtotal_logins = nil
}

// SetSuccessfulLogins sets the "successful_logins" field.
func (m *OrganizationProviderMutation) SetSuccessfulLogins(i int) {
	m.successful_logins = &i
	m.addsuccessful_logins = nil
}

// SuccessfulLogins returns the value of the "successful_logins" field in the mutation.
func (m *OrganizationProviderMutation) SuccessfulLogins() (r int, exists bool) {
	v := m.successful_logins
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessfulLogins returns the old "successful_logins" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldSuccessfulLogins(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessfulLogins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessfulLogins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessfulLogins: %w", err)
	}
	return oldValue.SuccessfulLogins, nil
}

// AddSuccessfulLogins adds i to the "successful_logins" field.
func (m *OrganizationProviderMutation) AddSuccessfulLogins(i int) {
	if m.addsuccessful_logins != nil {
		*m.addsuccessful_logins += i
	} else {
		m.addsuccessful_logins = &i
	}
}

// AddedSuccessfulLogins returns the value that was added to the "successful_logins" field in this mutation.
func (m *OrganizationProviderMutation) AddedSuccessfulLogins() (r int, exists bool) {
	v := m.addsuccessful_logins
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessfulLogins resets all changes to the "successful_logins" field.
func (m *OrganizationProviderMutation) ResetSuccessfulLogins() {
	m.successful_logins = nil
	m.addsuccessful_logins = nil
}

// SetFailedLogins sets the "failed_logins" field.
func (m *OrganizationProviderMutation) SetFailedLogins(i int) {
	m.failed_logins = &i
	m.addfailed_logins = nil
}

// FailedLogins returns the value of the "failed_logins" field in the mutation.
func (m *OrganizationProviderMutation) FailedLogins() (r int, exists bool) {
	v := m.failed_logins
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedLogins returns the old "failed_logins" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldFailedLogins(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedLogins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedLogins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedLogins: %w", err)
	}
	return oldValue.FailedLogins, nil
}

// AddFailedLogins adds i to the "failed_logins" field.
func (m *OrganizationProviderMutation) AddFailedLogins(i int) {
	if m.addfailed_logins != nil {
		*m.addfailed_logins += i
	} else {
		m.addfailed_logins = &i
	}
}

// AddedFailedLogins returns the value that was added to the "failed_logins" field in this mutation.
func (m *OrganizationProviderMutation) AddedFailedLogins() (r int, exists bool) {
	v := m.addfailed_logins
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedLogins resets all changes to the "failed_logins" field.
func (m *OrganizationProviderMutation) ResetFailedLogins() {
	m.failed_logins = nil
	m.addfailed_logins = nil
}

// SetLastSuccess sets the "last_success" field.
func (m *OrganizationProviderMutation) SetLastSuccess(t time.Time) {
	m.last_success = &t
}

// LastSuccess returns the value of the "last_success" field in the mutation.
func (m *OrganizationProviderMutation) LastSuccess() (r time.Time, exists bool) {
	v := m.last_success
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSuccess returns the old "last_success" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldLastSuccess(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSuccess: %w", err)
	}
	return oldValue.LastSuccess, nil
}

// ClearLastSuccess clears the value of the "last_success" field.
func (m *OrganizationProviderMutation) ClearLastSuccess() {
	m.last_success = nil
	m.clearedFields[organizationprovider.FieldLastSuccess] = struct{}{}
}

// LastSuccessCleared returns if the "last_success" field was cleared in this mutation.
func (m *OrganizationProviderMutation) LastSuccessCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldLastSuccess]
	return ok
}

// ResetLastSuccess resets all changes to the "last_success" field.
func (m *OrganizationProviderMutation) ResetLastSuccess() {
	m.last_success = nil
	delete(m.clearedFields, organizationprovider.FieldLastSuccess)
}

// SetLastFailure sets the "last_failure" field.
func (m *OrganizationProviderMutation) SetLastFailure(t time.Time) {
	m.last_failure = &t
}

// LastFailure returns the value of the "last_failure" field in the mutation.
func (m *OrganizationProviderMutation) LastFailure() (r time.Time, exists bool) {
	v := m.last_failure
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailure returns the old "last_failure" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldLastFailure(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailure: %w", err)
	}
	return oldValue.LastFailure, nil
}

// ClearLastFailure clears the value of the "last_failure" field.
func (m *OrganizationProviderMutation) ClearLastFailure() {
	m.last_failure = nil
	m.clearedFields[organizationprovider.FieldLastFailure] = struct{}{}
}

// LastFailureCleared returns if the "last_failure" field was cleared in this mutation.
func (m *OrganizationProviderMutation) LastFailureCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldLastFailure]
	return ok
}

// ResetLastFailure resets all changes to the "last_failure" field.
func (m *OrganizationProviderMutation) ResetLastFailure() {
	m.last_failure = nil
	delete(m.clearedFields, organizationprovider.FieldLastFailure)
}

// SetConfigErrors sets the "config_errors" field.
func (m *OrganizationProviderMutation) SetConfigErrors(i int) {
	m.config_errors = &i
	m.addconfig_errors = nil
}

// ConfigErrors returns the value of the "config_errors" field in the mutation.
func (m *OrganizationProviderMutation) ConfigErrors() (r int, exists bool) {
	v := m.config_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigErrors returns the old "config_errors" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldConfigErrors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigErrors: %w", err)
	}
	return oldValue.ConfigErrors, nil
}

// AddConfigErrors adds i to the "config_errors" field.
func (m *OrganizationProviderMutation) AddConfigErrors(i int) {
	if m.addconfig_errors != nil {
		*m.addconfig_errors += i
	} else {
		m.addconfig_errors = &i
	}
}

// AddedConfigErrors returns the value that was added to the "config_errors" field in this mutation.
func (m *OrganizationProviderMutation) AddedConfigErrors() (r int, exists bool) {
	v := m.addconfig_errors
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfigErrors resets all changes to the "config_errors" field.
func (m *OrganizationProviderMutation) ResetConfigErrors() {
	m.config_errors = nil
	m.addconfig_errors = nil
}

// SetAverageResponseTime sets the "average_response_time" field.
func (m *OrganizationProviderMutation) SetAverageResponseTime(f float64) {
	m.average_response_time = &f
	m.addaverage_response_time = nil
}

// AverageResponseTime returns the value of the "average_response_time" field in the mutation.
func (m *OrganizationProviderMutation) AverageResponseTime() (r float64, exists bool) {
	v := m.average_response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageResponseTime returns the old "average_response_time" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldAverageResponseTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageResponseTime: %w", err)
	}
	return oldValue.AverageResponseTime, nil
}

// AddAverageResponseTime adds f to the "average_response_time" field.
func (m *OrganizationProviderMutation) AddAverageResponseTime(f float64) {
	if m.addaverage_response_time != nil {
		*m.addaverage_response_time += f
	} else {
		m.addaverage_response_time = &f
	}
}

// AddedAverageResponseTime returns the value that was added to the "average_response_time" field in this mutation.
func (m *OrganizationProviderMutation) AddedAverageResponseTime() (r float64, exists bool) {
	v := m.addaverage_response_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageResponseTime resets all changes to the "average_response_time" field.
func (m *OrganizationProviderMutation) ResetAverageResponseTime() {
	m.average_response_time = nil
	m.addaverage_response_time = nil
}

// SetAnalyticsData sets the "analytics_data" field.
func (m *OrganizationProviderMutation) SetAnalyticsData(value map[string]interface{}) {
	m.analytics_data = &value
}

// AnalyticsData returns the value of the "analytics_data" field in the mutation.
func (m *OrganizationProviderMutation) AnalyticsData() (r map[string]interface{}, exists bool) {
	v := m.analytics_data
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalyticsData returns the old "analytics_data" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldAnalyticsData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalyticsData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalyticsData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalyticsData: %w", err)
	}
	return oldValue.AnalyticsData, nil
}

// ClearAnalyticsData clears the value of the "analytics_data" field.
func (m *OrganizationProviderMutation) ClearAnalyticsData() {
	m.analytics_data = nil
	m.clearedFields[organizationprovider.FieldAnalyticsData] = struct{}{}
}

// AnalyticsDataCleared returns if the "analytics_data" field was cleared in this mutation.
func (m *OrganizationProviderMutation) AnalyticsDataCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldAnalyticsData]
	return ok
}

// ResetAnalyticsData resets all changes to the "analytics_data" field.
func (m *OrganizationProviderMutation) ResetAnalyticsData() {
	m.analytics_data = nil
	delete(m.clearedFields, organizationprovider.FieldAnalyticsData)
}

// SetMetadata sets the "metadata" field.
func (m *OrganizationProviderMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *OrganizationProviderMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the OrganizationProvider entity.
// If the OrganizationProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationProviderMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *OrganizationProviderMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[organizationprovider.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *OrganizationProviderMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[organizationprovider.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *OrganizationProviderMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, organizationprovider.FieldMetadata)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationProviderMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationprovider.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationProviderMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationProviderMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationProviderMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearProvider clears the "provider" edge to the IdentityProvider entity.
func (m *OrganizationProviderMutation) ClearProvider() {
	m.clearedprovider = true
	m.clearedFields[organizationprovider.FieldProviderID] = struct{}{}
}

// ProviderCleared reports if the "provider" edge to the IdentityProvider entity was cleared.
func (m *OrganizationProviderMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *OrganizationProviderMutation) ProviderIDs() (ids []xid.ID) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *OrganizationProviderMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// ClearTemplate clears the "template" edge to the ProviderTemplate entity.
func (m *OrganizationProviderMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[organizationprovider.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the ProviderTemplate entity was cleared.
func (m *OrganizationProviderMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *OrganizationProviderMutation) TemplateIDs() (ids []xid.ID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *OrganizationProviderMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// Where appends a list predicates to the OrganizationProviderMutation builder.
func (m *OrganizationProviderMutation) Where(ps ...predicate.OrganizationProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationProvider).
func (m *OrganizationProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationProviderMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, organizationprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationprovider.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationprovider.FieldDeletedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationprovider.FieldOrganizationID)
	}
	if m.provider != nil {
		fields = append(fields, organizationprovider.FieldProviderID)
	}
	if m.template != nil {
		fields = append(fields, organizationprovider.FieldTemplateID)
	}
	if m.template_key != nil {
		fields = append(fields, organizationprovider.FieldTemplateKey)
	}
	if m.custom_config != nil {
		fields = append(fields, organizationprovider.FieldCustomConfig)
	}
	if m.enabled_at != nil {
		fields = append(fields, organizationprovider.FieldEnabledAt)
	}
	if m.last_used != nil {
		fields = append(fields, organizationprovider.FieldLastUsed)
	}
	if m.usage_count != nil {
		fields = append(fields, organizationprovider.FieldUsageCount)
	}
	if m.enabled != nil {
		fields = append(fields, organizationprovider.FieldEnabled)
	}
	if m.success_rate != nil {
		fields = append(fields, organizationprovider.FieldSuccessRate)
	}
	if m.total_logins != nil {
		fields = append(fields, organizationprovider.FieldTotalLogins)
	}
	if m.successful_logins != nil {
		fields = append(fields, organizationprovider.FieldSuccessfulLogins)
	}
	if m.failed_logins != nil {
		fields = append(fields, organizationprovider.FieldFailedLogins)
	}
	if m.last_success != nil {
		fields = append(fields, organizationprovider.FieldLastSuccess)
	}
	if m.last_failure != nil {
		fields = append(fields, organizationprovider.FieldLastFailure)
	}
	if m.config_errors != nil {
		fields = append(fields, organizationprovider.FieldConfigErrors)
	}
	if m.average_response_time != nil {
		fields = append(fields, organizationprovider.FieldAverageResponseTime)
	}
	if m.analytics_data != nil {
		fields = append(fields, organizationprovider.FieldAnalyticsData)
	}
	if m.metadata != nil {
		fields = append(fields, organizationprovider.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationprovider.FieldCreatedAt:
		return m.CreatedAt()
	case organizationprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationprovider.FieldDeletedAt:
		return m.DeletedAt()
	case organizationprovider.FieldOrganizationID:
		return m.OrganizationID()
	case organizationprovider.FieldProviderID:
		return m.ProviderID()
	case organizationprovider.FieldTemplateID:
		return m.TemplateID()
	case organizationprovider.FieldTemplateKey:
		return m.TemplateKey()
	case organizationprovider.FieldCustomConfig:
		return m.CustomConfig()
	case organizationprovider.FieldEnabledAt:
		return m.EnabledAt()
	case organizationprovider.FieldLastUsed:
		return m.LastUsed()
	case organizationprovider.FieldUsageCount:
		return m.UsageCount()
	case organizationprovider.FieldEnabled:
		return m.Enabled()
	case organizationprovider.FieldSuccessRate:
		return m.SuccessRate()
	case organizationprovider.FieldTotalLogins:
		return m.TotalLogins()
	case organizationprovider.FieldSuccessfulLogins:
		return m.SuccessfulLogins()
	case organizationprovider.FieldFailedLogins:
		return m.FailedLogins()
	case organizationprovider.FieldLastSuccess:
		return m.LastSuccess()
	case organizationprovider.FieldLastFailure:
		return m.LastFailure()
	case organizationprovider.FieldConfigErrors:
		return m.ConfigErrors()
	case organizationprovider.FieldAverageResponseTime:
		return m.AverageResponseTime()
	case organizationprovider.FieldAnalyticsData:
		return m.AnalyticsData()
	case organizationprovider.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationprovider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationprovider.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationprovider.FieldProviderID:
		return m.OldProviderID(ctx)
	case organizationprovider.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case organizationprovider.FieldTemplateKey:
		return m.OldTemplateKey(ctx)
	case organizationprovider.FieldCustomConfig:
		return m.OldCustomConfig(ctx)
	case organizationprovider.FieldEnabledAt:
		return m.OldEnabledAt(ctx)
	case organizationprovider.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case organizationprovider.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case organizationprovider.FieldEnabled:
		return m.OldEnabled(ctx)
	case organizationprovider.FieldSuccessRate:
		return m.OldSuccessRate(ctx)
	case organizationprovider.FieldTotalLogins:
		return m.OldTotalLogins(ctx)
	case organizationprovider.FieldSuccessfulLogins:
		return m.OldSuccessfulLogins(ctx)
	case organizationprovider.FieldFailedLogins:
		return m.OldFailedLogins(ctx)
	case organizationprovider.FieldLastSuccess:
		return m.OldLastSuccess(ctx)
	case organizationprovider.FieldLastFailure:
		return m.OldLastFailure(ctx)
	case organizationprovider.FieldConfigErrors:
		return m.OldConfigErrors(ctx)
	case organizationprovider.FieldAverageResponseTime:
		return m.OldAverageResponseTime(ctx)
	case organizationprovider.FieldAnalyticsData:
		return m.OldAnalyticsData(ctx)
	case organizationprovider.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationprovider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationprovider.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationprovider.FieldProviderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case organizationprovider.FieldTemplateID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case organizationprovider.FieldTemplateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateKey(v)
		return nil
	case organizationprovider.FieldCustomConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomConfig(v)
		return nil
	case organizationprovider.FieldEnabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabledAt(v)
		return nil
	case organizationprovider.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case organizationprovider.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case organizationprovider.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case organizationprovider.FieldSuccessRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessRate(v)
		return nil
	case organizationprovider.FieldTotalLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalLogins(v)
		return nil
	case organizationprovider.FieldSuccessfulLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessfulLogins(v)
		return nil
	case organizationprovider.FieldFailedLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedLogins(v)
		return nil
	case organizationprovider.FieldLastSuccess:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSuccess(v)
		return nil
	case organizationprovider.FieldLastFailure:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailure(v)
		return nil
	case organizationprovider.FieldConfigErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigErrors(v)
		return nil
	case organizationprovider.FieldAverageResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageResponseTime(v)
		return nil
	case organizationprovider.FieldAnalyticsData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalyticsData(v)
		return nil
	case organizationprovider.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationProviderMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, organizationprovider.FieldUsageCount)
	}
	if m.addsuccess_rate != nil {
		fields = append(fields, organizationprovider.FieldSuccessRate)
	}
	if m.addtotal_logins != nil {
		fields = append(fields, organizationprovider.FieldTotalLogins)
	}
	if m.addsuccessful_logins != nil {
		fields = append(fields, organizationprovider.FieldSuccessfulLogins)
	}
	if m.addfailed_logins != nil {
		fields = append(fields, organizationprovider.FieldFailedLogins)
	}
	if m.addconfig_errors != nil {
		fields = append(fields, organizationprovider.FieldConfigErrors)
	}
	if m.addaverage_response_time != nil {
		fields = append(fields, organizationprovider.FieldAverageResponseTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationprovider.FieldUsageCount:
		return m.AddedUsageCount()
	case organizationprovider.FieldSuccessRate:
		return m.AddedSuccessRate()
	case organizationprovider.FieldTotalLogins:
		return m.AddedTotalLogins()
	case organizationprovider.FieldSuccessfulLogins:
		return m.AddedSuccessfulLogins()
	case organizationprovider.FieldFailedLogins:
		return m.AddedFailedLogins()
	case organizationprovider.FieldConfigErrors:
		return m.AddedConfigErrors()
	case organizationprovider.FieldAverageResponseTime:
		return m.AddedAverageResponseTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationprovider.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	case organizationprovider.FieldSuccessRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessRate(v)
		return nil
	case organizationprovider.FieldTotalLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalLogins(v)
		return nil
	case organizationprovider.FieldSuccessfulLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessfulLogins(v)
		return nil
	case organizationprovider.FieldFailedLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedLogins(v)
		return nil
	case organizationprovider.FieldConfigErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigErrors(v)
		return nil
	case organizationprovider.FieldAverageResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageResponseTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationprovider.FieldDeletedAt) {
		fields = append(fields, organizationprovider.FieldDeletedAt)
	}
	if m.FieldCleared(organizationprovider.FieldCustomConfig) {
		fields = append(fields, organizationprovider.FieldCustomConfig)
	}
	if m.FieldCleared(organizationprovider.FieldLastUsed) {
		fields = append(fields, organizationprovider.FieldLastUsed)
	}
	if m.FieldCleared(organizationprovider.FieldLastSuccess) {
		fields = append(fields, organizationprovider.FieldLastSuccess)
	}
	if m.FieldCleared(organizationprovider.FieldLastFailure) {
		fields = append(fields, organizationprovider.FieldLastFailure)
	}
	if m.FieldCleared(organizationprovider.FieldAnalyticsData) {
		fields = append(fields, organizationprovider.FieldAnalyticsData)
	}
	if m.FieldCleared(organizationprovider.FieldMetadata) {
		fields = append(fields, organizationprovider.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationProviderMutation) ClearField(name string) error {
	switch name {
	case organizationprovider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationprovider.FieldCustomConfig:
		m.ClearCustomConfig()
		return nil
	case organizationprovider.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case organizationprovider.FieldLastSuccess:
		m.ClearLastSuccess()
		return nil
	case organizationprovider.FieldLastFailure:
		m.ClearLastFailure()
		return nil
	case organizationprovider.FieldAnalyticsData:
		m.ClearAnalyticsData()
		return nil
	case organizationprovider.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown OrganizationProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationProviderMutation) ResetField(name string) error {
	switch name {
	case organizationprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationprovider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationprovider.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationprovider.FieldProviderID:
		m.ResetProviderID()
		return nil
	case organizationprovider.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case organizationprovider.FieldTemplateKey:
		m.ResetTemplateKey()
		return nil
	case organizationprovider.FieldCustomConfig:
		m.ResetCustomConfig()
		return nil
	case organizationprovider.FieldEnabledAt:
		m.ResetEnabledAt()
		return nil
	case organizationprovider.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case organizationprovider.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case organizationprovider.FieldEnabled:
		m.ResetEnabled()
		return nil
	case organizationprovider.FieldSuccessRate:
		m.ResetSuccessRate()
		return nil
	case organizationprovider.FieldTotalLogins:
		m.ResetTotalLogins()
		return nil
	case organizationprovider.FieldSuccessfulLogins:
		m.ResetSuccessfulLogins()
		return nil
	case organizationprovider.FieldFailedLogins:
		m.ResetFailedLogins()
		return nil
	case organizationprovider.FieldLastSuccess:
		m.ResetLastSuccess()
		return nil
	case organizationprovider.FieldLastFailure:
		m.ResetLastFailure()
		return nil
	case organizationprovider.FieldConfigErrors:
		m.ResetConfigErrors()
		return nil
	case organizationprovider.FieldAverageResponseTime:
		m.ResetAverageResponseTime()
		return nil
	case organizationprovider.FieldAnalyticsData:
		m.ResetAnalyticsData()
		return nil
	case organizationprovider.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown OrganizationProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, organizationprovider.EdgeOrganization)
	}
	if m.provider != nil {
		edges = append(edges, organizationprovider.EdgeProvider)
	}
	if m.template != nil {
		edges = append(edges, organizationprovider.EdgeTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationprovider.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationprovider.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case organizationprovider.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, organizationprovider.EdgeOrganization)
	}
	if m.clearedprovider {
		edges = append(edges, organizationprovider.EdgeProvider)
	}
	if m.clearedtemplate {
		edges = append(edges, organizationprovider.EdgeTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationprovider.EdgeOrganization:
		return m.clearedorganization
	case organizationprovider.EdgeProvider:
		return m.clearedprovider
	case organizationprovider.EdgeTemplate:
		return m.clearedtemplate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationProviderMutation) ClearEdge(name string) error {
	switch name {
	case organizationprovider.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationprovider.EdgeProvider:
		m.ClearProvider()
		return nil
	case organizationprovider.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown OrganizationProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationProviderMutation) ResetEdge(name string) error {
	switch name {
	case organizationprovider.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationprovider.EdgeProvider:
		m.ResetProvider()
		return nil
	case organizationprovider.EdgeTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown OrganizationProvider edge %s", name)
}

// PasskeyMutation represents an operation that mutates the Passkey nodes in the graph.
type PasskeyMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	credential_id    *string
	public_key       *[]byte
	sign_count       *int
	addsign_count    *int
	active           *bool
	device_type      *string
	aaguid           *string
	last_used        *time.Time
	transports       *[]string
	appendtransports []string
	attestation      *map[string]interface{}
	backup_state     *bool
	backup_eligible  *bool
	user_agent       *string
	ip_address       *string
	clearedFields    map[string]struct{}
	user             *xid.ID
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Passkey, error)
	predicates       []predicate.Passkey
}

var _ ent.Mutation = (*PasskeyMutation)(nil)

// passkeyOption allows management of the mutation configuration using functional options.
type passkeyOption func(*PasskeyMutation)

// newPasskeyMutation creates new mutation for the Passkey entity.
func newPasskeyMutation(c config, op Op, opts ...passkeyOption) *PasskeyMutation {
	m := &PasskeyMutation{
		config:        c,
		op:            op,
		typ:           TypePasskey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasskeyID sets the ID field of the mutation.
func withPasskeyID(id xid.ID) passkeyOption {
	return func(m *PasskeyMutation) {
		var (
			err   error
			once  sync.Once
			value *Passkey
		)
		m.oldValue = func(ctx context.Context) (*Passkey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passkey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasskey sets the old Passkey of the mutation.
func withPasskey(node *Passkey) passkeyOption {
	return func(m *PasskeyMutation) {
		m.oldValue = func(context.Context) (*Passkey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasskeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasskeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Passkey entities.
func (m *PasskeyMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasskeyMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasskeyMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passkey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasskeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasskeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasskeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasskeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasskeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasskeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasskeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasskeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasskeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passkey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasskeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasskeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passkey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *PasskeyMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasskeyMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasskeyMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *PasskeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PasskeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasskeyMutation) ResetName() {
	m.name = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *PasskeyMutation) SetCredentialID(s string) {
	m.credential_id = &s
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *PasskeyMutation) CredentialID() (r string, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCredentialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *PasskeyMutation) ResetCredentialID() {
	m.credential_id = nil
}

// SetPublicKey sets the "public_key" field.
func (m *PasskeyMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *PasskeyMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *PasskeyMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetSignCount sets the "sign_count" field.
func (m *PasskeyMutation) SetSignCount(i int) {
	m.sign_count = &i
	m.addsign_count = nil
}

// SignCount returns the value of the "sign_count" field in the mutation.
func (m *PasskeyMutation) SignCount() (r int, exists bool) {
	v := m.sign_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "sign_count" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldSignCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds i to the "sign_count" field.
func (m *PasskeyMutation) AddSignCount(i int) {
	if m.addsign_count != nil {
		*m.addsign_count += i
	} else {
		m.addsign_count = &i
	}
}

// AddedSignCount returns the value that was added to the "sign_count" field in this mutation.
func (m *PasskeyMutation) AddedSignCount() (r int, exists bool) {
	v := m.addsign_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "sign_count" field.
func (m *PasskeyMutation) ResetSignCount() {
	m.sign_count = nil
	m.addsign_count = nil
}

// SetActive sets the "active" field.
func (m *PasskeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PasskeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PasskeyMutation) ResetActive() {
	m.active = nil
}

// SetDeviceType sets the "device_type" field.
func (m *PasskeyMutation) SetDeviceType(s string) {
	m.device_type = &s
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *PasskeyMutation) DeviceType() (r string, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldDeviceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ClearDeviceType clears the value of the "device_type" field.
func (m *PasskeyMutation) ClearDeviceType() {
	m.device_type = nil
	m.clearedFields[passkey.FieldDeviceType] = struct{}{}
}

// DeviceTypeCleared returns if the "device_type" field was cleared in this mutation.
func (m *PasskeyMutation) DeviceTypeCleared() bool {
	_, ok := m.clearedFields[passkey.FieldDeviceType]
	return ok
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *PasskeyMutation) ResetDeviceType() {
	m.device_type = nil
	delete(m.clearedFields, passkey.FieldDeviceType)
}

// SetAaguid sets the "aaguid" field.
func (m *PasskeyMutation) SetAaguid(s string) {
	m.aaguid = &s
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *PasskeyMutation) Aaguid() (r string, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAaguid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ClearAaguid clears the value of the "aaguid" field.
func (m *PasskeyMutation) ClearAaguid() {
	m.aaguid = nil
	m.clearedFields[passkey.FieldAaguid] = struct{}{}
}

// AaguidCleared returns if the "aaguid" field was cleared in this mutation.
func (m *PasskeyMutation) AaguidCleared() bool {
	_, ok := m.clearedFields[passkey.FieldAaguid]
	return ok
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *PasskeyMutation) ResetAaguid() {
	m.aaguid = nil
	delete(m.clearedFields, passkey.FieldAaguid)
}

// SetLastUsed sets the "last_used" field.
func (m *PasskeyMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *PasskeyMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *PasskeyMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[passkey.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *PasskeyMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[passkey.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *PasskeyMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, passkey.FieldLastUsed)
}

// SetTransports sets the "transports" field.
func (m *PasskeyMutation) SetTransports(s []string) {
	m.transports = &s
	m.appendtransports = nil
}

// Transports returns the value of the "transports" field in the mutation.
func (m *PasskeyMutation) Transports() (r []string, exists bool) {
	v := m.transports
	if v == nil {
		return
	}
	return *v, true
}

// OldTransports returns the old "transports" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldTransports(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransports: %w", err)
	}
	return oldValue.Transports, nil
}

// AppendTransports adds s to the "transports" field.
func (m *PasskeyMutation) AppendTransports(s []string) {
	m.appendtransports = append(m.appendtransports, s...)
}

// AppendedTransports returns the list of values that were appended to the "transports" field in this mutation.
func (m *PasskeyMutation) AppendedTransports() ([]string, bool) {
	if len(m.appendtransports) == 0 {
		return nil, false
	}
	return m.appendtransports, true
}

// ClearTransports clears the value of the "transports" field.
func (m *PasskeyMutation) ClearTransports() {
	m.transports = nil
	m.appendtransports = nil
	m.clearedFields[passkey.FieldTransports] = struct{}{}
}

// TransportsCleared returns if the "transports" field was cleared in this mutation.
func (m *PasskeyMutation) TransportsCleared() bool {
	_, ok := m.clearedFields[passkey.FieldTransports]
	return ok
}

// ResetTransports resets all changes to the "transports" field.
func (m *PasskeyMutation) ResetTransports() {
	m.transports = nil
	m.appendtransports = nil
	delete(m.clearedFields, passkey.FieldTransports)
}

// SetAttestation sets the "attestation" field.
func (m *PasskeyMutation) SetAttestation(value map[string]interface{}) {
	m.attestation = &value
}

// Attestation returns the value of the "attestation" field in the mutation.
func (m *PasskeyMutation) Attestation() (r map[string]interface{}, exists bool) {
	v := m.attestation
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestation returns the old "attestation" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAttestation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestation: %w", err)
	}
	return oldValue.Attestation, nil
}

// ClearAttestation clears the value of the "attestation" field.
func (m *PasskeyMutation) ClearAttestation() {
	m.attestation = nil
	m.clearedFields[passkey.FieldAttestation] = struct{}{}
}

// AttestationCleared returns if the "attestation" field was cleared in this mutation.
func (m *PasskeyMutation) AttestationCleared() bool {
	_, ok := m.clearedFields[passkey.FieldAttestation]
	return ok
}

// ResetAttestation resets all changes to the "attestation" field.
func (m *PasskeyMutation) ResetAttestation() {
	m.attestation = nil
	delete(m.clearedFields, passkey.FieldAttestation)
}

// SetBackupState sets the "backup_state" field.
func (m *PasskeyMutation) SetBackupState(b bool) {
	m.backup_state = &b
}

// BackupState returns the value of the "backup_state" field in the mutation.
func (m *PasskeyMutation) BackupState() (r bool, exists bool) {
	v := m.backup_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupState returns the old "backup_state" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldBackupState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupState: %w", err)
	}
	return oldValue.BackupState, nil
}

// ClearBackupState clears the value of the "backup_state" field.
func (m *PasskeyMutation) ClearBackupState() {
	m.backup_state = nil
	m.clearedFields[passkey.FieldBackupState] = struct{}{}
}

// BackupStateCleared returns if the "backup_state" field was cleared in this mutation.
func (m *PasskeyMutation) BackupStateCleared() bool {
	_, ok := m.clearedFields[passkey.FieldBackupState]
	return ok
}

// ResetBackupState resets all changes to the "backup_state" field.
func (m *PasskeyMutation) ResetBackupState() {
	m.backup_state = nil
	delete(m.clearedFields, passkey.FieldBackupState)
}

// SetBackupEligible sets the "backup_eligible" field.
func (m *PasskeyMutation) SetBackupEligible(b bool) {
	m.backup_eligible = &b
}

// BackupEligible returns the value of the "backup_eligible" field in the mutation.
func (m *PasskeyMutation) BackupEligible() (r bool, exists bool) {
	v := m.backup_eligible
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupEligible returns the old "backup_eligible" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldBackupEligible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupEligible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupEligible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupEligible: %w", err)
	}
	return oldValue.BackupEligible, nil
}

// ClearBackupEligible clears the value of the "backup_eligible" field.
func (m *PasskeyMutation) ClearBackupEligible() {
	m.backup_eligible = nil
	m.clearedFields[passkey.FieldBackupEligible] = struct{}{}
}

// BackupEligibleCleared returns if the "backup_eligible" field was cleared in this mutation.
func (m *PasskeyMutation) BackupEligibleCleared() bool {
	_, ok := m.clearedFields[passkey.FieldBackupEligible]
	return ok
}

// ResetBackupEligible resets all changes to the "backup_eligible" field.
func (m *PasskeyMutation) ResetBackupEligible() {
	m.backup_eligible = nil
	delete(m.clearedFields, passkey.FieldBackupEligible)
}

// SetUserAgent sets the "user_agent" field.
func (m *PasskeyMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *PasskeyMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *PasskeyMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[passkey.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *PasskeyMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[passkey.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *PasskeyMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, passkey.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *PasskeyMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *PasskeyMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *PasskeyMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[passkey.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *PasskeyMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[passkey.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *PasskeyMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, passkey.FieldIPAddress)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasskeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passkey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasskeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasskeyMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasskeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasskeyMutation builder.
func (m *PasskeyMutation) Where(ps ...predicate.Passkey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasskeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasskeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passkey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasskeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasskeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passkey).
func (m *PasskeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasskeyMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, passkey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passkey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, passkey.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, passkey.FieldName)
	}
	if m.credential_id != nil {
		fields = append(fields, passkey.FieldCredentialID)
	}
	if m.public_key != nil {
		fields = append(fields, passkey.FieldPublicKey)
	}
	if m.sign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	if m.active != nil {
		fields = append(fields, passkey.FieldActive)
	}
	if m.device_type != nil {
		fields = append(fields, passkey.FieldDeviceType)
	}
	if m.aaguid != nil {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.last_used != nil {
		fields = append(fields, passkey.FieldLastUsed)
	}
	if m.transports != nil {
		fields = append(fields, passkey.FieldTransports)
	}
	if m.attestation != nil {
		fields = append(fields, passkey.FieldAttestation)
	}
	if m.backup_state != nil {
		fields = append(fields, passkey.FieldBackupState)
	}
	if m.backup_eligible != nil {
		fields = append(fields, passkey.FieldBackupEligible)
	}
	if m.user_agent != nil {
		fields = append(fields, passkey.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, passkey.FieldIPAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasskeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.CreatedAt()
	case passkey.FieldUpdatedAt:
		return m.UpdatedAt()
	case passkey.FieldDeletedAt:
		return m.DeletedAt()
	case passkey.FieldUserID:
		return m.UserID()
	case passkey.FieldName:
		return m.Name()
	case passkey.FieldCredentialID:
		return m.CredentialID()
	case passkey.FieldPublicKey:
		return m.PublicKey()
	case passkey.FieldSignCount:
		return m.SignCount()
	case passkey.FieldActive:
		return m.Active()
	case passkey.FieldDeviceType:
		return m.DeviceType()
	case passkey.FieldAaguid:
		return m.Aaguid()
	case passkey.FieldLastUsed:
		return m.LastUsed()
	case passkey.FieldTransports:
		return m.Transports()
	case passkey.FieldAttestation:
		return m.Attestation()
	case passkey.FieldBackupState:
		return m.BackupState()
	case passkey.FieldBackupEligible:
		return m.BackupEligible()
	case passkey.FieldUserAgent:
		return m.UserAgent()
	case passkey.FieldIPAddress:
		return m.IPAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasskeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passkey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passkey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passkey.FieldUserID:
		return m.OldUserID(ctx)
	case passkey.FieldName:
		return m.OldName(ctx)
	case passkey.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case passkey.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case passkey.FieldSignCount:
		return m.OldSignCount(ctx)
	case passkey.FieldActive:
		return m.OldActive(ctx)
	case passkey.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case passkey.FieldAaguid:
		return m.OldAaguid(ctx)
	case passkey.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case passkey.FieldTransports:
		return m.OldTransports(ctx)
	case passkey.FieldAttestation:
		return m.OldAttestation(ctx)
	case passkey.FieldBackupState:
		return m.OldBackupState(ctx)
	case passkey.FieldBackupEligible:
		return m.OldBackupEligible(ctx)
	case passkey.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case passkey.FieldIPAddress:
		return m.OldIPAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Passkey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passkey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passkey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passkey.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passkey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case passkey.FieldCredentialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case passkey.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case passkey.FieldSignCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case passkey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case passkey.FieldDeviceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case passkey.FieldAaguid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case passkey.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case passkey.FieldTransports:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransports(v)
		return nil
	case passkey.FieldAttestation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestation(v)
		return nil
	case passkey.FieldBackupState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupState(v)
		return nil
	case passkey.FieldBackupEligible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupEligible(v)
		return nil
	case passkey.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case passkey.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasskeyMutation) AddedFields() []string {
	var fields []string
	if m.addsign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasskeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldSignCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasskeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passkey.FieldDeletedAt) {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.FieldCleared(passkey.FieldDeviceType) {
		fields = append(fields, passkey.FieldDeviceType)
	}
	if m.FieldCleared(passkey.FieldAaguid) {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.FieldCleared(passkey.FieldLastUsed) {
		fields = append(fields, passkey.FieldLastUsed)
	}
	if m.FieldCleared(passkey.FieldTransports) {
		fields = append(fields, passkey.FieldTransports)
	}
	if m.FieldCleared(passkey.FieldAttestation) {
		fields = append(fields, passkey.FieldAttestation)
	}
	if m.FieldCleared(passkey.FieldBackupState) {
		fields = append(fields, passkey.FieldBackupState)
	}
	if m.FieldCleared(passkey.FieldBackupEligible) {
		fields = append(fields, passkey.FieldBackupEligible)
	}
	if m.FieldCleared(passkey.FieldUserAgent) {
		fields = append(fields, passkey.FieldUserAgent)
	}
	if m.FieldCleared(passkey.FieldIPAddress) {
		fields = append(fields, passkey.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasskeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasskeyMutation) ClearField(name string) error {
	switch name {
	case passkey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passkey.FieldDeviceType:
		m.ClearDeviceType()
		return nil
	case passkey.FieldAaguid:
		m.ClearAaguid()
		return nil
	case passkey.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case passkey.FieldTransports:
		m.ClearTransports()
		return nil
	case passkey.FieldAttestation:
		m.ClearAttestation()
		return nil
	case passkey.FieldBackupState:
		m.ClearBackupState()
		return nil
	case passkey.FieldBackupEligible:
		m.ClearBackupEligible()
		return nil
	case passkey.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case passkey.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown Passkey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasskeyMutation) ResetField(name string) error {
	switch name {
	case passkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passkey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passkey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passkey.FieldUserID:
		m.ResetUserID()
		return nil
	case passkey.FieldName:
		m.ResetName()
		return nil
	case passkey.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case passkey.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case passkey.FieldSignCount:
		m.ResetSignCount()
		return nil
	case passkey.FieldActive:
		m.ResetActive()
		return nil
	case passkey.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case passkey.FieldAaguid:
		m.ResetAaguid()
		return nil
	case passkey.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case passkey.FieldTransports:
		m.ResetTransports()
		return nil
	case passkey.FieldAttestation:
		m.ResetAttestation()
		return nil
	case passkey.FieldBackupState:
		m.ResetBackupState()
		return nil
	case passkey.FieldBackupEligible:
		m.ResetBackupEligible()
		return nil
	case passkey.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case passkey.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasskeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasskeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasskeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasskeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasskeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasskeyMutation) EdgeCleared(name string) bool {
	switch name {
	case passkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasskeyMutation) ClearEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasskeyMutation) ResetEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *xid.ID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	display_name                 *string
	description                  *string
	resource                     *string
	action                       *string
	category                     *model.PermissionCategory
	applicable_user_types        *[]model.UserType
	appendapplicable_user_types  []model.UserType
	applicable_contexts          *[]model.ContextType
	appendapplicable_contexts    []model.ContextType
	conditions                   *string
	system                       *bool
	dangerous                    *bool
	risk_level                   *int
	addrisk_level                *int
	created_by                   *string
	active                       *bool
	permission_group             *model.PermissionGroup
	clearedFields                map[string]struct{}
	roles                        map[xid.ID]struct{}
	removedroles                 map[xid.ID]struct{}
	clearedroles                 bool
	user_assignments             map[xid.ID]struct{}
	removeduser_assignments      map[xid.ID]struct{}
	cleareduser_assignments      bool
	dependencies                 map[xid.ID]struct{}
	removeddependencies          map[xid.ID]struct{}
	cleareddependencies          bool
	dependents                   map[xid.ID]struct{}
	removeddependents            map[xid.ID]struct{}
	cleareddependents            bool
	dependent_permissions        map[xid.ID]struct{}
	removeddependent_permissions map[xid.ID]struct{}
	cleareddependent_permissions bool
	required_permissions         map[xid.ID]struct{}
	removedrequired_permissions  map[xid.ID]struct{}
	clearedrequired_permissions  bool
	done                         bool
	oldValue                     func(context.Context) (*Permission, error)
	predicates                   []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id xid.ID) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *PermissionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PermissionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PermissionMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[permission.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PermissionMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[permission.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PermissionMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, permission.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
}

// SetResource sets the "resource" field.
func (m *PermissionMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *PermissionMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *PermissionMutation) ResetResource() {
	m.resource = nil
}

// SetAction sets the "action" field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
}

// SetCategory sets the "category" field.
func (m *PermissionMutation) SetCategory(mc model.PermissionCategory) {
	m.category = &mc
}

// Category returns the value of the "category" field in the mutation.
func (m *PermissionMutation) Category() (r model.PermissionCategory, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCategory(ctx context.Context) (v model.PermissionCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *PermissionMutation) ResetCategory() {
	m.category = nil
}

// SetApplicableUserTypes sets the "applicable_user_types" field.
func (m *PermissionMutation) SetApplicableUserTypes(mt []model.UserType) {
	m.applicable_user_types = &mt
	m.appendapplicable_user_types = nil
}

// ApplicableUserTypes returns the value of the "applicable_user_types" field in the mutation.
func (m *PermissionMutation) ApplicableUserTypes() (r []model.UserType, exists bool) {
	v := m.applicable_user_types
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableUserTypes returns the old "applicable_user_types" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldApplicableUserTypes(ctx context.Context) (v []model.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableUserTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableUserTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableUserTypes: %w", err)
	}
	return oldValue.ApplicableUserTypes, nil
}

// AppendApplicableUserTypes adds mt to the "applicable_user_types" field.
func (m *PermissionMutation) AppendApplicableUserTypes(mt []model.UserType) {
	m.appendapplicable_user_types = append(m.appendapplicable_user_types, mt...)
}

// AppendedApplicableUserTypes returns the list of values that were appended to the "applicable_user_types" field in this mutation.
func (m *PermissionMutation) AppendedApplicableUserTypes() ([]model.UserType, bool) {
	if len(m.appendapplicable_user_types) == 0 {
		return nil, false
	}
	return m.appendapplicable_user_types, true
}

// ResetApplicableUserTypes resets all changes to the "applicable_user_types" field.
func (m *PermissionMutation) ResetApplicableUserTypes() {
	m.applicable_user_types = nil
	m.appendapplicable_user_types = nil
}

// SetApplicableContexts sets the "applicable_contexts" field.
func (m *PermissionMutation) SetApplicableContexts(mt []model.ContextType) {
	m.applicable_contexts = &mt
	m.appendapplicable_contexts = nil
}

// ApplicableContexts returns the value of the "applicable_contexts" field in the mutation.
func (m *PermissionMutation) ApplicableContexts() (r []model.ContextType, exists bool) {
	v := m.applicable_contexts
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableContexts returns the old "applicable_contexts" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldApplicableContexts(ctx context.Context) (v []model.ContextType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableContexts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableContexts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableContexts: %w", err)
	}
	return oldValue.ApplicableContexts, nil
}

// AppendApplicableContexts adds mt to the "applicable_contexts" field.
func (m *PermissionMutation) AppendApplicableContexts(mt []model.ContextType) {
	m.appendapplicable_contexts = append(m.appendapplicable_contexts, mt...)
}

// AppendedApplicableContexts returns the list of values that were appended to the "applicable_contexts" field in this mutation.
func (m *PermissionMutation) AppendedApplicableContexts() ([]model.ContextType, bool) {
	if len(m.appendapplicable_contexts) == 0 {
		return nil, false
	}
	return m.appendapplicable_contexts, true
}

// ResetApplicableContexts resets all changes to the "applicable_contexts" field.
func (m *PermissionMutation) ResetApplicableContexts() {
	m.applicable_contexts = nil
	m.appendapplicable_contexts = nil
}

// SetConditions sets the "conditions" field.
func (m *PermissionMutation) SetConditions(s string) {
	m.conditions = &s
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *PermissionMutation) Conditions() (r string, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldConditions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *PermissionMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[permission.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *PermissionMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[permission.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *PermissionMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, permission.FieldConditions)
}

// SetSystem sets the "system" field.
func (m *PermissionMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *PermissionMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *PermissionMutation) ResetSystem() {
	m.system = nil
}

// SetDangerous sets the "dangerous" field.
func (m *PermissionMutation) SetDangerous(b bool) {
	m.dangerous = &b
}

// Dangerous returns the value of the "dangerous" field in the mutation.
func (m *PermissionMutation) Dangerous() (r bool, exists bool) {
	v := m.dangerous
	if v == nil {
		return
	}
	return *v, true
}

// OldDangerous returns the old "dangerous" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDangerous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDangerous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDangerous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDangerous: %w", err)
	}
	return oldValue.Dangerous, nil
}

// ResetDangerous resets all changes to the "dangerous" field.
func (m *PermissionMutation) ResetDangerous() {
	m.dangerous = nil
}

// SetRiskLevel sets the "risk_level" field.
func (m *PermissionMutation) SetRiskLevel(i int) {
	m.risk_level = &i
	m.addrisk_level = nil
}

// RiskLevel returns the value of the "risk_level" field in the mutation.
func (m *PermissionMutation) RiskLevel() (r int, exists bool) {
	v := m.risk_level
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLevel returns the old "risk_level" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldRiskLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLevel: %w", err)
	}
	return oldValue.RiskLevel, nil
}

// AddRiskLevel adds i to the "risk_level" field.
func (m *PermissionMutation) AddRiskLevel(i int) {
	if m.addrisk_level != nil {
		*m.addrisk_level += i
	} else {
		m.addrisk_level = &i
	}
}

// AddedRiskLevel returns the value that was added to the "risk_level" field in this mutation.
func (m *PermissionMutation) AddedRiskLevel() (r int, exists bool) {
	v := m.addrisk_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetRiskLevel resets all changes to the "risk_level" field.
func (m *PermissionMutation) ResetRiskLevel() {
	m.risk_level = nil
	m.addrisk_level = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[permission.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, permission.FieldCreatedBy)
}

// SetActive sets the "active" field.
func (m *PermissionMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PermissionMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PermissionMutation) ResetActive() {
	m.active = nil
}

// SetPermissionGroup sets the "permission_group" field.
func (m *PermissionMutation) SetPermissionGroup(mg model.PermissionGroup) {
	m.permission_group = &mg
}

// PermissionGroup returns the value of the "permission_group" field in the mutation.
func (m *PermissionMutation) PermissionGroup() (r model.PermissionGroup, exists bool) {
	v := m.permission_group
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionGroup returns the old "permission_group" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldPermissionGroup(ctx context.Context) (v model.PermissionGroup, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionGroup: %w", err)
	}
	return oldValue.PermissionGroup, nil
}

// ClearPermissionGroup clears the value of the "permission_group" field.
func (m *PermissionMutation) ClearPermissionGroup() {
	m.permission_group = nil
	m.clearedFields[permission.FieldPermissionGroup] = struct{}{}
}

// PermissionGroupCleared returns if the "permission_group" field was cleared in this mutation.
func (m *PermissionMutation) PermissionGroupCleared() bool {
	_, ok := m.clearedFields[permission.FieldPermissionGroup]
	return ok
}

// ResetPermissionGroup resets all changes to the "permission_group" field.
func (m *PermissionMutation) ResetPermissionGroup() {
	m.permission_group = nil
	delete(m.clearedFields, permission.FieldPermissionGroup)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...xid.ID) {
	if m.roles == nil {
		m.roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...xid.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []xid.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []xid.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUserAssignmentIDs adds the "user_assignments" edge to the UserPermission entity by ids.
func (m *PermissionMutation) AddUserAssignmentIDs(ids ...xid.ID) {
	if m.user_assignments == nil {
		m.user_assignments = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.user_assignments[ids[i]] = struct{}{}
	}
}

// ClearUserAssignments clears the "user_assignments" edge to the UserPermission entity.
func (m *PermissionMutation) ClearUserAssignments() {
	m.cleareduser_assignments = true
}

// UserAssignmentsCleared reports if the "user_assignments" edge to the UserPermission entity was cleared.
func (m *PermissionMutation) UserAssignmentsCleared() bool {
	return m.cleareduser_assignments
}

// RemoveUserAssignmentIDs removes the "user_assignments" edge to the UserPermission entity by IDs.
func (m *PermissionMutation) RemoveUserAssignmentIDs(ids ...xid.ID) {
	if m.removeduser_assignments == nil {
		m.removeduser_assignments = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.user_assignments, ids[i])
		m.removeduser_assignments[ids[i]] = struct{}{}
	}
}

// RemovedUserAssignments returns the removed IDs of the "user_assignments" edge to the UserPermission entity.
func (m *PermissionMutation) RemovedUserAssignmentsIDs() (ids []xid.ID) {
	for id := range m.removeduser_assignments {
		ids = append(ids, id)
	}
	return
}

// UserAssignmentsIDs returns the "user_assignments" edge IDs in the mutation.
func (m *PermissionMutation) UserAssignmentsIDs() (ids []xid.ID) {
	for id := range m.user_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetUserAssignments resets all changes to the "user_assignments" edge.
func (m *PermissionMutation) ResetUserAssignments() {
	m.user_assignments = nil
	m.cleareduser_assignments = false
	m.removeduser_assignments = nil
}

// AddDependencyIDs adds the "dependencies" edge to the PermissionDependency entity by ids.
func (m *PermissionMutation) AddDependencyIDs(ids ...xid.ID) {
	if m.dependencies == nil {
		m.dependencies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the PermissionDependency entity.
func (m *PermissionMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the PermissionDependency entity was cleared.
func (m *PermissionMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the PermissionDependency entity by IDs.
func (m *PermissionMutation) RemoveDependencyIDs(ids ...xid.ID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the PermissionDependency entity.
func (m *PermissionMutation) RemovedDependenciesIDs() (ids []xid.ID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *PermissionMutation) DependenciesIDs() (ids []xid.ID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *PermissionMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// AddDependentIDs adds the "dependents" edge to the PermissionDependency entity by ids.
func (m *PermissionMutation) AddDependentIDs(ids ...xid.ID) {
	if m.dependents == nil {
		m.dependents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.dependents[ids[i]] = struct{}{}
	}
}

// ClearDependents clears the "dependents" edge to the PermissionDependency entity.
func (m *PermissionMutation) ClearDependents() {
	m.cleareddependents = true
}

// DependentsCleared reports if the "dependents" edge to the PermissionDependency entity was cleared.
func (m *PermissionMutation) DependentsCleared() bool {
	return m.cleareddependents
}

// RemoveDependentIDs removes the "dependents" edge to the PermissionDependency entity by IDs.
func (m *PermissionMutation) RemoveDependentIDs(ids ...xid.ID) {
	if m.removeddependents == nil {
		m.removeddependents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.dependents, ids[i])
		m.removeddependents[ids[i]] = struct{}{}
	}
}

// RemovedDependents returns the removed IDs of the "dependents" edge to the PermissionDependency entity.
func (m *PermissionMutation) RemovedDependentsIDs() (ids []xid.ID) {
	for id := range m.removeddependents {
		ids = append(ids, id)
	}
	return
}

// DependentsIDs returns the "dependents" edge IDs in the mutation.
func (m *PermissionMutation) DependentsIDs() (ids []xid.ID) {
	for id := range m.dependents {
		ids = append(ids, id)
	}
	return
}

// ResetDependents resets all changes to the "dependents" edge.
func (m *PermissionMutation) ResetDependents() {
	m.dependents = nil
	m.cleareddependents = false
	m.removeddependents = nil
}

// AddDependentPermissionIDs adds the "dependent_permissions" edge to the Permission entity by ids.
func (m *PermissionMutation) AddDependentPermissionIDs(ids ...xid.ID) {
	if m.dependent_permissions == nil {
		m.dependent_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.dependent_permissions[ids[i]] = struct{}{}
	}
}

// ClearDependentPermissions clears the "dependent_permissions" edge to the Permission entity.
func (m *PermissionMutation) ClearDependentPermissions() {
	m.cleareddependent_permissions = true
}

// DependentPermissionsCleared reports if the "dependent_permissions" edge to the Permission entity was cleared.
func (m *PermissionMutation) DependentPermissionsCleared() bool {
	return m.cleareddependent_permissions
}

// RemoveDependentPermissionIDs removes the "dependent_permissions" edge to the Permission entity by IDs.
func (m *PermissionMutation) RemoveDependentPermissionIDs(ids ...xid.ID) {
	if m.removeddependent_permissions == nil {
		m.removeddependent_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.dependent_permissions, ids[i])
		m.removeddependent_permissions[ids[i]] = struct{}{}
	}
}

// RemovedDependentPermissions returns the removed IDs of the "dependent_permissions" edge to the Permission entity.
func (m *PermissionMutation) RemovedDependentPermissionsIDs() (ids []xid.ID) {
	for id := range m.removeddependent_permissions {
		ids = append(ids, id)
	}
	return
}

// DependentPermissionsIDs returns the "dependent_permissions" edge IDs in the mutation.
func (m *PermissionMutation) DependentPermissionsIDs() (ids []xid.ID) {
	for id := range m.dependent_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetDependentPermissions resets all changes to the "dependent_permissions" edge.
func (m *PermissionMutation) ResetDependentPermissions() {
	m.dependent_permissions = nil
	m.cleareddependent_permissions = false
	m.removeddependent_permissions = nil
}

// AddRequiredPermissionIDs adds the "required_permissions" edge to the Permission entity by ids.
func (m *PermissionMutation) AddRequiredPermissionIDs(ids ...xid.ID) {
	if m.required_permissions == nil {
		m.required_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.required_permissions[ids[i]] = struct{}{}
	}
}

// ClearRequiredPermissions clears the "required_permissions" edge to the Permission entity.
func (m *PermissionMutation) ClearRequiredPermissions() {
	m.clearedrequired_permissions = true
}

// RequiredPermissionsCleared reports if the "required_permissions" edge to the Permission entity was cleared.
func (m *PermissionMutation) RequiredPermissionsCleared() bool {
	return m.clearedrequired_permissions
}

// RemoveRequiredPermissionIDs removes the "required_permissions" edge to the Permission entity by IDs.
func (m *PermissionMutation) RemoveRequiredPermissionIDs(ids ...xid.ID) {
	if m.removedrequired_permissions == nil {
		m.removedrequired_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.required_permissions, ids[i])
		m.removedrequired_permissions[ids[i]] = struct{}{}
	}
}

// RemovedRequiredPermissions returns the removed IDs of the "required_permissions" edge to the Permission entity.
func (m *PermissionMutation) RemovedRequiredPermissionsIDs() (ids []xid.ID) {
	for id := range m.removedrequired_permissions {
		ids = append(ids, id)
	}
	return
}

// RequiredPermissionsIDs returns the "required_permissions" edge IDs in the mutation.
func (m *PermissionMutation) RequiredPermissionsIDs() (ids []xid.ID) {
	for id := range m.required_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetRequiredPermissions resets all changes to the "required_permissions" edge.
func (m *PermissionMutation) ResetRequiredPermissions() {
	m.required_permissions = nil
	m.clearedrequired_permissions = false
	m.removedrequired_permissions = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, permission.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.resource != nil {
		fields = append(fields, permission.FieldResource)
	}
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	if m.category != nil {
		fields = append(fields, permission.FieldCategory)
	}
	if m.applicable_user_types != nil {
		fields = append(fields, permission.FieldApplicableUserTypes)
	}
	if m.applicable_contexts != nil {
		fields = append(fields, permission.FieldApplicableContexts)
	}
	if m.conditions != nil {
		fields = append(fields, permission.FieldConditions)
	}
	if m.system != nil {
		fields = append(fields, permission.FieldSystem)
	}
	if m.dangerous != nil {
		fields = append(fields, permission.FieldDangerous)
	}
	if m.risk_level != nil {
		fields = append(fields, permission.FieldRiskLevel)
	}
	if m.created_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.active != nil {
		fields = append(fields, permission.FieldActive)
	}
	if m.permission_group != nil {
		fields = append(fields, permission.FieldPermissionGroup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldName:
		return m.Name()
	case permission.FieldDisplayName:
		return m.DisplayName()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldResource:
		return m.Resource()
	case permission.FieldAction:
		return m.Action()
	case permission.FieldCategory:
		return m.Category()
	case permission.FieldApplicableUserTypes:
		return m.ApplicableUserTypes()
	case permission.FieldApplicableContexts:
		return m.ApplicableContexts()
	case permission.FieldConditions:
		return m.Conditions()
	case permission.FieldSystem:
		return m.System()
	case permission.FieldDangerous:
		return m.Dangerous()
	case permission.FieldRiskLevel:
		return m.RiskLevel()
	case permission.FieldCreatedBy:
		return m.CreatedBy()
	case permission.FieldActive:
		return m.Active()
	case permission.FieldPermissionGroup:
		return m.PermissionGroup()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldResource:
		return m.OldResource(ctx)
	case permission.FieldAction:
		return m.OldAction(ctx)
	case permission.FieldCategory:
		return m.OldCategory(ctx)
	case permission.FieldApplicableUserTypes:
		return m.OldApplicableUserTypes(ctx)
	case permission.FieldApplicableContexts:
		return m.OldApplicableContexts(ctx)
	case permission.FieldConditions:
		return m.OldConditions(ctx)
	case permission.FieldSystem:
		return m.OldSystem(ctx)
	case permission.FieldDangerous:
		return m.OldDangerous(ctx)
	case permission.FieldRiskLevel:
		return m.OldRiskLevel(ctx)
	case permission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permission.FieldActive:
		return m.OldActive(ctx)
	case permission.FieldPermissionGroup:
		return m.OldPermissionGroup(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permission.FieldCategory:
		v, ok := value.(model.PermissionCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case permission.FieldApplicableUserTypes:
		v, ok := value.([]model.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableUserTypes(v)
		return nil
	case permission.FieldApplicableContexts:
		v, ok := value.([]model.ContextType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableContexts(v)
		return nil
	case permission.FieldConditions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case permission.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case permission.FieldDangerous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDangerous(v)
		return nil
	case permission.FieldRiskLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLevel(v)
		return nil
	case permission.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permission.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case permission.FieldPermissionGroup:
		v, ok := value.(model.PermissionGroup)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionGroup(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addrisk_level != nil {
		fields = append(fields, permission.FieldRiskLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldRiskLevel:
		return m.AddedRiskLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldRiskLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRiskLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.FieldCleared(permission.FieldDisplayName) {
		fields = append(fields, permission.FieldDisplayName)
	}
	if m.FieldCleared(permission.FieldConditions) {
		fields = append(fields, permission.FieldConditions)
	}
	if m.FieldCleared(permission.FieldCreatedBy) {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.FieldCleared(permission.FieldPermissionGroup) {
		fields = append(fields, permission.FieldPermissionGroup)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permission.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case permission.FieldConditions:
		m.ClearConditions()
		return nil
	case permission.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case permission.FieldPermissionGroup:
		m.ClearPermissionGroup()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldResource:
		m.ResetResource()
		return nil
	case permission.FieldAction:
		m.ResetAction()
		return nil
	case permission.FieldCategory:
		m.ResetCategory()
		return nil
	case permission.FieldApplicableUserTypes:
		m.ResetApplicableUserTypes()
		return nil
	case permission.FieldApplicableContexts:
		m.ResetApplicableContexts()
		return nil
	case permission.FieldConditions:
		m.ResetConditions()
		return nil
	case permission.FieldSystem:
		m.ResetSystem()
		return nil
	case permission.FieldDangerous:
		m.ResetDangerous()
		return nil
	case permission.FieldRiskLevel:
		m.ResetRiskLevel()
		return nil
	case permission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permission.FieldActive:
		m.ResetActive()
		return nil
	case permission.FieldPermissionGroup:
		m.ResetPermissionGroup()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	if m.user_assignments != nil {
		edges = append(edges, permission.EdgeUserAssignments)
	}
	if m.dependencies != nil {
		edges = append(edges, permission.EdgeDependencies)
	}
	if m.dependents != nil {
		edges = append(edges, permission.EdgeDependents)
	}
	if m.dependent_permissions != nil {
		edges = append(edges, permission.EdgeDependentPermissions)
	}
	if m.required_permissions != nil {
		edges = append(edges, permission.EdgeRequiredPermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.user_assignments))
		for id := range m.user_assignments {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.dependents))
		for id := range m.dependents {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDependentPermissions:
		ids := make([]ent.Value, 0, len(m.dependent_permissions))
		for id := range m.dependent_permissions {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeRequiredPermissions:
		ids := make([]ent.Value, 0, len(m.required_permissions))
		for id := range m.required_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	if m.removeduser_assignments != nil {
		edges = append(edges, permission.EdgeUserAssignments)
	}
	if m.removeddependencies != nil {
		edges = append(edges, permission.EdgeDependencies)
	}
	if m.removeddependents != nil {
		edges = append(edges, permission.EdgeDependents)
	}
	if m.removeddependent_permissions != nil {
		edges = append(edges, permission.EdgeDependentPermissions)
	}
	if m.removedrequired_permissions != nil {
		edges = append(edges, permission.EdgeRequiredPermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.removeduser_assignments))
		for id := range m.removeduser_assignments {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.removeddependents))
		for id := range m.removeddependents {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDependentPermissions:
		ids := make([]ent.Value, 0, len(m.removeddependent_permissions))
		for id := range m.removeddependent_permissions {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeRequiredPermissions:
		ids := make([]ent.Value, 0, len(m.removedrequired_permissions))
		for id := range m.removedrequired_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	if m.cleareduser_assignments {
		edges = append(edges, permission.EdgeUserAssignments)
	}
	if m.cleareddependencies {
		edges = append(edges, permission.EdgeDependencies)
	}
	if m.cleareddependents {
		edges = append(edges, permission.EdgeDependents)
	}
	if m.cleareddependent_permissions {
		edges = append(edges, permission.EdgeDependentPermissions)
	}
	if m.clearedrequired_permissions {
		edges = append(edges, permission.EdgeRequiredPermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	case permission.EdgeUserAssignments:
		return m.cleareduser_assignments
	case permission.EdgeDependencies:
		return m.cleareddependencies
	case permission.EdgeDependents:
		return m.cleareddependents
	case permission.EdgeDependentPermissions:
		return m.cleareddependent_permissions
	case permission.EdgeRequiredPermissions:
		return m.clearedrequired_permissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	case permission.EdgeUserAssignments:
		m.ResetUserAssignments()
		return nil
	case permission.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case permission.EdgeDependents:
		m.ResetDependents()
		return nil
	case permission.EdgeDependentPermissions:
		m.ResetDependentPermissions()
		return nil
	case permission.EdgeRequiredPermissions:
		m.ResetRequiredPermissions()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// PermissionDependencyMutation represents an operation that mutates the PermissionDependency nodes in the graph.
type PermissionDependencyMutation struct {
	config
	op                         Op
	typ                        string
	id                         *xid.ID
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	dependency_type            *permissiondependency.DependencyType
	condition                  *string
	active                     *bool
	created_by                 *string
	clearedFields              map[string]struct{}
	permission                 *xid.ID
	clearedpermission          bool
	required_permission        *xid.ID
	clearedrequired_permission bool
	done                       bool
	oldValue                   func(context.Context) (*PermissionDependency, error)
	predicates                 []predicate.PermissionDependency
}

var _ ent.Mutation = (*PermissionDependencyMutation)(nil)

// permissiondependencyOption allows management of the mutation configuration using functional options.
type permissiondependencyOption func(*PermissionDependencyMutation)

// newPermissionDependencyMutation creates new mutation for the PermissionDependency entity.
func newPermissionDependencyMutation(c config, op Op, opts ...permissiondependencyOption) *PermissionDependencyMutation {
	m := &PermissionDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionDependencyID sets the ID field of the mutation.
func withPermissionDependencyID(id xid.ID) permissiondependencyOption {
	return func(m *PermissionDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionDependency
		)
		m.oldValue = func(ctx context.Context) (*PermissionDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionDependency sets the old PermissionDependency of the mutation.
func withPermissionDependency(node *PermissionDependency) permissiondependencyOption {
	return func(m *PermissionDependencyMutation) {
		m.oldValue = func(context.Context) (*PermissionDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionDependency entities.
func (m *PermissionDependencyMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionDependencyMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionDependencyMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionDependencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionDependencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionDependencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionDependencyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionDependencyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionDependencyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permissiondependency.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionDependencyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permissiondependency.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionDependencyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permissiondependency.FieldDeletedAt)
}

// SetPermissionID sets the "permission_id" field.
func (m *PermissionDependencyMutation) SetPermissionID(x xid.ID) {
	m.permission = &x
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *PermissionDependencyMutation) PermissionID() (r xid.ID, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldPermissionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *PermissionDependencyMutation) ResetPermissionID() {
	m.permission = nil
}

// SetRequiredPermissionID sets the "required_permission_id" field.
func (m *PermissionDependencyMutation) SetRequiredPermissionID(x xid.ID) {
	m.required_permission = &x
}

// RequiredPermissionID returns the value of the "required_permission_id" field in the mutation.
func (m *PermissionDependencyMutation) RequiredPermissionID() (r xid.ID, exists bool) {
	v := m.required_permission
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredPermissionID returns the old "required_permission_id" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldRequiredPermissionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredPermissionID: %w", err)
	}
	return oldValue.RequiredPermissionID, nil
}

// ResetRequiredPermissionID resets all changes to the "required_permission_id" field.
func (m *PermissionDependencyMutation) ResetRequiredPermissionID() {
	m.required_permission = nil
}

// SetDependencyType sets the "dependency_type" field.
func (m *PermissionDependencyMutation) SetDependencyType(pt permissiondependency.DependencyType) {
	m.dependency_type = &pt
}

// DependencyType returns the value of the "dependency_type" field in the mutation.
func (m *PermissionDependencyMutation) DependencyType() (r permissiondependency.DependencyType, exists bool) {
	v := m.dependency_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyType returns the old "dependency_type" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldDependencyType(ctx context.Context) (v permissiondependency.DependencyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyType: %w", err)
	}
	return oldValue.DependencyType, nil
}

// ResetDependencyType resets all changes to the "dependency_type" field.
func (m *PermissionDependencyMutation) ResetDependencyType() {
	m.dependency_type = nil
}

// SetCondition sets the "condition" field.
func (m *PermissionDependencyMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *PermissionDependencyMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldCondition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ClearCondition clears the value of the "condition" field.
func (m *PermissionDependencyMutation) ClearCondition() {
	m.condition = nil
	m.clearedFields[permissiondependency.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *PermissionDependencyMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[permissiondependency.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *PermissionDependencyMutation) ResetCondition() {
	m.condition = nil
	delete(m.clearedFields, permissiondependency.FieldCondition)
}

// SetActive sets the "active" field.
func (m *PermissionDependencyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PermissionDependencyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PermissionDependencyMutation) ResetActive() {
	m.active = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionDependencyMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionDependencyMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PermissionDependency entity.
// If the PermissionDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionDependencyMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PermissionDependencyMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[permissiondependency.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PermissionDependencyMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[permissiondependency.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionDependencyMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, permissiondependency.FieldCreatedBy)
}

// ClearPermission clears the "permission" edge to the Permission entity.
func (m *PermissionDependencyMutation) ClearPermission() {
	m.clearedpermission = true
	m.clearedFields[permissiondependency.FieldPermissionID] = struct{}{}
}

// PermissionCleared reports if the "permission" edge to the Permission entity was cleared.
func (m *PermissionDependencyMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *PermissionDependencyMutation) PermissionIDs() (ids []xid.ID) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *PermissionDependencyMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// ClearRequiredPermission clears the "required_permission" edge to the Permission entity.
func (m *PermissionDependencyMutation) ClearRequiredPermission() {
	m.clearedrequired_permission = true
	m.clearedFields[permissiondependency.FieldRequiredPermissionID] = struct{}{}
}

// RequiredPermissionCleared reports if the "required_permission" edge to the Permission entity was cleared.
func (m *PermissionDependencyMutation) RequiredPermissionCleared() bool {
	return m.clearedrequired_permission
}

// RequiredPermissionIDs returns the "required_permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequiredPermissionID instead. It exists only for internal usage by the builders.
func (m *PermissionDependencyMutation) RequiredPermissionIDs() (ids []xid.ID) {
	if id := m.required_permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequiredPermission resets all changes to the "required_permission" edge.
func (m *PermissionDependencyMutation) ResetRequiredPermission() {
	m.required_permission = nil
	m.clearedrequired_permission = false
}

// Where appends a list predicates to the PermissionDependencyMutation builder.
func (m *PermissionDependencyMutation) Where(ps ...predicate.PermissionDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionDependency).
func (m *PermissionDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionDependencyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, permissiondependency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permissiondependency.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permissiondependency.FieldDeletedAt)
	}
	if m.permission != nil {
		fields = append(fields, permissiondependency.FieldPermissionID)
	}
	if m.required_permission != nil {
		fields = append(fields, permissiondependency.FieldRequiredPermissionID)
	}
	if m.dependency_type != nil {
		fields = append(fields, permissiondependency.FieldDependencyType)
	}
	if m.condition != nil {
		fields = append(fields, permissiondependency.FieldCondition)
	}
	if m.active != nil {
		fields = append(fields, permissiondependency.FieldActive)
	}
	if m.created_by != nil {
		fields = append(fields, permissiondependency.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissiondependency.FieldCreatedAt:
		return m.CreatedAt()
	case permissiondependency.FieldUpdatedAt:
		return m.UpdatedAt()
	case permissiondependency.FieldDeletedAt:
		return m.DeletedAt()
	case permissiondependency.FieldPermissionID:
		return m.PermissionID()
	case permissiondependency.FieldRequiredPermissionID:
		return m.RequiredPermissionID()
	case permissiondependency.FieldDependencyType:
		return m.DependencyType()
	case permissiondependency.FieldCondition:
		return m.Condition()
	case permissiondependency.FieldActive:
		return m.Active()
	case permissiondependency.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissiondependency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissiondependency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permissiondependency.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permissiondependency.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case permissiondependency.FieldRequiredPermissionID:
		return m.OldRequiredPermissionID(ctx)
	case permissiondependency.FieldDependencyType:
		return m.OldDependencyType(ctx)
	case permissiondependency.FieldCondition:
		return m.OldCondition(ctx)
	case permissiondependency.FieldActive:
		return m.OldActive(ctx)
	case permissiondependency.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissiondependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissiondependency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permissiondependency.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permissiondependency.FieldPermissionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case permissiondependency.FieldRequiredPermissionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredPermissionID(v)
		return nil
	case permissiondependency.FieldDependencyType:
		v, ok := value.(permissiondependency.DependencyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyType(v)
		return nil
	case permissiondependency.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case permissiondependency.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case permissiondependency.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PermissionDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionDependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissiondependency.FieldDeletedAt) {
		fields = append(fields, permissiondependency.FieldDeletedAt)
	}
	if m.FieldCleared(permissiondependency.FieldCondition) {
		fields = append(fields, permissiondependency.FieldCondition)
	}
	if m.FieldCleared(permissiondependency.FieldCreatedBy) {
		fields = append(fields, permissiondependency.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionDependencyMutation) ClearField(name string) error {
	switch name {
	case permissiondependency.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permissiondependency.FieldCondition:
		m.ClearCondition()
		return nil
	case permissiondependency.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown PermissionDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionDependencyMutation) ResetField(name string) error {
	switch name {
	case permissiondependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissiondependency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permissiondependency.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permissiondependency.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case permissiondependency.FieldRequiredPermissionID:
		m.ResetRequiredPermissionID()
		return nil
	case permissiondependency.FieldDependencyType:
		m.ResetDependencyType()
		return nil
	case permissiondependency.FieldCondition:
		m.ResetCondition()
		return nil
	case permissiondependency.FieldActive:
		m.ResetActive()
		return nil
	case permissiondependency.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown PermissionDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.permission != nil {
		edges = append(edges, permissiondependency.EdgePermission)
	}
	if m.required_permission != nil {
		edges = append(edges, permissiondependency.EdgeRequiredPermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permissiondependency.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	case permissiondependency.EdgeRequiredPermission:
		if id := m.required_permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpermission {
		edges = append(edges, permissiondependency.EdgePermission)
	}
	if m.clearedrequired_permission {
		edges = append(edges, permissiondependency.EdgeRequiredPermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case permissiondependency.EdgePermission:
		return m.clearedpermission
	case permissiondependency.EdgeRequiredPermission:
		return m.clearedrequired_permission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionDependencyMutation) ClearEdge(name string) error {
	switch name {
	case permissiondependency.EdgePermission:
		m.ClearPermission()
		return nil
	case permissiondependency.EdgeRequiredPermission:
		m.ClearRequiredPermission()
		return nil
	}
	return fmt.Errorf("unknown PermissionDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionDependencyMutation) ResetEdge(name string) error {
	switch name {
	case permissiondependency.EdgePermission:
		m.ResetPermission()
		return nil
	case permissiondependency.EdgeRequiredPermission:
		m.ResetRequiredPermission()
		return nil
	}
	return fmt.Errorf("unknown PermissionDependency edge %s", name)
}

// ProviderTemplateMutation represents an operation that mutates the ProviderTemplate nodes in the graph.
type ProviderTemplateMutation struct {
	config
	op                            Op
	typ                           string
	id                            *xid.ID
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	key                           *string
	name                          *string
	display_name                  *string
	_type                         *string
	protocol                      *string
	icon_url                      *string
	category                      *string
	popular                       *bool
	active                        *bool
	description                   *string
	config_template               *map[string]interface{}
	required_fields               *[]string
	appendrequired_fields         []string
	supported_features            *[]string
	appendsupported_features      []string
	documentation_url             *string
	setup_guide_url               *string
	usage_count                   *int
	addusage_count                *int
	average_setup_time            *float64
	addaverage_setup_time         *float64
	success_rate                  *float64
	addsuccess_rate               *float64
	popularity_rank               *int
	addpopularity_rank            *int
	metadata                      *map[string]interface{}
	clearedFields                 map[string]struct{}
	organization_providers        map[xid.ID]struct{}
	removedorganization_providers map[xid.ID]struct{}
	clearedorganization_providers bool
	done                          bool
	oldValue                      func(context.Context) (*ProviderTemplate, error)
	predicates                    []predicate.ProviderTemplate
}

var _ ent.Mutation = (*ProviderTemplateMutation)(nil)

// providertemplateOption allows management of the mutation configuration using functional options.
type providertemplateOption func(*ProviderTemplateMutation)

// newProviderTemplateMutation creates new mutation for the ProviderTemplate entity.
func newProviderTemplateMutation(c config, op Op, opts ...providertemplateOption) *ProviderTemplateMutation {
	m := &ProviderTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderTemplateID sets the ID field of the mutation.
func withProviderTemplateID(id xid.ID) providertemplateOption {
	return func(m *ProviderTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderTemplate
		)
		m.oldValue = func(ctx context.Context) (*ProviderTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderTemplate sets the old ProviderTemplate of the mutation.
func withProviderTemplate(node *ProviderTemplate) providertemplateOption {
	return func(m *ProviderTemplateMutation) {
		m.oldValue = func(context.Context) (*ProviderTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProviderTemplate entities.
func (m *ProviderTemplateMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderTemplateMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderTemplateMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProviderTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProviderTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProviderTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProviderTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProviderTemplateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProviderTemplateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProviderTemplateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[providertemplate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProviderTemplateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProviderTemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, providertemplate.FieldDeletedAt)
}

// SetKey sets the "key" field.
func (m *ProviderTemplateMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ProviderTemplateMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ProviderTemplateMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *ProviderTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderTemplateMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ProviderTemplateMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProviderTemplateMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProviderTemplateMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetType sets the "type" field.
func (m *ProviderTemplateMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProviderTemplateMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProviderTemplateMutation) ResetType() {
	m._type = nil
}

// SetProtocol sets the "protocol" field.
func (m *ProviderTemplateMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *ProviderTemplateMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *ProviderTemplateMutation) ResetProtocol() {
	m.protocol = nil
}

// SetIconURL sets the "icon_url" field.
func (m *ProviderTemplateMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *ProviderTemplateMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *ProviderTemplateMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[providertemplate.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *ProviderTemplateMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *ProviderTemplateMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, providertemplate.FieldIconURL)
}

// SetCategory sets the "category" field.
func (m *ProviderTemplateMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProviderTemplateMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProviderTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetPopular sets the "popular" field.
func (m *ProviderTemplateMutation) SetPopular(b bool) {
	m.popular = &b
}

// Popular returns the value of the "popular" field in the mutation.
func (m *ProviderTemplateMutation) Popular() (r bool, exists bool) {
	v := m.popular
	if v == nil {
		return
	}
	return *v, true
}

// OldPopular returns the old "popular" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldPopular(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopular is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopular requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopular: %w", err)
	}
	return oldValue.Popular, nil
}

// ResetPopular resets all changes to the "popular" field.
func (m *ProviderTemplateMutation) ResetPopular() {
	m.popular = nil
}

// SetActive sets the "active" field.
func (m *ProviderTemplateMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ProviderTemplateMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ProviderTemplateMutation) ResetActive() {
	m.active = nil
}

// SetDescription sets the "description" field.
func (m *ProviderTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProviderTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProviderTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[providertemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProviderTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProviderTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, providertemplate.FieldDescription)
}

// SetConfigTemplate sets the "config_template" field.
func (m *ProviderTemplateMutation) SetConfigTemplate(value map[string]interface{}) {
	m.config_template = &value
}

// ConfigTemplate returns the value of the "config_template" field in the mutation.
func (m *ProviderTemplateMutation) ConfigTemplate() (r map[string]interface{}, exists bool) {
	v := m.config_template
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigTemplate returns the old "config_template" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldConfigTemplate(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigTemplate: %w", err)
	}
	return oldValue.ConfigTemplate, nil
}

// ResetConfigTemplate resets all changes to the "config_template" field.
func (m *ProviderTemplateMutation) ResetConfigTemplate() {
	m.config_template = nil
}

// SetRequiredFields sets the "required_fields" field.
func (m *ProviderTemplateMutation) SetRequiredFields(s []string) {
	m.required_fields = &s
	m.appendrequired_fields = nil
}

// RequiredFields returns the value of the "required_fields" field in the mutation.
func (m *ProviderTemplateMutation) RequiredFields() (r []string, exists bool) {
	v := m.required_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredFields returns the old "required_fields" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldRequiredFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredFields: %w", err)
	}
	return oldValue.RequiredFields, nil
}

// AppendRequiredFields adds s to the "required_fields" field.
func (m *ProviderTemplateMutation) AppendRequiredFields(s []string) {
	m.appendrequired_fields = append(m.appendrequired_fields, s...)
}

// AppendedRequiredFields returns the list of values that were appended to the "required_fields" field in this mutation.
func (m *ProviderTemplateMutation) AppendedRequiredFields() ([]string, bool) {
	if len(m.appendrequired_fields) == 0 {
		return nil, false
	}
	return m.appendrequired_fields, true
}

// ClearRequiredFields clears the value of the "required_fields" field.
func (m *ProviderTemplateMutation) ClearRequiredFields() {
	m.required_fields = nil
	m.appendrequired_fields = nil
	m.clearedFields[providertemplate.FieldRequiredFields] = struct{}{}
}

// RequiredFieldsCleared returns if the "required_fields" field was cleared in this mutation.
func (m *ProviderTemplateMutation) RequiredFieldsCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldRequiredFields]
	return ok
}

// ResetRequiredFields resets all changes to the "required_fields" field.
func (m *ProviderTemplateMutation) ResetRequiredFields() {
	m.required_fields = nil
	m.appendrequired_fields = nil
	delete(m.clearedFields, providertemplate.FieldRequiredFields)
}

// SetSupportedFeatures sets the "supported_features" field.
func (m *ProviderTemplateMutation) SetSupportedFeatures(s []string) {
	m.supported_features = &s
	m.appendsupported_features = nil
}

// SupportedFeatures returns the value of the "supported_features" field in the mutation.
func (m *ProviderTemplateMutation) SupportedFeatures() (r []string, exists bool) {
	v := m.supported_features
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedFeatures returns the old "supported_features" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldSupportedFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedFeatures: %w", err)
	}
	return oldValue.SupportedFeatures, nil
}

// AppendSupportedFeatures adds s to the "supported_features" field.
func (m *ProviderTemplateMutation) AppendSupportedFeatures(s []string) {
	m.appendsupported_features = append(m.appendsupported_features, s...)
}

// AppendedSupportedFeatures returns the list of values that were appended to the "supported_features" field in this mutation.
func (m *ProviderTemplateMutation) AppendedSupportedFeatures() ([]string, bool) {
	if len(m.appendsupported_features) == 0 {
		return nil, false
	}
	return m.appendsupported_features, true
}

// ClearSupportedFeatures clears the value of the "supported_features" field.
func (m *ProviderTemplateMutation) ClearSupportedFeatures() {
	m.supported_features = nil
	m.appendsupported_features = nil
	m.clearedFields[providertemplate.FieldSupportedFeatures] = struct{}{}
}

// SupportedFeaturesCleared returns if the "supported_features" field was cleared in this mutation.
func (m *ProviderTemplateMutation) SupportedFeaturesCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldSupportedFeatures]
	return ok
}

// ResetSupportedFeatures resets all changes to the "supported_features" field.
func (m *ProviderTemplateMutation) ResetSupportedFeatures() {
	m.supported_features = nil
	m.appendsupported_features = nil
	delete(m.clearedFields, providertemplate.FieldSupportedFeatures)
}

// SetDocumentationURL sets the "documentation_url" field.
func (m *ProviderTemplateMutation) SetDocumentationURL(s string) {
	m.documentation_url = &s
}

// DocumentationURL returns the value of the "documentation_url" field in the mutation.
func (m *ProviderTemplateMutation) DocumentationURL() (r string, exists bool) {
	v := m.documentation_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationURL returns the old "documentation_url" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldDocumentationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationURL: %w", err)
	}
	return oldValue.DocumentationURL, nil
}

// ClearDocumentationURL clears the value of the "documentation_url" field.
func (m *ProviderTemplateMutation) ClearDocumentationURL() {
	m.documentation_url = nil
	m.clearedFields[providertemplate.FieldDocumentationURL] = struct{}{}
}

// DocumentationURLCleared returns if the "documentation_url" field was cleared in this mutation.
func (m *ProviderTemplateMutation) DocumentationURLCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldDocumentationURL]
	return ok
}

// ResetDocumentationURL resets all changes to the "documentation_url" field.
func (m *ProviderTemplateMutation) ResetDocumentationURL() {
	m.documentation_url = nil
	delete(m.clearedFields, providertemplate.FieldDocumentationURL)
}

// SetSetupGuideURL sets the "setup_guide_url" field.
func (m *ProviderTemplateMutation) SetSetupGuideURL(s string) {
	m.setup_guide_url = &s
}

// SetupGuideURL returns the value of the "setup_guide_url" field in the mutation.
func (m *ProviderTemplateMutation) SetupGuideURL() (r string, exists bool) {
	v := m.setup_guide_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSetupGuideURL returns the old "setup_guide_url" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldSetupGuideURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetupGuideURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetupGuideURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetupGuideURL: %w", err)
	}
	return oldValue.SetupGuideURL, nil
}

// ClearSetupGuideURL clears the value of the "setup_guide_url" field.
func (m *ProviderTemplateMutation) ClearSetupGuideURL() {
	m.setup_guide_url = nil
	m.clearedFields[providertemplate.FieldSetupGuideURL] = struct{}{}
}

// SetupGuideURLCleared returns if the "setup_guide_url" field was cleared in this mutation.
func (m *ProviderTemplateMutation) SetupGuideURLCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldSetupGuideURL]
	return ok
}

// ResetSetupGuideURL resets all changes to the "setup_guide_url" field.
func (m *ProviderTemplateMutation) ResetSetupGuideURL() {
	m.setup_guide_url = nil
	delete(m.clearedFields, providertemplate.FieldSetupGuideURL)
}

// SetUsageCount sets the "usage_count" field.
func (m *ProviderTemplateMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *ProviderTemplateMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *ProviderTemplateMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *ProviderTemplateMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *ProviderTemplateMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetAverageSetupTime sets the "average_setup_time" field.
func (m *ProviderTemplateMutation) SetAverageSetupTime(f float64) {
	m.average_setup_time = &f
	m.addaverage_setup_time = nil
}

// AverageSetupTime returns the value of the "average_setup_time" field in the mutation.
func (m *ProviderTemplateMutation) AverageSetupTime() (r float64, exists bool) {
	v := m.average_setup_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageSetupTime returns the old "average_setup_time" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldAverageSetupTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageSetupTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageSetupTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageSetupTime: %w", err)
	}
	return oldValue.AverageSetupTime, nil
}

// AddAverageSetupTime adds f to the "average_setup_time" field.
func (m *ProviderTemplateMutation) AddAverageSetupTime(f float64) {
	if m.addaverage_setup_time != nil {
		*m.addaverage_setup_time += f
	} else {
		m.addaverage_setup_time = &f
	}
}

// AddedAverageSetupTime returns the value that was added to the "average_setup_time" field in this mutation.
func (m *ProviderTemplateMutation) AddedAverageSetupTime() (r float64, exists bool) {
	v := m.addaverage_setup_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearAverageSetupTime clears the value of the "average_setup_time" field.
func (m *ProviderTemplateMutation) ClearAverageSetupTime() {
	m.average_setup_time = nil
	m.addaverage_setup_time = nil
	m.clearedFields[providertemplate.FieldAverageSetupTime] = struct{}{}
}

// AverageSetupTimeCleared returns if the "average_setup_time" field was cleared in this mutation.
func (m *ProviderTemplateMutation) AverageSetupTimeCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldAverageSetupTime]
	return ok
}

// ResetAverageSetupTime resets all changes to the "average_setup_time" field.
func (m *ProviderTemplateMutation) ResetAverageSetupTime() {
	m.average_setup_time = nil
	m.addaverage_setup_time = nil
	delete(m.clearedFields, providertemplate.FieldAverageSetupTime)
}

// SetSuccessRate sets the "success_rate" field.
func (m *ProviderTemplateMutation) SetSuccessRate(f float64) {
	m.success_rate = &f
	m.addsuccess_rate = nil
}

// SuccessRate returns the value of the "success_rate" field in the mutation.
func (m *ProviderTemplateMutation) SuccessRate() (r float64, exists bool) {
	v := m.success_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessRate returns the old "success_rate" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldSuccessRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessRate: %w", err)
	}
	return oldValue.SuccessRate, nil
}

// AddSuccessRate adds f to the "success_rate" field.
func (m *ProviderTemplateMutation) AddSuccessRate(f float64) {
	if m.addsuccess_rate != nil {
		*m.addsuccess_rate += f
	} else {
		m.addsuccess_rate = &f
	}
}

// AddedSuccessRate returns the value that was added to the "success_rate" field in this mutation.
func (m *ProviderTemplateMutation) AddedSuccessRate() (r float64, exists bool) {
	v := m.addsuccess_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessRate resets all changes to the "success_rate" field.
func (m *ProviderTemplateMutation) ResetSuccessRate() {
	m.success_rate = nil
	m.addsuccess_rate = nil
}

// SetPopularityRank sets the "popularity_rank" field.
func (m *ProviderTemplateMutation) SetPopularityRank(i int) {
	m.popularity_rank = &i
	m.addpopularity_rank = nil
}

// PopularityRank returns the value of the "popularity_rank" field in the mutation.
func (m *ProviderTemplateMutation) PopularityRank() (r int, exists bool) {
	v := m.popularity_rank
	if v == nil {
		return
	}
	return *v, true
}

// OldPopularityRank returns the old "popularity_rank" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldPopularityRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopularityRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopularityRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopularityRank: %w", err)
	}
	return oldValue.PopularityRank, nil
}

// AddPopularityRank adds i to the "popularity_rank" field.
func (m *ProviderTemplateMutation) AddPopularityRank(i int) {
	if m.addpopularity_rank != nil {
		*m.addpopularity_rank += i
	} else {
		m.addpopularity_rank = &i
	}
}

// AddedPopularityRank returns the value that was added to the "popularity_rank" field in this mutation.
func (m *ProviderTemplateMutation) AddedPopularityRank() (r int, exists bool) {
	v := m.addpopularity_rank
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopularityRank resets all changes to the "popularity_rank" field.
func (m *ProviderTemplateMutation) ResetPopularityRank() {
	m.popularity_rank = nil
	m.addpopularity_rank = nil
}

// SetMetadata sets the "metadata" field.
func (m *ProviderTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ProviderTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ProviderTemplate entity.
// If the ProviderTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ProviderTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[providertemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ProviderTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[providertemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ProviderTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, providertemplate.FieldMetadata)
}

// AddOrganizationProviderIDs adds the "organization_providers" edge to the OrganizationProvider entity by ids.
func (m *ProviderTemplateMutation) AddOrganizationProviderIDs(ids ...xid.ID) {
	if m.organization_providers == nil {
		m.organization_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.organization_providers[ids[i]] = struct{}{}
	}
}

// ClearOrganizationProviders clears the "organization_providers" edge to the OrganizationProvider entity.
func (m *ProviderTemplateMutation) ClearOrganizationProviders() {
	m.clearedorganization_providers = true
}

// OrganizationProvidersCleared reports if the "organization_providers" edge to the OrganizationProvider entity was cleared.
func (m *ProviderTemplateMutation) OrganizationProvidersCleared() bool {
	return m.clearedorganization_providers
}

// RemoveOrganizationProviderIDs removes the "organization_providers" edge to the OrganizationProvider entity by IDs.
func (m *ProviderTemplateMutation) RemoveOrganizationProviderIDs(ids ...xid.ID) {
	if m.removedorganization_providers == nil {
		m.removedorganization_providers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.organization_providers, ids[i])
		m.removedorganization_providers[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationProviders returns the removed IDs of the "organization_providers" edge to the OrganizationProvider entity.
func (m *ProviderTemplateMutation) RemovedOrganizationProvidersIDs() (ids []xid.ID) {
	for id := range m.removedorganization_providers {
		ids = append(ids, id)
	}
	return
}

// OrganizationProvidersIDs returns the "organization_providers" edge IDs in the mutation.
func (m *ProviderTemplateMutation) OrganizationProvidersIDs() (ids []xid.ID) {
	for id := range m.organization_providers {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationProviders resets all changes to the "organization_providers" edge.
func (m *ProviderTemplateMutation) ResetOrganizationProviders() {
	m.organization_providers = nil
	m.clearedorganization_providers = false
	m.removedorganization_providers = nil
}

// Where appends a list predicates to the ProviderTemplateMutation builder.
func (m *ProviderTemplateMutation) Where(ps ...predicate.ProviderTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProviderTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProviderTemplate).
func (m *ProviderTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderTemplateMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, providertemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, providertemplate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, providertemplate.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, providertemplate.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, providertemplate.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, providertemplate.FieldDisplayName)
	}
	if m._type != nil {
		fields = append(fields, providertemplate.FieldType)
	}
	if m.protocol != nil {
		fields = append(fields, providertemplate.FieldProtocol)
	}
	if m.icon_url != nil {
		fields = append(fields, providertemplate.FieldIconURL)
	}
	if m.category != nil {
		fields = append(fields, providertemplate.FieldCategory)
	}
	if m.popular != nil {
		fields = append(fields, providertemplate.FieldPopular)
	}
	if m.active != nil {
		fields = append(fields, providertemplate.FieldActive)
	}
	if m.description != nil {
		fields = append(fields, providertemplate.FieldDescription)
	}
	if m.config_template != nil {
		fields = append(fields, providertemplate.FieldConfigTemplate)
	}
	if m.required_fields != nil {
		fields = append(fields, providertemplate.FieldRequiredFields)
	}
	if m.supported_features != nil {
		fields = append(fields, providertemplate.FieldSupportedFeatures)
	}
	if m.documentation_url != nil {
		fields = append(fields, providertemplate.FieldDocumentationURL)
	}
	if m.setup_guide_url != nil {
		fields = append(fields, providertemplate.FieldSetupGuideURL)
	}
	if m.usage_count != nil {
		fields = append(fields, providertemplate.FieldUsageCount)
	}
	if m.average_setup_time != nil {
		fields = append(fields, providertemplate.FieldAverageSetupTime)
	}
	if m.success_rate != nil {
		fields = append(fields, providertemplate.FieldSuccessRate)
	}
	if m.popularity_rank != nil {
		fields = append(fields, providertemplate.FieldPopularityRank)
	}
	if m.metadata != nil {
		fields = append(fields, providertemplate.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providertemplate.FieldCreatedAt:
		return m.CreatedAt()
	case providertemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case providertemplate.FieldDeletedAt:
		return m.DeletedAt()
	case providertemplate.FieldKey:
		return m.Key()
	case providertemplate.FieldName:
		return m.Name()
	case providertemplate.FieldDisplayName:
		return m.DisplayName()
	case providertemplate.FieldType:
		return m.GetType()
	case providertemplate.FieldProtocol:
		return m.Protocol()
	case providertemplate.FieldIconURL:
		return m.IconURL()
	case providertemplate.FieldCategory:
		return m.Category()
	case providertemplate.FieldPopular:
		return m.Popular()
	case providertemplate.FieldActive:
		return m.Active()
	case providertemplate.FieldDescription:
		return m.Description()
	case providertemplate.FieldConfigTemplate:
		return m.ConfigTemplate()
	case providertemplate.FieldRequiredFields:
		return m.RequiredFields()
	case providertemplate.FieldSupportedFeatures:
		return m.SupportedFeatures()
	case providertemplate.FieldDocumentationURL:
		return m.DocumentationURL()
	case providertemplate.FieldSetupGuideURL:
		return m.SetupGuideURL()
	case providertemplate.FieldUsageCount:
		return m.UsageCount()
	case providertemplate.FieldAverageSetupTime:
		return m.AverageSetupTime()
	case providertemplate.FieldSuccessRate:
		return m.SuccessRate()
	case providertemplate.FieldPopularityRank:
		return m.PopularityRank()
	case providertemplate.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providertemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case providertemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case providertemplate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case providertemplate.FieldKey:
		return m.OldKey(ctx)
	case providertemplate.FieldName:
		return m.OldName(ctx)
	case providertemplate.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case providertemplate.FieldType:
		return m.OldType(ctx)
	case providertemplate.FieldProtocol:
		return m.OldProtocol(ctx)
	case providertemplate.FieldIconURL:
		return m.OldIconURL(ctx)
	case providertemplate.FieldCategory:
		return m.OldCategory(ctx)
	case providertemplate.FieldPopular:
		return m.OldPopular(ctx)
	case providertemplate.FieldActive:
		return m.OldActive(ctx)
	case providertemplate.FieldDescription:
		return m.OldDescription(ctx)
	case providertemplate.FieldConfigTemplate:
		return m.OldConfigTemplate(ctx)
	case providertemplate.FieldRequiredFields:
		return m.OldRequiredFields(ctx)
	case providertemplate.FieldSupportedFeatures:
		return m.OldSupportedFeatures(ctx)
	case providertemplate.FieldDocumentationURL:
		return m.OldDocumentationURL(ctx)
	case providertemplate.FieldSetupGuideURL:
		return m.OldSetupGuideURL(ctx)
	case providertemplate.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case providertemplate.FieldAverageSetupTime:
		return m.OldAverageSetupTime(ctx)
	case providertemplate.FieldSuccessRate:
		return m.OldSuccessRate(ctx)
	case providertemplate.FieldPopularityRank:
		return m.OldPopularityRank(ctx)
	case providertemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providertemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case providertemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case providertemplate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case providertemplate.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case providertemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case providertemplate.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case providertemplate.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case providertemplate.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case providertemplate.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case providertemplate.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case providertemplate.FieldPopular:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopular(v)
		return nil
	case providertemplate.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case providertemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case providertemplate.FieldConfigTemplate:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigTemplate(v)
		return nil
	case providertemplate.FieldRequiredFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredFields(v)
		return nil
	case providertemplate.FieldSupportedFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedFeatures(v)
		return nil
	case providertemplate.FieldDocumentationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationURL(v)
		return nil
	case providertemplate.FieldSetupGuideURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetupGuideURL(v)
		return nil
	case providertemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case providertemplate.FieldAverageSetupTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageSetupTime(v)
		return nil
	case providertemplate.FieldSuccessRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessRate(v)
		return nil
	case providertemplate.FieldPopularityRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopularityRank(v)
		return nil
	case providertemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, providertemplate.FieldUsageCount)
	}
	if m.addaverage_setup_time != nil {
		fields = append(fields, providertemplate.FieldAverageSetupTime)
	}
	if m.addsuccess_rate != nil {
		fields = append(fields, providertemplate.FieldSuccessRate)
	}
	if m.addpopularity_rank != nil {
		fields = append(fields, providertemplate.FieldPopularityRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case providertemplate.FieldUsageCount:
		return m.AddedUsageCount()
	case providertemplate.FieldAverageSetupTime:
		return m.AddedAverageSetupTime()
	case providertemplate.FieldSuccessRate:
		return m.AddedSuccessRate()
	case providertemplate.FieldPopularityRank:
		return m.AddedPopularityRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case providertemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	case providertemplate.FieldAverageSetupTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageSetupTime(v)
		return nil
	case providertemplate.FieldSuccessRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessRate(v)
		return nil
	case providertemplate.FieldPopularityRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopularityRank(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(providertemplate.FieldDeletedAt) {
		fields = append(fields, providertemplate.FieldDeletedAt)
	}
	if m.FieldCleared(providertemplate.FieldIconURL) {
		fields = append(fields, providertemplate.FieldIconURL)
	}
	if m.FieldCleared(providertemplate.FieldDescription) {
		fields = append(fields, providertemplate.FieldDescription)
	}
	if m.FieldCleared(providertemplate.FieldRequiredFields) {
		fields = append(fields, providertemplate.FieldRequiredFields)
	}
	if m.FieldCleared(providertemplate.FieldSupportedFeatures) {
		fields = append(fields, providertemplate.FieldSupportedFeatures)
	}
	if m.FieldCleared(providertemplate.FieldDocumentationURL) {
		fields = append(fields, providertemplate.FieldDocumentationURL)
	}
	if m.FieldCleared(providertemplate.FieldSetupGuideURL) {
		fields = append(fields, providertemplate.FieldSetupGuideURL)
	}
	if m.FieldCleared(providertemplate.FieldAverageSetupTime) {
		fields = append(fields, providertemplate.FieldAverageSetupTime)
	}
	if m.FieldCleared(providertemplate.FieldMetadata) {
		fields = append(fields, providertemplate.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderTemplateMutation) ClearField(name string) error {
	switch name {
	case providertemplate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case providertemplate.FieldIconURL:
		m.ClearIconURL()
		return nil
	case providertemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case providertemplate.FieldRequiredFields:
		m.ClearRequiredFields()
		return nil
	case providertemplate.FieldSupportedFeatures:
		m.ClearSupportedFeatures()
		return nil
	case providertemplate.FieldDocumentationURL:
		m.ClearDocumentationURL()
		return nil
	case providertemplate.FieldSetupGuideURL:
		m.ClearSetupGuideURL()
		return nil
	case providertemplate.FieldAverageSetupTime:
		m.ClearAverageSetupTime()
		return nil
	case providertemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown ProviderTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderTemplateMutation) ResetField(name string) error {
	switch name {
	case providertemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case providertemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case providertemplate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case providertemplate.FieldKey:
		m.ResetKey()
		return nil
	case providertemplate.FieldName:
		m.ResetName()
		return nil
	case providertemplate.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case providertemplate.FieldType:
		m.ResetType()
		return nil
	case providertemplate.FieldProtocol:
		m.ResetProtocol()
		return nil
	case providertemplate.FieldIconURL:
		m.ResetIconURL()
		return nil
	case providertemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case providertemplate.FieldPopular:
		m.ResetPopular()
		return nil
	case providertemplate.FieldActive:
		m.ResetActive()
		return nil
	case providertemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case providertemplate.FieldConfigTemplate:
		m.ResetConfigTemplate()
		return nil
	case providertemplate.FieldRequiredFields:
		m.ResetRequiredFields()
		return nil
	case providertemplate.FieldSupportedFeatures:
		m.ResetSupportedFeatures()
		return nil
	case providertemplate.FieldDocumentationURL:
		m.ResetDocumentationURL()
		return nil
	case providertemplate.FieldSetupGuideURL:
		m.ResetSetupGuideURL()
		return nil
	case providertemplate.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case providertemplate.FieldAverageSetupTime:
		m.ResetAverageSetupTime()
		return nil
	case providertemplate.FieldSuccessRate:
		m.ResetSuccessRate()
		return nil
	case providertemplate.FieldPopularityRank:
		m.ResetPopularityRank()
		return nil
	case providertemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown ProviderTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization_providers != nil {
		edges = append(edges, providertemplate.EdgeOrganizationProviders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case providertemplate.EdgeOrganizationProviders:
		ids := make([]ent.Value, 0, len(m.organization_providers))
		for id := range m.organization_providers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganization_providers != nil {
		edges = append(edges, providertemplate.EdgeOrganizationProviders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case providertemplate.EdgeOrganizationProviders:
		ids := make([]ent.Value, 0, len(m.removedorganization_providers))
		for id := range m.removedorganization_providers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization_providers {
		edges = append(edges, providertemplate.EdgeOrganizationProviders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case providertemplate.EdgeOrganizationProviders:
		return m.clearedorganization_providers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProviderTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderTemplateMutation) ResetEdge(name string) error {
	switch name {
	case providertemplate.EdgeOrganizationProviders:
		m.ResetOrganizationProviders()
		return nil
	}
	return fmt.Errorf("unknown ProviderTemplate edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *xid.ID
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	name                        *string
	display_name                *string
	description                 *string
	role_type                   *model.RoleType
	application_id              *xid.ID
	system                      *bool
	is_default                  *bool
	priority                    *int
	addpriority                 *int
	color                       *string
	applicable_user_types       *[]model.UserType
	appendapplicable_user_types []model.UserType
	created_by                  *string
	active                      *bool
	clearedFields               map[string]struct{}
	organization                *xid.ID
	clearedorganization         bool
	user_assignments            map[xid.ID]struct{}
	removeduser_assignments     map[xid.ID]struct{}
	cleareduser_assignments     bool
	system_users                map[xid.ID]struct{}
	removedsystem_users         map[xid.ID]struct{}
	clearedsystem_users         bool
	permissions                 map[xid.ID]struct{}
	removedpermissions          map[xid.ID]struct{}
	clearedpermissions          bool
	memberships                 map[xid.ID]struct{}
	removedmemberships          map[xid.ID]struct{}
	clearedmemberships          bool
	parent                      *xid.ID
	clearedparent               bool
	children                    map[xid.ID]struct{}
	removedchildren             map[xid.ID]struct{}
	clearedchildren             bool
	done                        bool
	oldValue                    func(context.Context) (*Role, error)
	predicates                  []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id xid.ID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *RoleMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *RoleMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *RoleMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[role.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *RoleMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[role.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *RoleMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, role.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetRoleType sets the "role_type" field.
func (m *RoleMutation) SetRoleType(mt model.RoleType) {
	m.role_type = &mt
}

// RoleType returns the value of the "role_type" field in the mutation.
func (m *RoleMutation) RoleType() (r model.RoleType, exists bool) {
	v := m.role_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleType returns the old "role_type" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleType(ctx context.Context) (v model.RoleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleType: %w", err)
	}
	return oldValue.RoleType, nil
}

// ResetRoleType resets all changes to the "role_type" field.
func (m *RoleMutation) ResetRoleType() {
	m.role_type = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *RoleMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RoleMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *RoleMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[role.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *RoleMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[role.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RoleMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, role.FieldOrganizationID)
}

// SetApplicationID sets the "application_id" field.
func (m *RoleMutation) SetApplicationID(x xid.ID) {
	m.application_id = &x
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *RoleMutation) ApplicationID() (r xid.ID, exists bool) {
	v := m.application_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApplicationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "application_id" field.
func (m *RoleMutation) ClearApplicationID() {
	m.application_id = nil
	m.clearedFields[role.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "application_id" field was cleared in this mutation.
func (m *RoleMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[role.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *RoleMutation) ResetApplicationID() {
	m.application_id = nil
	delete(m.clearedFields, role.FieldApplicationID)
}

// SetSystem sets the "system" field.
func (m *RoleMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *RoleMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *RoleMutation) ResetSystem() {
	m.system = nil
}

// SetIsDefault sets the "is_default" field.
func (m *RoleMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *RoleMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *RoleMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetPriority sets the "priority" field.
func (m *RoleMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *RoleMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *RoleMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *RoleMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *RoleMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetColor sets the "color" field.
func (m *RoleMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *RoleMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *RoleMutation) ClearColor() {
	m.color = nil
	m.clearedFields[role.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *RoleMutation) ColorCleared() bool {
	_, ok := m.clearedFields[role.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *RoleMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, role.FieldColor)
}

// SetApplicableUserTypes sets the "applicable_user_types" field.
func (m *RoleMutation) SetApplicableUserTypes(mt []model.UserType) {
	m.applicable_user_types = &mt
	m.appendapplicable_user_types = nil
}

// ApplicableUserTypes returns the value of the "applicable_user_types" field in the mutation.
func (m *RoleMutation) ApplicableUserTypes() (r []model.UserType, exists bool) {
	v := m.applicable_user_types
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableUserTypes returns the old "applicable_user_types" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApplicableUserTypes(ctx context.Context) (v []model.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableUserTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableUserTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableUserTypes: %w", err)
	}
	return oldValue.ApplicableUserTypes, nil
}

// AppendApplicableUserTypes adds mt to the "applicable_user_types" field.
func (m *RoleMutation) AppendApplicableUserTypes(mt []model.UserType) {
	m.appendapplicable_user_types = append(m.appendapplicable_user_types, mt...)
}

// AppendedApplicableUserTypes returns the list of values that were appended to the "applicable_user_types" field in this mutation.
func (m *RoleMutation) AppendedApplicableUserTypes() ([]model.UserType, bool) {
	if len(m.appendapplicable_user_types) == 0 {
		return nil, false
	}
	return m.appendapplicable_user_types, true
}

// ResetApplicableUserTypes resets all changes to the "applicable_user_types" field.
func (m *RoleMutation) ResetApplicableUserTypes() {
	m.applicable_user_types = nil
	m.appendapplicable_user_types = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[role.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, role.FieldCreatedBy)
}

// SetActive sets the "active" field.
func (m *RoleMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *RoleMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *RoleMutation) ResetActive() {
	m.active = nil
}

// SetParentID sets the "parent_id" field.
func (m *RoleMutation) SetParentID(x xid.ID) {
	m.parent = &x
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *RoleMutation) ParentID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldParentID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *RoleMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[role.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *RoleMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[role.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *RoleMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, role.FieldParentID)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RoleMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[role.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RoleMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RoleMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddUserAssignmentIDs adds the "user_assignments" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserAssignmentIDs(ids ...xid.ID) {
	if m.user_assignments == nil {
		m.user_assignments = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.user_assignments[ids[i]] = struct{}{}
	}
}

// ClearUserAssignments clears the "user_assignments" edge to the UserRole entity.
func (m *RoleMutation) ClearUserAssignments() {
	m.cleareduser_assignments = true
}

// UserAssignmentsCleared reports if the "user_assignments" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserAssignmentsCleared() bool {
	return m.cleareduser_assignments
}

// RemoveUserAssignmentIDs removes the "user_assignments" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserAssignmentIDs(ids ...xid.ID) {
	if m.removeduser_assignments == nil {
		m.removeduser_assignments = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.user_assignments, ids[i])
		m.removeduser_assignments[ids[i]] = struct{}{}
	}
}

// RemovedUserAssignments returns the removed IDs of the "user_assignments" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserAssignmentsIDs() (ids []xid.ID) {
	for id := range m.removeduser_assignments {
		ids = append(ids, id)
	}
	return
}

// UserAssignmentsIDs returns the "user_assignments" edge IDs in the mutation.
func (m *RoleMutation) UserAssignmentsIDs() (ids []xid.ID) {
	for id := range m.user_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetUserAssignments resets all changes to the "user_assignments" edge.
func (m *RoleMutation) ResetUserAssignments() {
	m.user_assignments = nil
	m.cleareduser_assignments = false
	m.removeduser_assignments = nil
}

// AddSystemUserIDs adds the "system_users" edge to the User entity by ids.
func (m *RoleMutation) AddSystemUserIDs(ids ...xid.ID) {
	if m.system_users == nil {
		m.system_users = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.system_users[ids[i]] = struct{}{}
	}
}

// ClearSystemUsers clears the "system_users" edge to the User entity.
func (m *RoleMutation) ClearSystemUsers() {
	m.clearedsystem_users = true
}

// SystemUsersCleared reports if the "system_users" edge to the User entity was cleared.
func (m *RoleMutation) SystemUsersCleared() bool {
	return m.clearedsystem_users
}

// RemoveSystemUserIDs removes the "system_users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveSystemUserIDs(ids ...xid.ID) {
	if m.removedsystem_users == nil {
		m.removedsystem_users = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.system_users, ids[i])
		m.removedsystem_users[ids[i]] = struct{}{}
	}
}

// RemovedSystemUsers returns the removed IDs of the "system_users" edge to the User entity.
func (m *RoleMutation) RemovedSystemUsersIDs() (ids []xid.ID) {
	for id := range m.removedsystem_users {
		ids = append(ids, id)
	}
	return
}

// SystemUsersIDs returns the "system_users" edge IDs in the mutation.
func (m *RoleMutation) SystemUsersIDs() (ids []xid.ID) {
	for id := range m.system_users {
		ids = append(ids, id)
	}
	return
}

// ResetSystemUsers resets all changes to the "system_users" edge.
func (m *RoleMutation) ResetSystemUsers() {
	m.system_users = nil
	m.clearedsystem_users = false
	m.removedsystem_users = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...xid.ID) {
	if m.permissions == nil {
		m.permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...xid.ID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []xid.ID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []xid.ID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddMembershipIDs adds the "memberships" edge to the Membership entity by ids.
func (m *RoleMutation) AddMembershipIDs(ids ...xid.ID) {
	if m.memberships == nil {
		m.memberships = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the Membership entity.
func (m *RoleMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the Membership entity was cleared.
func (m *RoleMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the Membership entity by IDs.
func (m *RoleMutation) RemoveMembershipIDs(ids ...xid.ID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the Membership entity.
func (m *RoleMutation) RemovedMembershipsIDs() (ids []xid.ID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *RoleMutation) MembershipsIDs() (ids []xid.ID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *RoleMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// ClearParent clears the "parent" edge to the Role entity.
func (m *RoleMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[role.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Role entity was cleared.
func (m *RoleMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *RoleMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Role entity by ids.
func (m *RoleMutation) AddChildIDs(ids ...xid.ID) {
	if m.children == nil {
		m.children = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Role entity.
func (m *RoleMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Role entity was cleared.
func (m *RoleMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Role entity by IDs.
func (m *RoleMutation) RemoveChildIDs(ids ...xid.ID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Role entity.
func (m *RoleMutation) RemovedChildrenIDs() (ids []xid.ID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *RoleMutation) ChildrenIDs() (ids []xid.ID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *RoleMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, role.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.role_type != nil {
		fields = append(fields, role.FieldRoleType)
	}
	if m.organization != nil {
		fields = append(fields, role.FieldOrganizationID)
	}
	if m.application_id != nil {
		fields = append(fields, role.FieldApplicationID)
	}
	if m.system != nil {
		fields = append(fields, role.FieldSystem)
	}
	if m.is_default != nil {
		fields = append(fields, role.FieldIsDefault)
	}
	if m.priority != nil {
		fields = append(fields, role.FieldPriority)
	}
	if m.color != nil {
		fields = append(fields, role.FieldColor)
	}
	if m.applicable_user_types != nil {
		fields = append(fields, role.FieldApplicableUserTypes)
	}
	if m.created_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.active != nil {
		fields = append(fields, role.FieldActive)
	}
	if m.parent != nil {
		fields = append(fields, role.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldDisplayName:
		return m.DisplayName()
	case role.FieldDescription:
		return m.Description()
	case role.FieldRoleType:
		return m.RoleType()
	case role.FieldOrganizationID:
		return m.OrganizationID()
	case role.FieldApplicationID:
		return m.ApplicationID()
	case role.FieldSystem:
		return m.System()
	case role.FieldIsDefault:
		return m.IsDefault()
	case role.FieldPriority:
		return m.Priority()
	case role.FieldColor:
		return m.Color()
	case role.FieldApplicableUserTypes:
		return m.ApplicableUserTypes()
	case role.FieldCreatedBy:
		return m.CreatedBy()
	case role.FieldActive:
		return m.Active()
	case role.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldRoleType:
		return m.OldRoleType(ctx)
	case role.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case role.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case role.FieldSystem:
		return m.OldSystem(ctx)
	case role.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case role.FieldPriority:
		return m.OldPriority(ctx)
	case role.FieldColor:
		return m.OldColor(ctx)
	case role.FieldApplicableUserTypes:
		return m.OldApplicableUserTypes(ctx)
	case role.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role.FieldActive:
		return m.OldActive(ctx)
	case role.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldRoleType:
		v, ok := value.(model.RoleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleType(v)
		return nil
	case role.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case role.FieldApplicationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case role.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case role.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case role.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case role.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case role.FieldApplicableUserTypes:
		v, ok := value.([]model.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableUserTypes(v)
		return nil
	case role.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case role.FieldParentID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, role.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldDisplayName) {
		fields = append(fields, role.FieldDisplayName)
	}
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldOrganizationID) {
		fields = append(fields, role.FieldOrganizationID)
	}
	if m.FieldCleared(role.FieldApplicationID) {
		fields = append(fields, role.FieldApplicationID)
	}
	if m.FieldCleared(role.FieldColor) {
		fields = append(fields, role.FieldColor)
	}
	if m.FieldCleared(role.FieldCreatedBy) {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.FieldCleared(role.FieldParentID) {
		fields = append(fields, role.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case role.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	case role.FieldColor:
		m.ClearColor()
		return nil
	case role.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case role.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldRoleType:
		m.ResetRoleType()
		return nil
	case role.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case role.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case role.FieldSystem:
		m.ResetSystem()
		return nil
	case role.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case role.FieldPriority:
		m.ResetPriority()
		return nil
	case role.FieldColor:
		m.ResetColor()
		return nil
	case role.FieldApplicableUserTypes:
		m.ResetApplicableUserTypes()
		return nil
	case role.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role.FieldActive:
		m.ResetActive()
		return nil
	case role.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.organization != nil {
		edges = append(edges, role.EdgeOrganization)
	}
	if m.user_assignments != nil {
		edges = append(edges, role.EdgeUserAssignments)
	}
	if m.system_users != nil {
		edges = append(edges, role.EdgeSystemUsers)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.memberships != nil {
		edges = append(edges, role.EdgeMemberships)
	}
	if m.parent != nil {
		edges = append(edges, role.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, role.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.user_assignments))
		for id := range m.user_assignments {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeSystemUsers:
		ids := make([]ent.Value, 0, len(m.system_users))
		for id := range m.system_users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removeduser_assignments != nil {
		edges = append(edges, role.EdgeUserAssignments)
	}
	if m.removedsystem_users != nil {
		edges = append(edges, role.EdgeSystemUsers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.removedmemberships != nil {
		edges = append(edges, role.EdgeMemberships)
	}
	if m.removedchildren != nil {
		edges = append(edges, role.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.removeduser_assignments))
		for id := range m.removeduser_assignments {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeSystemUsers:
		ids := make([]ent.Value, 0, len(m.removedsystem_users))
		for id := range m.removedsystem_users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedorganization {
		edges = append(edges, role.EdgeOrganization)
	}
	if m.cleareduser_assignments {
		edges = append(edges, role.EdgeUserAssignments)
	}
	if m.clearedsystem_users {
		edges = append(edges, role.EdgeSystemUsers)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	if m.clearedmemberships {
		edges = append(edges, role.EdgeMemberships)
	}
	if m.clearedparent {
		edges = append(edges, role.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, role.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeOrganization:
		return m.clearedorganization
	case role.EdgeUserAssignments:
		return m.cleareduser_assignments
	case role.EdgeSystemUsers:
		return m.clearedsystem_users
	case role.EdgePermissions:
		return m.clearedpermissions
	case role.EdgeMemberships:
		return m.clearedmemberships
	case role.EdgeParent:
		return m.clearedparent
	case role.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case role.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case role.EdgeUserAssignments:
		m.ResetUserAssignments()
		return nil
	case role.EdgeSystemUsers:
		m.ResetSystemUsers()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	case role.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case role.EdgeParent:
		m.ResetParent()
		return nil
	case role.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SMSTemplateMutation represents an operation that mutates the SMSTemplate nodes in the graph.
type SMSTemplateMutation struct {
	config
	op                    Op
	typ                   string
	id                    *xid.ID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	content               *string
	_type                 *string
	active                *bool
	system                *bool
	locale                *string
	max_length            *int
	addmax_length         *int
	message_type          *string
	estimated_segments    *int
	addestimated_segments *int
	estimated_cost        *float64
	addestimated_cost     *float64
	currency              *string
	variables             *[]string
	appendvariables       []string
	metadata              *map[string]interface{}
	last_used_at          *time.Time
	usage_count           *int
	addusage_count        *int
	clearedFields         map[string]struct{}
	organization          *xid.ID
	clearedorganization   bool
	done                  bool
	oldValue              func(context.Context) (*SMSTemplate, error)
	predicates            []predicate.SMSTemplate
}

var _ ent.Mutation = (*SMSTemplateMutation)(nil)

// smstemplateOption allows management of the mutation configuration using functional options.
type smstemplateOption func(*SMSTemplateMutation)

// newSMSTemplateMutation creates new mutation for the SMSTemplate entity.
func newSMSTemplateMutation(c config, op Op, opts ...smstemplateOption) *SMSTemplateMutation {
	m := &SMSTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeSMSTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSMSTemplateID sets the ID field of the mutation.
func withSMSTemplateID(id xid.ID) smstemplateOption {
	return func(m *SMSTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *SMSTemplate
		)
		m.oldValue = func(ctx context.Context) (*SMSTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SMSTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSMSTemplate sets the old SMSTemplate of the mutation.
func withSMSTemplate(node *SMSTemplate) smstemplateOption {
	return func(m *SMSTemplateMutation) {
		m.oldValue = func(context.Context) (*SMSTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SMSTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SMSTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SMSTemplate entities.
func (m *SMSTemplateMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SMSTemplateMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SMSTemplateMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SMSTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SMSTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SMSTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SMSTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SMSTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SMSTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SMSTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SMSTemplateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SMSTemplateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SMSTemplateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[smstemplate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SMSTemplateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SMSTemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, smstemplate.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SMSTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SMSTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SMSTemplateMutation) ResetName() {
	m.name = nil
}

// SetContent sets the "content" field.
func (m *SMSTemplateMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SMSTemplateMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SMSTemplateMutation) ResetContent() {
	m.content = nil
}

// SetType sets the "type" field.
func (m *SMSTemplateMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SMSTemplateMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SMSTemplateMutation) ResetType() {
	m._type = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *SMSTemplateMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *SMSTemplateMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *SMSTemplateMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[smstemplate.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *SMSTemplateMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *SMSTemplateMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, smstemplate.FieldOrganizationID)
}

// SetActive sets the "active" field.
func (m *SMSTemplateMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *SMSTemplateMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *SMSTemplateMutation) ResetActive() {
	m.active = nil
}

// SetSystem sets the "system" field.
func (m *SMSTemplateMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *SMSTemplateMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *SMSTemplateMutation) ResetSystem() {
	m.system = nil
}

// SetLocale sets the "locale" field.
func (m *SMSTemplateMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *SMSTemplateMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *SMSTemplateMutation) ResetLocale() {
	m.locale = nil
}

// SetMaxLength sets the "max_length" field.
func (m *SMSTemplateMutation) SetMaxLength(i int) {
	m.max_length = &i
	m.addmax_length = nil
}

// MaxLength returns the value of the "max_length" field in the mutation.
func (m *SMSTemplateMutation) MaxLength() (r int, exists bool) {
	v := m.max_length
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLength returns the old "max_length" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldMaxLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLength: %w", err)
	}
	return oldValue.MaxLength, nil
}

// AddMaxLength adds i to the "max_length" field.
func (m *SMSTemplateMutation) AddMaxLength(i int) {
	if m.addmax_length != nil {
		*m.addmax_length += i
	} else {
		m.addmax_length = &i
	}
}

// AddedMaxLength returns the value that was added to the "max_length" field in this mutation.
func (m *SMSTemplateMutation) AddedMaxLength() (r int, exists bool) {
	v := m.addmax_length
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLength resets all changes to the "max_length" field.
func (m *SMSTemplateMutation) ResetMaxLength() {
	m.max_length = nil
	m.addmax_length = nil
}

// SetMessageType sets the "message_type" field.
func (m *SMSTemplateMutation) SetMessageType(s string) {
	m.message_type = &s
}

// MessageType returns the value of the "message_type" field in the mutation.
func (m *SMSTemplateMutation) MessageType() (r string, exists bool) {
	v := m.message_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageType returns the old "message_type" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldMessageType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageType: %w", err)
	}
	return oldValue.MessageType, nil
}

// ResetMessageType resets all changes to the "message_type" field.
func (m *SMSTemplateMutation) ResetMessageType() {
	m.message_type = nil
}

// SetEstimatedSegments sets the "estimated_segments" field.
func (m *SMSTemplateMutation) SetEstimatedSegments(i int) {
	m.estimated_segments = &i
	m.addestimated_segments = nil
}

// EstimatedSegments returns the value of the "estimated_segments" field in the mutation.
func (m *SMSTemplateMutation) EstimatedSegments() (r int, exists bool) {
	v := m.estimated_segments
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedSegments returns the old "estimated_segments" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldEstimatedSegments(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedSegments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedSegments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedSegments: %w", err)
	}
	return oldValue.EstimatedSegments, nil
}

// AddEstimatedSegments adds i to the "estimated_segments" field.
func (m *SMSTemplateMutation) AddEstimatedSegments(i int) {
	if m.addestimated_segments != nil {
		*m.addestimated_segments += i
	} else {
		m.addestimated_segments = &i
	}
}

// AddedEstimatedSegments returns the value that was added to the "estimated_segments" field in this mutation.
func (m *SMSTemplateMutation) AddedEstimatedSegments() (r int, exists bool) {
	v := m.addestimated_segments
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedSegments clears the value of the "estimated_segments" field.
func (m *SMSTemplateMutation) ClearEstimatedSegments() {
	m.estimated_segments = nil
	m.addestimated_segments = nil
	m.clearedFields[smstemplate.FieldEstimatedSegments] = struct{}{}
}

// EstimatedSegmentsCleared returns if the "estimated_segments" field was cleared in this mutation.
func (m *SMSTemplateMutation) EstimatedSegmentsCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldEstimatedSegments]
	return ok
}

// ResetEstimatedSegments resets all changes to the "estimated_segments" field.
func (m *SMSTemplateMutation) ResetEstimatedSegments() {
	m.estimated_segments = nil
	m.addestimated_segments = nil
	delete(m.clearedFields, smstemplate.FieldEstimatedSegments)
}

// SetEstimatedCost sets the "estimated_cost" field.
func (m *SMSTemplateMutation) SetEstimatedCost(f float64) {
	m.estimated_cost = &f
	m.addestimated_cost = nil
}

// EstimatedCost returns the value of the "estimated_cost" field in the mutation.
func (m *SMSTemplateMutation) EstimatedCost() (r float64, exists bool) {
	v := m.estimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCost returns the old "estimated_cost" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldEstimatedCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCost: %w", err)
	}
	return oldValue.EstimatedCost, nil
}

// AddEstimatedCost adds f to the "estimated_cost" field.
func (m *SMSTemplateMutation) AddEstimatedCost(f float64) {
	if m.addestimated_cost != nil {
		*m.addestimated_cost += f
	} else {
		m.addestimated_cost = &f
	}
}

// AddedEstimatedCost returns the value that was added to the "estimated_cost" field in this mutation.
func (m *SMSTemplateMutation) AddedEstimatedCost() (r float64, exists bool) {
	v := m.addestimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedCost clears the value of the "estimated_cost" field.
func (m *SMSTemplateMutation) ClearEstimatedCost() {
	m.estimated_cost = nil
	m.addestimated_cost = nil
	m.clearedFields[smstemplate.FieldEstimatedCost] = struct{}{}
}

// EstimatedCostCleared returns if the "estimated_cost" field was cleared in this mutation.
func (m *SMSTemplateMutation) EstimatedCostCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldEstimatedCost]
	return ok
}

// ResetEstimatedCost resets all changes to the "estimated_cost" field.
func (m *SMSTemplateMutation) ResetEstimatedCost() {
	m.estimated_cost = nil
	m.addestimated_cost = nil
	delete(m.clearedFields, smstemplate.FieldEstimatedCost)
}

// SetCurrency sets the "currency" field.
func (m *SMSTemplateMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *SMSTemplateMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *SMSTemplateMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[smstemplate.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *SMSTemplateMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *SMSTemplateMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, smstemplate.FieldCurrency)
}

// SetVariables sets the "variables" field.
func (m *SMSTemplateMutation) SetVariables(s []string) {
	m.variables = &s
	m.appendvariables = nil
}

// Variables returns the value of the "variables" field in the mutation.
func (m *SMSTemplateMutation) Variables() (r []string, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldVariables(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// AppendVariables adds s to the "variables" field.
func (m *SMSTemplateMutation) AppendVariables(s []string) {
	m.appendvariables = append(m.appendvariables, s...)
}

// AppendedVariables returns the list of values that were appended to the "variables" field in this mutation.
func (m *SMSTemplateMutation) AppendedVariables() ([]string, bool) {
	if len(m.appendvariables) == 0 {
		return nil, false
	}
	return m.appendvariables, true
}

// ClearVariables clears the value of the "variables" field.
func (m *SMSTemplateMutation) ClearVariables() {
	m.variables = nil
	m.appendvariables = nil
	m.clearedFields[smstemplate.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *SMSTemplateMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *SMSTemplateMutation) ResetVariables() {
	m.variables = nil
	m.appendvariables = nil
	delete(m.clearedFields, smstemplate.FieldVariables)
}

// SetMetadata sets the "metadata" field.
func (m *SMSTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SMSTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SMSTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[smstemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SMSTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SMSTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, smstemplate.FieldMetadata)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *SMSTemplateMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *SMSTemplateMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *SMSTemplateMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[smstemplate.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *SMSTemplateMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[smstemplate.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *SMSTemplateMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, smstemplate.FieldLastUsedAt)
}

// SetUsageCount sets the "usage_count" field.
func (m *SMSTemplateMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *SMSTemplateMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the SMSTemplate entity.
// If the SMSTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SMSTemplateMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *SMSTemplateMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *SMSTemplateMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *SMSTemplateMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *SMSTemplateMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[smstemplate.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *SMSTemplateMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *SMSTemplateMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *SMSTemplateMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the SMSTemplateMutation builder.
func (m *SMSTemplateMutation) Where(ps ...predicate.SMSTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SMSTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SMSTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SMSTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SMSTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SMSTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SMSTemplate).
func (m *SMSTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SMSTemplateMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, smstemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, smstemplate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, smstemplate.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, smstemplate.FieldName)
	}
	if m.content != nil {
		fields = append(fields, smstemplate.FieldContent)
	}
	if m._type != nil {
		fields = append(fields, smstemplate.FieldType)
	}
	if m.organization != nil {
		fields = append(fields, smstemplate.FieldOrganizationID)
	}
	if m.active != nil {
		fields = append(fields, smstemplate.FieldActive)
	}
	if m.system != nil {
		fields = append(fields, smstemplate.FieldSystem)
	}
	if m.locale != nil {
		fields = append(fields, smstemplate.FieldLocale)
	}
	if m.max_length != nil {
		fields = append(fields, smstemplate.FieldMaxLength)
	}
	if m.message_type != nil {
		fields = append(fields, smstemplate.FieldMessageType)
	}
	if m.estimated_segments != nil {
		fields = append(fields, smstemplate.FieldEstimatedSegments)
	}
	if m.estimated_cost != nil {
		fields = append(fields, smstemplate.FieldEstimatedCost)
	}
	if m.currency != nil {
		fields = append(fields, smstemplate.FieldCurrency)
	}
	if m.variables != nil {
		fields = append(fields, smstemplate.FieldVariables)
	}
	if m.metadata != nil {
		fields = append(fields, smstemplate.FieldMetadata)
	}
	if m.last_used_at != nil {
		fields = append(fields, smstemplate.FieldLastUsedAt)
	}
	if m.usage_count != nil {
		fields = append(fields, smstemplate.FieldUsageCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SMSTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case smstemplate.FieldCreatedAt:
		return m.CreatedAt()
	case smstemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case smstemplate.FieldDeletedAt:
		return m.DeletedAt()
	case smstemplate.FieldName:
		return m.Name()
	case smstemplate.FieldContent:
		return m.Content()
	case smstemplate.FieldType:
		return m.GetType()
	case smstemplate.FieldOrganizationID:
		return m.OrganizationID()
	case smstemplate.FieldActive:
		return m.Active()
	case smstemplate.FieldSystem:
		return m.System()
	case smstemplate.FieldLocale:
		return m.Locale()
	case smstemplate.FieldMaxLength:
		return m.MaxLength()
	case smstemplate.FieldMessageType:
		return m.MessageType()
	case smstemplate.FieldEstimatedSegments:
		return m.EstimatedSegments()
	case smstemplate.FieldEstimatedCost:
		return m.EstimatedCost()
	case smstemplate.FieldCurrency:
		return m.Currency()
	case smstemplate.FieldVariables:
		return m.Variables()
	case smstemplate.FieldMetadata:
		return m.Metadata()
	case smstemplate.FieldLastUsedAt:
		return m.LastUsedAt()
	case smstemplate.FieldUsageCount:
		return m.UsageCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SMSTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case smstemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case smstemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case smstemplate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case smstemplate.FieldName:
		return m.OldName(ctx)
	case smstemplate.FieldContent:
		return m.OldContent(ctx)
	case smstemplate.FieldType:
		return m.OldType(ctx)
	case smstemplate.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case smstemplate.FieldActive:
		return m.OldActive(ctx)
	case smstemplate.FieldSystem:
		return m.OldSystem(ctx)
	case smstemplate.FieldLocale:
		return m.OldLocale(ctx)
	case smstemplate.FieldMaxLength:
		return m.OldMaxLength(ctx)
	case smstemplate.FieldMessageType:
		return m.OldMessageType(ctx)
	case smstemplate.FieldEstimatedSegments:
		return m.OldEstimatedSegments(ctx)
	case smstemplate.FieldEstimatedCost:
		return m.OldEstimatedCost(ctx)
	case smstemplate.FieldCurrency:
		return m.OldCurrency(ctx)
	case smstemplate.FieldVariables:
		return m.OldVariables(ctx)
	case smstemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	case smstemplate.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case smstemplate.FieldUsageCount:
		return m.OldUsageCount(ctx)
	}
	return nil, fmt.Errorf("unknown SMSTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SMSTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case smstemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case smstemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case smstemplate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case smstemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case smstemplate.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case smstemplate.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case smstemplate.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case smstemplate.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case smstemplate.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case smstemplate.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case smstemplate.FieldMaxLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLength(v)
		return nil
	case smstemplate.FieldMessageType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageType(v)
		return nil
	case smstemplate.FieldEstimatedSegments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedSegments(v)
		return nil
	case smstemplate.FieldEstimatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCost(v)
		return nil
	case smstemplate.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case smstemplate.FieldVariables:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case smstemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case smstemplate.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case smstemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown SMSTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SMSTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addmax_length != nil {
		fields = append(fields, smstemplate.FieldMaxLength)
	}
	if m.addestimated_segments != nil {
		fields = append(fields, smstemplate.FieldEstimatedSegments)
	}
	if m.addestimated_cost != nil {
		fields = append(fields, smstemplate.FieldEstimatedCost)
	}
	if m.addusage_count != nil {
		fields = append(fields, smstemplate.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SMSTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case smstemplate.FieldMaxLength:
		return m.AddedMaxLength()
	case smstemplate.FieldEstimatedSegments:
		return m.AddedEstimatedSegments()
	case smstemplate.FieldEstimatedCost:
		return m.AddedEstimatedCost()
	case smstemplate.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SMSTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case smstemplate.FieldMaxLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLength(v)
		return nil
	case smstemplate.FieldEstimatedSegments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedSegments(v)
		return nil
	case smstemplate.FieldEstimatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedCost(v)
		return nil
	case smstemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown SMSTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SMSTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(smstemplate.FieldDeletedAt) {
		fields = append(fields, smstemplate.FieldDeletedAt)
	}
	if m.FieldCleared(smstemplate.FieldOrganizationID) {
		fields = append(fields, smstemplate.FieldOrganizationID)
	}
	if m.FieldCleared(smstemplate.FieldEstimatedSegments) {
		fields = append(fields, smstemplate.FieldEstimatedSegments)
	}
	if m.FieldCleared(smstemplate.FieldEstimatedCost) {
		fields = append(fields, smstemplate.FieldEstimatedCost)
	}
	if m.FieldCleared(smstemplate.FieldCurrency) {
		fields = append(fields, smstemplate.FieldCurrency)
	}
	if m.FieldCleared(smstemplate.FieldVariables) {
		fields = append(fields, smstemplate.FieldVariables)
	}
	if m.FieldCleared(smstemplate.FieldMetadata) {
		fields = append(fields, smstemplate.FieldMetadata)
	}
	if m.FieldCleared(smstemplate.FieldLastUsedAt) {
		fields = append(fields, smstemplate.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SMSTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SMSTemplateMutation) ClearField(name string) error {
	switch name {
	case smstemplate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case smstemplate.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case smstemplate.FieldEstimatedSegments:
		m.ClearEstimatedSegments()
		return nil
	case smstemplate.FieldEstimatedCost:
		m.ClearEstimatedCost()
		return nil
	case smstemplate.FieldCurrency:
		m.ClearCurrency()
		return nil
	case smstemplate.FieldVariables:
		m.ClearVariables()
		return nil
	case smstemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	case smstemplate.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown SMSTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SMSTemplateMutation) ResetField(name string) error {
	switch name {
	case smstemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case smstemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case smstemplate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case smstemplate.FieldName:
		m.ResetName()
		return nil
	case smstemplate.FieldContent:
		m.ResetContent()
		return nil
	case smstemplate.FieldType:
		m.ResetType()
		return nil
	case smstemplate.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case smstemplate.FieldActive:
		m.ResetActive()
		return nil
	case smstemplate.FieldSystem:
		m.ResetSystem()
		return nil
	case smstemplate.FieldLocale:
		m.ResetLocale()
		return nil
	case smstemplate.FieldMaxLength:
		m.ResetMaxLength()
		return nil
	case smstemplate.FieldMessageType:
		m.ResetMessageType()
		return nil
	case smstemplate.FieldEstimatedSegments:
		m.ResetEstimatedSegments()
		return nil
	case smstemplate.FieldEstimatedCost:
		m.ResetEstimatedCost()
		return nil
	case smstemplate.FieldCurrency:
		m.ResetCurrency()
		return nil
	case smstemplate.FieldVariables:
		m.ResetVariables()
		return nil
	case smstemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	case smstemplate.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case smstemplate.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	}
	return fmt.Errorf("unknown SMSTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SMSTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, smstemplate.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SMSTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case smstemplate.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SMSTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SMSTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SMSTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, smstemplate.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SMSTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case smstemplate.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SMSTemplateMutation) ClearEdge(name string) error {
	switch name {
	case smstemplate.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown SMSTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SMSTemplateMutation) ResetEdge(name string) error {
	switch name {
	case smstemplate.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown SMSTemplate edge %s", name)
}

// SSOStateMutation represents an operation that mutates the SSOState nodes in the graph.
type SSOStateMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	state         *string
	data          *string
	expires_at    *time.Time
	redirect_url  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SSOState, error)
	predicates    []predicate.SSOState
}

var _ ent.Mutation = (*SSOStateMutation)(nil)

// ssostateOption allows management of the mutation configuration using functional options.
type ssostateOption func(*SSOStateMutation)

// newSSOStateMutation creates new mutation for the SSOState entity.
func newSSOStateMutation(c config, op Op, opts ...ssostateOption) *SSOStateMutation {
	m := &SSOStateMutation{
		config:        c,
		op:            op,
		typ:           TypeSSOState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSSOStateID sets the ID field of the mutation.
func withSSOStateID(id xid.ID) ssostateOption {
	return func(m *SSOStateMutation) {
		var (
			err   error
			once  sync.Once
			value *SSOState
		)
		m.oldValue = func(ctx context.Context) (*SSOState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SSOState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSSOState sets the old SSOState of the mutation.
func withSSOState(node *SSOState) ssostateOption {
	return func(m *SSOStateMutation) {
		m.oldValue = func(context.Context) (*SSOState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SSOStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SSOStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SSOState entities.
func (m *SSOStateMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SSOStateMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SSOStateMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SSOState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SSOStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SSOStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SSOStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SSOStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SSOStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SSOStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SSOStateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SSOStateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SSOStateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ssostate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SSOStateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ssostate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SSOStateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ssostate.FieldDeletedAt)
}

// SetState sets the "state" field.
func (m *SSOStateMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *SSOStateMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *SSOStateMutation) ResetState() {
	m.state = nil
}

// SetData sets the "data" field.
func (m *SSOStateMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *SSOStateMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SSOStateMutation) ResetData() {
	m.data = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SSOStateMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SSOStateMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SSOStateMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRedirectURL sets the "redirect_url" field.
func (m *SSOStateMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *SSOStateMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ClearRedirectURL clears the value of the "redirect_url" field.
func (m *SSOStateMutation) ClearRedirectURL() {
	m.redirect_url = nil
	m.clearedFields[ssostate.FieldRedirectURL] = struct{}{}
}

// RedirectURLCleared returns if the "redirect_url" field was cleared in this mutation.
func (m *SSOStateMutation) RedirectURLCleared() bool {
	_, ok := m.clearedFields[ssostate.FieldRedirectURL]
	return ok
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *SSOStateMutation) ResetRedirectURL() {
	m.redirect_url = nil
	delete(m.clearedFields, ssostate.FieldRedirectURL)
}

// Where appends a list predicates to the SSOStateMutation builder.
func (m *SSOStateMutation) Where(ps ...predicate.SSOState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SSOStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SSOStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SSOState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SSOStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SSOStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SSOState).
func (m *SSOStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SSOStateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, ssostate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ssostate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ssostate.FieldDeletedAt)
	}
	if m.state != nil {
		fields = append(fields, ssostate.FieldState)
	}
	if m.data != nil {
		fields = append(fields, ssostate.FieldData)
	}
	if m.expires_at != nil {
		fields = append(fields, ssostate.FieldExpiresAt)
	}
	if m.redirect_url != nil {
		fields = append(fields, ssostate.FieldRedirectURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SSOStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ssostate.FieldCreatedAt:
		return m.CreatedAt()
	case ssostate.FieldUpdatedAt:
		return m.UpdatedAt()
	case ssostate.FieldDeletedAt:
		return m.DeletedAt()
	case ssostate.FieldState:
		return m.State()
	case ssostate.FieldData:
		return m.Data()
	case ssostate.FieldExpiresAt:
		return m.ExpiresAt()
	case ssostate.FieldRedirectURL:
		return m.RedirectURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SSOStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ssostate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ssostate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ssostate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ssostate.FieldState:
		return m.OldState(ctx)
	case ssostate.FieldData:
		return m.OldData(ctx)
	case ssostate.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case ssostate.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	}
	return nil, fmt.Errorf("unknown SSOState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SSOStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ssostate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ssostate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ssostate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ssostate.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case ssostate.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case ssostate.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case ssostate.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	}
	return fmt.Errorf("unknown SSOState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SSOStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SSOStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SSOStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SSOState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SSOStateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ssostate.FieldDeletedAt) {
		fields = append(fields, ssostate.FieldDeletedAt)
	}
	if m.FieldCleared(ssostate.FieldRedirectURL) {
		fields = append(fields, ssostate.FieldRedirectURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SSOStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SSOStateMutation) ClearField(name string) error {
	switch name {
	case ssostate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ssostate.FieldRedirectURL:
		m.ClearRedirectURL()
		return nil
	}
	return fmt.Errorf("unknown SSOState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SSOStateMutation) ResetField(name string) error {
	switch name {
	case ssostate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ssostate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ssostate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ssostate.FieldState:
		m.ResetState()
		return nil
	case ssostate.FieldData:
		m.ResetData()
		return nil
	case ssostate.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case ssostate.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	}
	return fmt.Errorf("unknown SSOState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SSOStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SSOStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SSOStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SSOStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SSOStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SSOStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SSOStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SSOState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SSOStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SSOState edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	created_at        *time.Time
	updated_at        *time.Time
	token             *string
	ip_address        *string
	user_agent        *string
	device_id         *string
	location          *string
	organization_id   *xid.ID
	active            *bool
	expires_at        *time.Time
	last_active_at    *time.Time
	metadata          *map[string]interface{}
	clearedFields     map[string]struct{}
	user              *xid.ID
	cleareduser       bool
	audit_logs        map[xid.ID]struct{}
	removedaudit_logs map[xid.ID]struct{}
	clearedaudit_logs bool
	activities        map[xid.ID]struct{}
	removedactivities map[xid.ID]struct{}
	clearedactivities bool
	done              bool
	oldValue          func(context.Context) (*Session, error)
	predicates        []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id xid.ID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetDeviceID sets the "device_id" field.
func (m *SessionMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *SessionMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *SessionMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[session.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *SessionMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[session.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *SessionMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, session.FieldDeviceID)
}

// SetLocation sets the "location" field.
func (m *SessionMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *SessionMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *SessionMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[session.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *SessionMutation) LocationCleared() bool {
	_, ok := m.clearedFields[session.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *SessionMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, session.FieldLocation)
}

// SetOrganizationID sets the "organization_id" field.
func (m *SessionMutation) SetOrganizationID(x xid.ID) {
	m.organization_id = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *SessionMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *SessionMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[session.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *SessionMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[session.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *SessionMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, session.FieldOrganizationID)
}

// SetActive sets the "active" field.
func (m *SessionMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *SessionMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *SessionMutation) ResetActive() {
	m.active = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *SessionMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *SessionMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *SessionMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetMetadata sets the "metadata" field.
func (m *SessionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SessionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SessionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[session.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SessionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[session.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SessionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, session.FieldMetadata)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddAuditLogIDs adds the "audit_logs" edge to the Audit entity by ids.
func (m *SessionMutation) AddAuditLogIDs(ids ...xid.ID) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the Audit entity.
func (m *SessionMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the Audit entity was cleared.
func (m *SessionMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the Audit entity by IDs.
func (m *SessionMutation) RemoveAuditLogIDs(ids ...xid.ID) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the Audit entity.
func (m *SessionMutation) RemovedAuditLogsIDs() (ids []xid.ID) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *SessionMutation) AuditLogsIDs() (ids []xid.ID) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *SessionMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *SessionMutation) AddActivityIDs(ids ...xid.ID) {
	if m.activities == nil {
		m.activities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *SessionMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *SessionMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *SessionMutation) RemoveActivityIDs(ids ...xid.ID) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *SessionMutation) RemovedActivitiesIDs() (ids []xid.ID) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *SessionMutation) ActivitiesIDs() (ids []xid.ID) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *SessionMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.device_id != nil {
		fields = append(fields, session.FieldDeviceID)
	}
	if m.location != nil {
		fields = append(fields, session.FieldLocation)
	}
	if m.organization_id != nil {
		fields = append(fields, session.FieldOrganizationID)
	}
	if m.active != nil {
		fields = append(fields, session.FieldActive)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_active_at != nil {
		fields = append(fields, session.FieldLastActiveAt)
	}
	if m.metadata != nil {
		fields = append(fields, session.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldUserID:
		return m.UserID()
	case session.FieldToken:
		return m.Token()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldDeviceID:
		return m.DeviceID()
	case session.FieldLocation:
		return m.Location()
	case session.FieldOrganizationID:
		return m.OrganizationID()
	case session.FieldActive:
		return m.Active()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastActiveAt:
		return m.LastActiveAt()
	case session.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case session.FieldLocation:
		return m.OldLocation(ctx)
	case session.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case session.FieldActive:
		return m.OldActive(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case session.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case session.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case session.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case session.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case session.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldDeviceID) {
		fields = append(fields, session.FieldDeviceID)
	}
	if m.FieldCleared(session.FieldLocation) {
		fields = append(fields, session.FieldLocation)
	}
	if m.FieldCleared(session.FieldOrganizationID) {
		fields = append(fields, session.FieldOrganizationID)
	}
	if m.FieldCleared(session.FieldMetadata) {
		fields = append(fields, session.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case session.FieldLocation:
		m.ClearLocation()
		return nil
	case session.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case session.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case session.FieldLocation:
		m.ResetLocation()
		return nil
	case session.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case session.FieldActive:
		m.ResetActive()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case session.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	if m.audit_logs != nil {
		edges = append(edges, session.EdgeAuditLogs)
	}
	if m.activities != nil {
		edges = append(edges, session.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaudit_logs != nil {
		edges = append(edges, session.EdgeAuditLogs)
	}
	if m.removedactivities != nil {
		edges = append(edges, session.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	if m.clearedaudit_logs {
		edges = append(edges, session.EdgeAuditLogs)
	}
	if m.clearedactivities {
		edges = append(edges, session.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	case session.EdgeAuditLogs:
		return m.clearedaudit_logs
	case session.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	case session.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case session.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *xid.ID
	created_at                       *time.Time
	updated_at                       *time.Time
	email                            *string
	phone_number                     *string
	first_name                       *string
	last_name                        *string
	username                         *string
	password_hash                    *string
	email_verified                   *bool
	phone_verified                   *bool
	active                           *bool
	blocked                          *bool
	last_login                       *time.Time
	last_password_change             *time.Time
	metadata                         *map[string]interface{}
	profile_image_url                *string
	locale                           *string
	timezone                         *string
	user_type                        *model.UserType
	primary_organization_id          *xid.ID
	is_platform_admin                *bool
	auth_provider                    *string
	external_id                      *string
	customer_id                      *string
	custom_attributes                *map[string]interface{}
	created_by                       *string
	password_reset_token_expires     *time.Time
	password_reset_token             *string
	login_count                      *int
	addlogin_count                   *int
	last_login_ip                    *string
	clearedFields                    map[string]struct{}
	organization                     *xid.ID
	clearedorganization              bool
	memberships                      map[xid.ID]struct{}
	removedmemberships               map[xid.ID]struct{}
	clearedmemberships               bool
	sent_invitations                 map[xid.ID]struct{}
	removedsent_invitations          map[xid.ID]struct{}
	clearedsent_invitations          bool
	sessions                         map[xid.ID]struct{}
	removedsessions                  map[xid.ID]struct{}
	clearedsessions                  bool
	api_keys                         map[xid.ID]struct{}
	removedapi_keys                  map[xid.ID]struct{}
	clearedapi_keys                  bool
	mfa_methods                      map[xid.ID]struct{}
	removedmfa_methods               map[xid.ID]struct{}
	clearedmfa_methods               bool
	passkeys                         map[xid.ID]struct{}
	removedpasskeys                  map[xid.ID]struct{}
	clearedpasskeys                  bool
	oauth_tokens                     map[xid.ID]struct{}
	removedoauth_tokens              map[xid.ID]struct{}
	clearedoauth_tokens              bool
	oauth_authorizations             map[xid.ID]struct{}
	removedoauth_authorizations      map[xid.ID]struct{}
	clearedoauth_authorizations      bool
	verifications                    map[xid.ID]struct{}
	removedverifications             map[xid.ID]struct{}
	clearedverifications             bool
	user_roles                       map[xid.ID]struct{}
	removeduser_roles                map[xid.ID]struct{}
	cleareduser_roles                bool
	user_permissions                 map[xid.ID]struct{}
	removeduser_permissions          map[xid.ID]struct{}
	cleareduser_permissions          bool
	system_roles                     map[xid.ID]struct{}
	removedsystem_roles              map[xid.ID]struct{}
	clearedsystem_roles              bool
	assigned_user_roles              map[xid.ID]struct{}
	removedassigned_user_roles       map[xid.ID]struct{}
	clearedassigned_user_roles       bool
	assigned_user_permissions        map[xid.ID]struct{}
	removedassigned_user_permissions map[xid.ID]struct{}
	clearedassigned_user_permissions bool
	audit_logs                       map[xid.ID]struct{}
	removedaudit_logs                map[xid.ID]struct{}
	clearedaudit_logs                bool
	activities                       map[xid.ID]struct{}
	removedactivities                map[xid.ID]struct{}
	clearedactivities                bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id xid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetBlocked sets the "blocked" field.
func (m *UserMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *UserMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *UserMutation) ResetBlocked() {
	m.blocked = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetLastPasswordChange sets the "last_password_change" field.
func (m *UserMutation) SetLastPasswordChange(t time.Time) {
	m.last_password_change = &t
}

// LastPasswordChange returns the value of the "last_password_change" field in the mutation.
func (m *UserMutation) LastPasswordChange() (r time.Time, exists bool) {
	v := m.last_password_change
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPasswordChange returns the old "last_password_change" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastPasswordChange(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPasswordChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPasswordChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPasswordChange: %w", err)
	}
	return oldValue.LastPasswordChange, nil
}

// ClearLastPasswordChange clears the value of the "last_password_change" field.
func (m *UserMutation) ClearLastPasswordChange() {
	m.last_password_change = nil
	m.clearedFields[user.FieldLastPasswordChange] = struct{}{}
}

// LastPasswordChangeCleared returns if the "last_password_change" field was cleared in this mutation.
func (m *UserMutation) LastPasswordChangeCleared() bool {
	_, ok := m.clearedFields[user.FieldLastPasswordChange]
	return ok
}

// ResetLastPasswordChange resets all changes to the "last_password_change" field.
func (m *UserMutation) ResetLastPasswordChange() {
	m.last_password_change = nil
	delete(m.clearedFields, user.FieldLastPasswordChange)
}

// SetMetadata sets the "metadata" field.
func (m *UserMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[user.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[user.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, user.FieldMetadata)
}

// SetProfileImageURL sets the "profile_image_url" field.
func (m *UserMutation) SetProfileImageURL(s string) {
	m.profile_image_url = &s
}

// ProfileImageURL returns the value of the "profile_image_url" field in the mutation.
func (m *UserMutation) ProfileImageURL() (r string, exists bool) {
	v := m.profile_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImageURL returns the old "profile_image_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfileImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImageURL: %w", err)
	}
	return oldValue.ProfileImageURL, nil
}

// ClearProfileImageURL clears the value of the "profile_image_url" field.
func (m *UserMutation) ClearProfileImageURL() {
	m.profile_image_url = nil
	m.clearedFields[user.FieldProfileImageURL] = struct{}{}
}

// ProfileImageURLCleared returns if the "profile_image_url" field was cleared in this mutation.
func (m *UserMutation) ProfileImageURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfileImageURL]
	return ok
}

// ResetProfileImageURL resets all changes to the "profile_image_url" field.
func (m *UserMutation) ResetProfileImageURL() {
	m.profile_image_url = nil
	delete(m.clearedFields, user.FieldProfileImageURL)
}

// SetLocale sets the "locale" field.
func (m *UserMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *UserMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *UserMutation) ResetLocale() {
	m.locale = nil
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *UserMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[user.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *UserMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[user.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, user.FieldTimezone)
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(mt model.UserType) {
	m.user_type = &mt
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r model.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v model.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *UserMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[user.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *UserMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[user.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, user.FieldOrganizationID)
}

// SetPrimaryOrganizationID sets the "primary_organization_id" field.
func (m *UserMutation) SetPrimaryOrganizationID(x xid.ID) {
	m.primary_organization_id = &x
}

// PrimaryOrganizationID returns the value of the "primary_organization_id" field in the mutation.
func (m *UserMutation) PrimaryOrganizationID() (r xid.ID, exists bool) {
	v := m.primary_organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryOrganizationID returns the old "primary_organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrimaryOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryOrganizationID: %w", err)
	}
	return oldValue.PrimaryOrganizationID, nil
}

// ClearPrimaryOrganizationID clears the value of the "primary_organization_id" field.
func (m *UserMutation) ClearPrimaryOrganizationID() {
	m.primary_organization_id = nil
	m.clearedFields[user.FieldPrimaryOrganizationID] = struct{}{}
}

// PrimaryOrganizationIDCleared returns if the "primary_organization_id" field was cleared in this mutation.
func (m *UserMutation) PrimaryOrganizationIDCleared() bool {
	_, ok := m.clearedFields[user.FieldPrimaryOrganizationID]
	return ok
}

// ResetPrimaryOrganizationID resets all changes to the "primary_organization_id" field.
func (m *UserMutation) ResetPrimaryOrganizationID() {
	m.primary_organization_id = nil
	delete(m.clearedFields, user.FieldPrimaryOrganizationID)
}

// SetIsPlatformAdmin sets the "is_platform_admin" field.
func (m *UserMutation) SetIsPlatformAdmin(b bool) {
	m.is_platform_admin = &b
}

// IsPlatformAdmin returns the value of the "is_platform_admin" field in the mutation.
func (m *UserMutation) IsPlatformAdmin() (r bool, exists bool) {
	v := m.is_platform_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPlatformAdmin returns the old "is_platform_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsPlatformAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPlatformAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPlatformAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPlatformAdmin: %w", err)
	}
	return oldValue.IsPlatformAdmin, nil
}

// ResetIsPlatformAdmin resets all changes to the "is_platform_admin" field.
func (m *UserMutation) ResetIsPlatformAdmin() {
	m.is_platform_admin = nil
}

// SetAuthProvider sets the "auth_provider" field.
func (m *UserMutation) SetAuthProvider(s string) {
	m.auth_provider = &s
}

// AuthProvider returns the value of the "auth_provider" field in the mutation.
func (m *UserMutation) AuthProvider() (r string, exists bool) {
	v := m.auth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProvider returns the old "auth_provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProvider: %w", err)
	}
	return oldValue.AuthProvider, nil
}

// ResetAuthProvider resets all changes to the "auth_provider" field.
func (m *UserMutation) ResetAuthProvider() {
	m.auth_provider = nil
}

// SetExternalID sets the "external_id" field.
func (m *UserMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *UserMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *UserMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[user.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *UserMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[user.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *UserMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, user.FieldExternalID)
}

// SetCustomerID sets the "customer_id" field.
func (m *UserMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *UserMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *UserMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[user.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *UserMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *UserMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, user.FieldCustomerID)
}

// SetCustomAttributes sets the "custom_attributes" field.
func (m *UserMutation) SetCustomAttributes(value map[string]interface{}) {
	m.custom_attributes = &value
}

// CustomAttributes returns the value of the "custom_attributes" field in the mutation.
func (m *UserMutation) CustomAttributes() (r map[string]interface{}, exists bool) {
	v := m.custom_attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomAttributes returns the old "custom_attributes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCustomAttributes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomAttributes: %w", err)
	}
	return oldValue.CustomAttributes, nil
}

// ClearCustomAttributes clears the value of the "custom_attributes" field.
func (m *UserMutation) ClearCustomAttributes() {
	m.custom_attributes = nil
	m.clearedFields[user.FieldCustomAttributes] = struct{}{}
}

// CustomAttributesCleared returns if the "custom_attributes" field was cleared in this mutation.
func (m *UserMutation) CustomAttributesCleared() bool {
	_, ok := m.clearedFields[user.FieldCustomAttributes]
	return ok
}

// ResetCustomAttributes resets all changes to the "custom_attributes" field.
func (m *UserMutation) ResetCustomAttributes() {
	m.custom_attributes = nil
	delete(m.clearedFields, user.FieldCustomAttributes)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetPasswordResetTokenExpires sets the "password_reset_token_expires" field.
func (m *UserMutation) SetPasswordResetTokenExpires(t time.Time) {
	m.password_reset_token_expires = &t
}

// PasswordResetTokenExpires returns the value of the "password_reset_token_expires" field in the mutation.
func (m *UserMutation) PasswordResetTokenExpires() (r time.Time, exists bool) {
	v := m.password_reset_token_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetTokenExpires returns the old "password_reset_token_expires" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetTokenExpires(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetTokenExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetTokenExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetTokenExpires: %w", err)
	}
	return oldValue.PasswordResetTokenExpires, nil
}

// ClearPasswordResetTokenExpires clears the value of the "password_reset_token_expires" field.
func (m *UserMutation) ClearPasswordResetTokenExpires() {
	m.password_reset_token_expires = nil
	m.clearedFields[user.FieldPasswordResetTokenExpires] = struct{}{}
}

// PasswordResetTokenExpiresCleared returns if the "password_reset_token_expires" field was cleared in this mutation.
func (m *UserMutation) PasswordResetTokenExpiresCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordResetTokenExpires]
	return ok
}

// ResetPasswordResetTokenExpires resets all changes to the "password_reset_token_expires" field.
func (m *UserMutation) ResetPasswordResetTokenExpires() {
	m.password_reset_token_expires = nil
	delete(m.clearedFields, user.FieldPasswordResetTokenExpires)
}

// SetPasswordResetToken sets the "password_reset_token" field.
func (m *UserMutation) SetPasswordResetToken(s string) {
	m.password_reset_token = &s
}

// PasswordResetToken returns the value of the "password_reset_token" field in the mutation.
func (m *UserMutation) PasswordResetToken() (r string, exists bool) {
	v := m.password_reset_token
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetToken returns the old "password_reset_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetToken: %w", err)
	}
	return oldValue.PasswordResetToken, nil
}

// ClearPasswordResetToken clears the value of the "password_reset_token" field.
func (m *UserMutation) ClearPasswordResetToken() {
	m.password_reset_token = nil
	m.clearedFields[user.FieldPasswordResetToken] = struct{}{}
}

// PasswordResetTokenCleared returns if the "password_reset_token" field was cleared in this mutation.
func (m *UserMutation) PasswordResetTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordResetToken]
	return ok
}

// ResetPasswordResetToken resets all changes to the "password_reset_token" field.
func (m *UserMutation) ResetPasswordResetToken() {
	m.password_reset_token = nil
	delete(m.clearedFields, user.FieldPasswordResetToken)
}

// SetLoginCount sets the "login_count" field.
func (m *UserMutation) SetLoginCount(i int) {
	m.login_count = &i
	m.addlogin_count = nil
}

// LoginCount returns the value of the "login_count" field in the mutation.
func (m *UserMutation) LoginCount() (r int, exists bool) {
	v := m.login_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginCount returns the old "login_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginCount: %w", err)
	}
	return oldValue.LoginCount, nil
}

// AddLoginCount adds i to the "login_count" field.
func (m *UserMutation) AddLoginCount(i int) {
	if m.addlogin_count != nil {
		*m.addlogin_count += i
	} else {
		m.addlogin_count = &i
	}
}

// AddedLoginCount returns the value that was added to the "login_count" field in this mutation.
func (m *UserMutation) AddedLoginCount() (r int, exists bool) {
	v := m.addlogin_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginCount resets all changes to the "login_count" field.
func (m *UserMutation) ResetLoginCount() {
	m.login_count = nil
	m.addlogin_count = nil
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[user.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, user.FieldLastLoginIP)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[user.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddMembershipIDs adds the "memberships" edge to the Membership entity by ids.
func (m *UserMutation) AddMembershipIDs(ids ...xid.ID) {
	if m.memberships == nil {
		m.memberships = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the Membership entity.
func (m *UserMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the Membership entity was cleared.
func (m *UserMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the Membership entity by IDs.
func (m *UserMutation) RemoveMembershipIDs(ids ...xid.ID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the Membership entity.
func (m *UserMutation) RemovedMembershipsIDs() (ids []xid.ID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *UserMutation) MembershipsIDs() (ids []xid.ID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *UserMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddSentInvitationIDs adds the "sent_invitations" edge to the Membership entity by ids.
func (m *UserMutation) AddSentInvitationIDs(ids ...xid.ID) {
	if m.sent_invitations == nil {
		m.sent_invitations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.sent_invitations[ids[i]] = struct{}{}
	}
}

// ClearSentInvitations clears the "sent_invitations" edge to the Membership entity.
func (m *UserMutation) ClearSentInvitations() {
	m.clearedsent_invitations = true
}

// SentInvitationsCleared reports if the "sent_invitations" edge to the Membership entity was cleared.
func (m *UserMutation) SentInvitationsCleared() bool {
	return m.clearedsent_invitations
}

// RemoveSentInvitationIDs removes the "sent_invitations" edge to the Membership entity by IDs.
func (m *UserMutation) RemoveSentInvitationIDs(ids ...xid.ID) {
	if m.removedsent_invitations == nil {
		m.removedsent_invitations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.sent_invitations, ids[i])
		m.removedsent_invitations[ids[i]] = struct{}{}
	}
}

// RemovedSentInvitations returns the removed IDs of the "sent_invitations" edge to the Membership entity.
func (m *UserMutation) RemovedSentInvitationsIDs() (ids []xid.ID) {
	for id := range m.removedsent_invitations {
		ids = append(ids, id)
	}
	return
}

// SentInvitationsIDs returns the "sent_invitations" edge IDs in the mutation.
func (m *UserMutation) SentInvitationsIDs() (ids []xid.ID) {
	for id := range m.sent_invitations {
		ids = append(ids, id)
	}
	return
}

// ResetSentInvitations resets all changes to the "sent_invitations" edge.
func (m *UserMutation) ResetSentInvitations() {
	m.sent_invitations = nil
	m.clearedsent_invitations = false
	m.removedsent_invitations = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...xid.ID) {
	if m.sessions == nil {
		m.sessions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...xid.ID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []xid.ID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []xid.ID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...xid.ID) {
	if m.api_keys == nil {
		m.api_keys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...xid.ID) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []xid.ID) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []xid.ID) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddMfaMethodIDs adds the "mfa_methods" edge to the MFA entity by ids.
func (m *UserMutation) AddMfaMethodIDs(ids ...xid.ID) {
	if m.mfa_methods == nil {
		m.mfa_methods = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.mfa_methods[ids[i]] = struct{}{}
	}
}

// ClearMfaMethods clears the "mfa_methods" edge to the MFA entity.
func (m *UserMutation) ClearMfaMethods() {
	m.clearedmfa_methods = true
}

// MfaMethodsCleared reports if the "mfa_methods" edge to the MFA entity was cleared.
func (m *UserMutation) MfaMethodsCleared() bool {
	return m.clearedmfa_methods
}

// RemoveMfaMethodIDs removes the "mfa_methods" edge to the MFA entity by IDs.
func (m *UserMutation) RemoveMfaMethodIDs(ids ...xid.ID) {
	if m.removedmfa_methods == nil {
		m.removedmfa_methods = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.mfa_methods, ids[i])
		m.removedmfa_methods[ids[i]] = struct{}{}
	}
}

// RemovedMfaMethods returns the removed IDs of the "mfa_methods" edge to the MFA entity.
func (m *UserMutation) RemovedMfaMethodsIDs() (ids []xid.ID) {
	for id := range m.removedmfa_methods {
		ids = append(ids, id)
	}
	return
}

// MfaMethodsIDs returns the "mfa_methods" edge IDs in the mutation.
func (m *UserMutation) MfaMethodsIDs() (ids []xid.ID) {
	for id := range m.mfa_methods {
		ids = append(ids, id)
	}
	return
}

// ResetMfaMethods resets all changes to the "mfa_methods" edge.
func (m *UserMutation) ResetMfaMethods() {
	m.mfa_methods = nil
	m.clearedmfa_methods = false
	m.removedmfa_methods = nil
}

// AddPasskeyIDs adds the "passkeys" edge to the Passkey entity by ids.
func (m *UserMutation) AddPasskeyIDs(ids ...xid.ID) {
	if m.passkeys == nil {
		m.passkeys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.passkeys[ids[i]] = struct{}{}
	}
}

// ClearPasskeys clears the "passkeys" edge to the Passkey entity.
func (m *UserMutation) ClearPasskeys() {
	m.clearedpasskeys = true
}

// PasskeysCleared reports if the "passkeys" edge to the Passkey entity was cleared.
func (m *UserMutation) PasskeysCleared() bool {
	return m.clearedpasskeys
}

// RemovePasskeyIDs removes the "passkeys" edge to the Passkey entity by IDs.
func (m *UserMutation) RemovePasskeyIDs(ids ...xid.ID) {
	if m.removedpasskeys == nil {
		m.removedpasskeys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.passkeys, ids[i])
		m.removedpasskeys[ids[i]] = struct{}{}
	}
}

// RemovedPasskeys returns the removed IDs of the "passkeys" edge to the Passkey entity.
func (m *UserMutation) RemovedPasskeysIDs() (ids []xid.ID) {
	for id := range m.removedpasskeys {
		ids = append(ids, id)
	}
	return
}

// PasskeysIDs returns the "passkeys" edge IDs in the mutation.
func (m *UserMutation) PasskeysIDs() (ids []xid.ID) {
	for id := range m.passkeys {
		ids = append(ids, id)
	}
	return
}

// ResetPasskeys resets all changes to the "passkeys" edge.
func (m *UserMutation) ResetPasskeys() {
	m.passkeys = nil
	m.clearedpasskeys = false
	m.removedpasskeys = nil
}

// AddOauthTokenIDs adds the "oauth_tokens" edge to the OAuthToken entity by ids.
func (m *UserMutation) AddOauthTokenIDs(ids ...xid.ID) {
	if m.oauth_tokens == nil {
		m.oauth_tokens = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.oauth_tokens[ids[i]] = struct{}{}
	}
}

// ClearOauthTokens clears the "oauth_tokens" edge to the OAuthToken entity.
func (m *UserMutation) ClearOauthTokens() {
	m.clearedoauth_tokens = true
}

// OauthTokensCleared reports if the "oauth_tokens" edge to the OAuthToken entity was cleared.
func (m *UserMutation) OauthTokensCleared() bool {
	return m.clearedoauth_tokens
}

// RemoveOauthTokenIDs removes the "oauth_tokens" edge to the OAuthToken entity by IDs.
func (m *UserMutation) RemoveOauthTokenIDs(ids ...xid.ID) {
	if m.removedoauth_tokens == nil {
		m.removedoauth_tokens = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.oauth_tokens, ids[i])
		m.removedoauth_tokens[ids[i]] = struct{}{}
	}
}

// RemovedOauthTokens returns the removed IDs of the "oauth_tokens" edge to the OAuthToken entity.
func (m *UserMutation) RemovedOauthTokensIDs() (ids []xid.ID) {
	for id := range m.removedoauth_tokens {
		ids = append(ids, id)
	}
	return
}

// OauthTokensIDs returns the "oauth_tokens" edge IDs in the mutation.
func (m *UserMutation) OauthTokensIDs() (ids []xid.ID) {
	for id := range m.oauth_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetOauthTokens resets all changes to the "oauth_tokens" edge.
func (m *UserMutation) ResetOauthTokens() {
	m.oauth_tokens = nil
	m.clearedoauth_tokens = false
	m.removedoauth_tokens = nil
}

// AddOauthAuthorizationIDs adds the "oauth_authorizations" edge to the OAuthAuthorization entity by ids.
func (m *UserMutation) AddOauthAuthorizationIDs(ids ...xid.ID) {
	if m.oauth_authorizations == nil {
		m.oauth_authorizations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.oauth_authorizations[ids[i]] = struct{}{}
	}
}

// ClearOauthAuthorizations clears the "oauth_authorizations" edge to the OAuthAuthorization entity.
func (m *UserMutation) ClearOauthAuthorizations() {
	m.clearedoauth_authorizations = true
}

// OauthAuthorizationsCleared reports if the "oauth_authorizations" edge to the OAuthAuthorization entity was cleared.
func (m *UserMutation) OauthAuthorizationsCleared() bool {
	return m.clearedoauth_authorizations
}

// RemoveOauthAuthorizationIDs removes the "oauth_authorizations" edge to the OAuthAuthorization entity by IDs.
func (m *UserMutation) RemoveOauthAuthorizationIDs(ids ...xid.ID) {
	if m.removedoauth_authorizations == nil {
		m.removedoauth_authorizations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.oauth_authorizations, ids[i])
		m.removedoauth_authorizations[ids[i]] = struct{}{}
	}
}

// RemovedOauthAuthorizations returns the removed IDs of the "oauth_authorizations" edge to the OAuthAuthorization entity.
func (m *UserMutation) RemovedOauthAuthorizationsIDs() (ids []xid.ID) {
	for id := range m.removedoauth_authorizations {
		ids = append(ids, id)
	}
	return
}

// OauthAuthorizationsIDs returns the "oauth_authorizations" edge IDs in the mutation.
func (m *UserMutation) OauthAuthorizationsIDs() (ids []xid.ID) {
	for id := range m.oauth_authorizations {
		ids = append(ids, id)
	}
	return
}

// ResetOauthAuthorizations resets all changes to the "oauth_authorizations" edge.
func (m *UserMutation) ResetOauthAuthorizations() {
	m.oauth_authorizations = nil
	m.clearedoauth_authorizations = false
	m.removedoauth_authorizations = nil
}

// AddVerificationIDs adds the "verifications" edge to the Verification entity by ids.
func (m *UserMutation) AddVerificationIDs(ids ...xid.ID) {
	if m.verifications == nil {
		m.verifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.verifications[ids[i]] = struct{}{}
	}
}

// ClearVerifications clears the "verifications" edge to the Verification entity.
func (m *UserMutation) ClearVerifications() {
	m.clearedverifications = true
}

// VerificationsCleared reports if the "verifications" edge to the Verification entity was cleared.
func (m *UserMutation) VerificationsCleared() bool {
	return m.clearedverifications
}

// RemoveVerificationIDs removes the "verifications" edge to the Verification entity by IDs.
func (m *UserMutation) RemoveVerificationIDs(ids ...xid.ID) {
	if m.removedverifications == nil {
		m.removedverifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.verifications, ids[i])
		m.removedverifications[ids[i]] = struct{}{}
	}
}

// RemovedVerifications returns the removed IDs of the "verifications" edge to the Verification entity.
func (m *UserMutation) RemovedVerificationsIDs() (ids []xid.ID) {
	for id := range m.removedverifications {
		ids = append(ids, id)
	}
	return
}

// VerificationsIDs returns the "verifications" edge IDs in the mutation.
func (m *UserMutation) VerificationsIDs() (ids []xid.ID) {
	for id := range m.verifications {
		ids = append(ids, id)
	}
	return
}

// ResetVerifications resets all changes to the "verifications" edge.
func (m *UserMutation) ResetVerifications() {
	m.verifications = nil
	m.clearedverifications = false
	m.removedverifications = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...xid.ID) {
	if m.user_roles == nil {
		m.user_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...xid.ID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []xid.ID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []xid.ID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddUserPermissionIDs adds the "user_permissions" edge to the UserPermission entity by ids.
func (m *UserMutation) AddUserPermissionIDs(ids ...xid.ID) {
	if m.user_permissions == nil {
		m.user_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.user_permissions[ids[i]] = struct{}{}
	}
}

// ClearUserPermissions clears the "user_permissions" edge to the UserPermission entity.
func (m *UserMutation) ClearUserPermissions() {
	m.cleareduser_permissions = true
}

// UserPermissionsCleared reports if the "user_permissions" edge to the UserPermission entity was cleared.
func (m *UserMutation) UserPermissionsCleared() bool {
	return m.cleareduser_permissions
}

// RemoveUserPermissionIDs removes the "user_permissions" edge to the UserPermission entity by IDs.
func (m *UserMutation) RemoveUserPermissionIDs(ids ...xid.ID) {
	if m.removeduser_permissions == nil {
		m.removeduser_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.user_permissions, ids[i])
		m.removeduser_permissions[ids[i]] = struct{}{}
	}
}

// RemovedUserPermissions returns the removed IDs of the "user_permissions" edge to the UserPermission entity.
func (m *UserMutation) RemovedUserPermissionsIDs() (ids []xid.ID) {
	for id := range m.removeduser_permissions {
		ids = append(ids, id)
	}
	return
}

// UserPermissionsIDs returns the "user_permissions" edge IDs in the mutation.
func (m *UserMutation) UserPermissionsIDs() (ids []xid.ID) {
	for id := range m.user_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetUserPermissions resets all changes to the "user_permissions" edge.
func (m *UserMutation) ResetUserPermissions() {
	m.user_permissions = nil
	m.cleareduser_permissions = false
	m.removeduser_permissions = nil
}

// AddSystemRoleIDs adds the "system_roles" edge to the Role entity by ids.
func (m *UserMutation) AddSystemRoleIDs(ids ...xid.ID) {
	if m.system_roles == nil {
		m.system_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.system_roles[ids[i]] = struct{}{}
	}
}

// ClearSystemRoles clears the "system_roles" edge to the Role entity.
func (m *UserMutation) ClearSystemRoles() {
	m.clearedsystem_roles = true
}

// SystemRolesCleared reports if the "system_roles" edge to the Role entity was cleared.
func (m *UserMutation) SystemRolesCleared() bool {
	return m.clearedsystem_roles
}

// RemoveSystemRoleIDs removes the "system_roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveSystemRoleIDs(ids ...xid.ID) {
	if m.removedsystem_roles == nil {
		m.removedsystem_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.system_roles, ids[i])
		m.removedsystem_roles[ids[i]] = struct{}{}
	}
}

// RemovedSystemRoles returns the removed IDs of the "system_roles" edge to the Role entity.
func (m *UserMutation) RemovedSystemRolesIDs() (ids []xid.ID) {
	for id := range m.removedsystem_roles {
		ids = append(ids, id)
	}
	return
}

// SystemRolesIDs returns the "system_roles" edge IDs in the mutation.
func (m *UserMutation) SystemRolesIDs() (ids []xid.ID) {
	for id := range m.system_roles {
		ids = append(ids, id)
	}
	return
}

// ResetSystemRoles resets all changes to the "system_roles" edge.
func (m *UserMutation) ResetSystemRoles() {
	m.system_roles = nil
	m.clearedsystem_roles = false
	m.removedsystem_roles = nil
}

// AddAssignedUserRoleIDs adds the "assigned_user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddAssignedUserRoleIDs(ids ...xid.ID) {
	if m.assigned_user_roles == nil {
		m.assigned_user_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assigned_user_roles[ids[i]] = struct{}{}
	}
}

// ClearAssignedUserRoles clears the "assigned_user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearAssignedUserRoles() {
	m.clearedassigned_user_roles = true
}

// AssignedUserRolesCleared reports if the "assigned_user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) AssignedUserRolesCleared() bool {
	return m.clearedassigned_user_roles
}

// RemoveAssignedUserRoleIDs removes the "assigned_user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveAssignedUserRoleIDs(ids ...xid.ID) {
	if m.removedassigned_user_roles == nil {
		m.removedassigned_user_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assigned_user_roles, ids[i])
		m.removedassigned_user_roles[ids[i]] = struct{}{}
	}
}

// RemovedAssignedUserRoles returns the removed IDs of the "assigned_user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedAssignedUserRolesIDs() (ids []xid.ID) {
	for id := range m.removedassigned_user_roles {
		ids = append(ids, id)
	}
	return
}

// AssignedUserRolesIDs returns the "assigned_user_roles" edge IDs in the mutation.
func (m *UserMutation) AssignedUserRolesIDs() (ids []xid.ID) {
	for id := range m.assigned_user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedUserRoles resets all changes to the "assigned_user_roles" edge.
func (m *UserMutation) ResetAssignedUserRoles() {
	m.assigned_user_roles = nil
	m.clearedassigned_user_roles = false
	m.removedassigned_user_roles = nil
}

// AddAssignedUserPermissionIDs adds the "assigned_user_permissions" edge to the UserPermission entity by ids.
func (m *UserMutation) AddAssignedUserPermissionIDs(ids ...xid.ID) {
	if m.assigned_user_permissions == nil {
		m.assigned_user_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assigned_user_permissions[ids[i]] = struct{}{}
	}
}

// ClearAssignedUserPermissions clears the "assigned_user_permissions" edge to the UserPermission entity.
func (m *UserMutation) ClearAssignedUserPermissions() {
	m.clearedassigned_user_permissions = true
}

// AssignedUserPermissionsCleared reports if the "assigned_user_permissions" edge to the UserPermission entity was cleared.
func (m *UserMutation) AssignedUserPermissionsCleared() bool {
	return m.clearedassigned_user_permissions
}

// RemoveAssignedUserPermissionIDs removes the "assigned_user_permissions" edge to the UserPermission entity by IDs.
func (m *UserMutation) RemoveAssignedUserPermissionIDs(ids ...xid.ID) {
	if m.removedassigned_user_permissions == nil {
		m.removedassigned_user_permissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assigned_user_permissions, ids[i])
		m.removedassigned_user_permissions[ids[i]] = struct{}{}
	}
}

// RemovedAssignedUserPermissions returns the removed IDs of the "assigned_user_permissions" edge to the UserPermission entity.
func (m *UserMutation) RemovedAssignedUserPermissionsIDs() (ids []xid.ID) {
	for id := range m.removedassigned_user_permissions {
		ids = append(ids, id)
	}
	return
}

// AssignedUserPermissionsIDs returns the "assigned_user_permissions" edge IDs in the mutation.
func (m *UserMutation) AssignedUserPermissionsIDs() (ids []xid.ID) {
	for id := range m.assigned_user_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedUserPermissions resets all changes to the "assigned_user_permissions" edge.
func (m *UserMutation) ResetAssignedUserPermissions() {
	m.assigned_user_permissions = nil
	m.clearedassigned_user_permissions = false
	m.removedassigned_user_permissions = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the Audit entity by ids.
func (m *UserMutation) AddAuditLogIDs(ids ...xid.ID) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the Audit entity.
func (m *UserMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the Audit entity was cleared.
func (m *UserMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the Audit entity by IDs.
func (m *UserMutation) RemoveAuditLogIDs(ids ...xid.ID) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the Audit entity.
func (m *UserMutation) RemovedAuditLogsIDs() (ids []xid.ID) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *UserMutation) AuditLogsIDs() (ids []xid.ID) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *UserMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *UserMutation) AddActivityIDs(ids ...xid.ID) {
	if m.activities == nil {
		m.activities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *UserMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *UserMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *UserMutation) RemoveActivityIDs(ids ...xid.ID) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *UserMutation) RemovedActivitiesIDs() (ids []xid.ID) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *UserMutation) ActivitiesIDs() (ids []xid.ID) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *UserMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.blocked != nil {
		fields = append(fields, user.FieldBlocked)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.last_password_change != nil {
		fields = append(fields, user.FieldLastPasswordChange)
	}
	if m.metadata != nil {
		fields = append(fields, user.FieldMetadata)
	}
	if m.profile_image_url != nil {
		fields = append(fields, user.FieldProfileImageURL)
	}
	if m.locale != nil {
		fields = append(fields, user.FieldLocale)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganizationID)
	}
	if m.primary_organization_id != nil {
		fields = append(fields, user.FieldPrimaryOrganizationID)
	}
	if m.is_platform_admin != nil {
		fields = append(fields, user.FieldIsPlatformAdmin)
	}
	if m.auth_provider != nil {
		fields = append(fields, user.FieldAuthProvider)
	}
	if m.external_id != nil {
		fields = append(fields, user.FieldExternalID)
	}
	if m.customer_id != nil {
		fields = append(fields, user.FieldCustomerID)
	}
	if m.custom_attributes != nil {
		fields = append(fields, user.FieldCustomAttributes)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.password_reset_token_expires != nil {
		fields = append(fields, user.FieldPasswordResetTokenExpires)
	}
	if m.password_reset_token != nil {
		fields = append(fields, user.FieldPasswordResetToken)
	}
	if m.login_count != nil {
		fields = append(fields, user.FieldLoginCount)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldActive:
		return m.Active()
	case user.FieldBlocked:
		return m.Blocked()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldLastPasswordChange:
		return m.LastPasswordChange()
	case user.FieldMetadata:
		return m.Metadata()
	case user.FieldProfileImageURL:
		return m.ProfileImageURL()
	case user.FieldLocale:
		return m.Locale()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldOrganizationID:
		return m.OrganizationID()
	case user.FieldPrimaryOrganizationID:
		return m.PrimaryOrganizationID()
	case user.FieldIsPlatformAdmin:
		return m.IsPlatformAdmin()
	case user.FieldAuthProvider:
		return m.AuthProvider()
	case user.FieldExternalID:
		return m.ExternalID()
	case user.FieldCustomerID:
		return m.CustomerID()
	case user.FieldCustomAttributes:
		return m.CustomAttributes()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldPasswordResetTokenExpires:
		return m.PasswordResetTokenExpires()
	case user.FieldPasswordResetToken:
		return m.PasswordResetToken()
	case user.FieldLoginCount:
		return m.LoginCount()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldBlocked:
		return m.OldBlocked(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldLastPasswordChange:
		return m.OldLastPasswordChange(ctx)
	case user.FieldMetadata:
		return m.OldMetadata(ctx)
	case user.FieldProfileImageURL:
		return m.OldProfileImageURL(ctx)
	case user.FieldLocale:
		return m.OldLocale(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case user.FieldPrimaryOrganizationID:
		return m.OldPrimaryOrganizationID(ctx)
	case user.FieldIsPlatformAdmin:
		return m.OldIsPlatformAdmin(ctx)
	case user.FieldAuthProvider:
		return m.OldAuthProvider(ctx)
	case user.FieldExternalID:
		return m.OldExternalID(ctx)
	case user.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case user.FieldCustomAttributes:
		return m.OldCustomAttributes(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldPasswordResetTokenExpires:
		return m.OldPasswordResetTokenExpires(ctx)
	case user.FieldPasswordResetToken:
		return m.OldPasswordResetToken(ctx)
	case user.FieldLoginCount:
		return m.OldLoginCount(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldLastPasswordChange:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPasswordChange(v)
		return nil
	case user.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case user.FieldProfileImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImageURL(v)
		return nil
	case user.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(model.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case user.FieldPrimaryOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryOrganizationID(v)
		return nil
	case user.FieldIsPlatformAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPlatformAdmin(v)
		return nil
	case user.FieldAuthProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProvider(v)
		return nil
	case user.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case user.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case user.FieldCustomAttributes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomAttributes(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldPasswordResetTokenExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetTokenExpires(v)
		return nil
	case user.FieldPasswordResetToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetToken(v)
		return nil
	case user.FieldLoginCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginCount(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addlogin_count != nil {
		fields = append(fields, user.FieldLoginCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLoginCount:
		return m.AddedLoginCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldLoginCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginCount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.FieldCleared(user.FieldLastPasswordChange) {
		fields = append(fields, user.FieldLastPasswordChange)
	}
	if m.FieldCleared(user.FieldMetadata) {
		fields = append(fields, user.FieldMetadata)
	}
	if m.FieldCleared(user.FieldProfileImageURL) {
		fields = append(fields, user.FieldProfileImageURL)
	}
	if m.FieldCleared(user.FieldTimezone) {
		fields = append(fields, user.FieldTimezone)
	}
	if m.FieldCleared(user.FieldOrganizationID) {
		fields = append(fields, user.FieldOrganizationID)
	}
	if m.FieldCleared(user.FieldPrimaryOrganizationID) {
		fields = append(fields, user.FieldPrimaryOrganizationID)
	}
	if m.FieldCleared(user.FieldExternalID) {
		fields = append(fields, user.FieldExternalID)
	}
	if m.FieldCleared(user.FieldCustomerID) {
		fields = append(fields, user.FieldCustomerID)
	}
	if m.FieldCleared(user.FieldCustomAttributes) {
		fields = append(fields, user.FieldCustomAttributes)
	}
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldPasswordResetTokenExpires) {
		fields = append(fields, user.FieldPasswordResetTokenExpires)
	}
	if m.FieldCleared(user.FieldPasswordResetToken) {
		fields = append(fields, user.FieldPasswordResetToken)
	}
	if m.FieldCleared(user.FieldLastLoginIP) {
		fields = append(fields, user.FieldLastLoginIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	case user.FieldLastPasswordChange:
		m.ClearLastPasswordChange()
		return nil
	case user.FieldMetadata:
		m.ClearMetadata()
		return nil
	case user.FieldProfileImageURL:
		m.ClearProfileImageURL()
		return nil
	case user.FieldTimezone:
		m.ClearTimezone()
		return nil
	case user.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case user.FieldPrimaryOrganizationID:
		m.ClearPrimaryOrganizationID()
		return nil
	case user.FieldExternalID:
		m.ClearExternalID()
		return nil
	case user.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case user.FieldCustomAttributes:
		m.ClearCustomAttributes()
		return nil
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldPasswordResetTokenExpires:
		m.ClearPasswordResetTokenExpires()
		return nil
	case user.FieldPasswordResetToken:
		m.ClearPasswordResetToken()
		return nil
	case user.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldBlocked:
		m.ResetBlocked()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldLastPasswordChange:
		m.ResetLastPasswordChange()
		return nil
	case user.FieldMetadata:
		m.ResetMetadata()
		return nil
	case user.FieldProfileImageURL:
		m.ResetProfileImageURL()
		return nil
	case user.FieldLocale:
		m.ResetLocale()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case user.FieldPrimaryOrganizationID:
		m.ResetPrimaryOrganizationID()
		return nil
	case user.FieldIsPlatformAdmin:
		m.ResetIsPlatformAdmin()
		return nil
	case user.FieldAuthProvider:
		m.ResetAuthProvider()
		return nil
	case user.FieldExternalID:
		m.ResetExternalID()
		return nil
	case user.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case user.FieldCustomAttributes:
		m.ResetCustomAttributes()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldPasswordResetTokenExpires:
		m.ResetPasswordResetTokenExpires()
		return nil
	case user.FieldPasswordResetToken:
		m.ResetPasswordResetToken()
		return nil
	case user.FieldLoginCount:
		m.ResetLoginCount()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.memberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.sent_invitations != nil {
		edges = append(edges, user.EdgeSentInvitations)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.mfa_methods != nil {
		edges = append(edges, user.EdgeMfaMethods)
	}
	if m.passkeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.oauth_tokens != nil {
		edges = append(edges, user.EdgeOauthTokens)
	}
	if m.oauth_authorizations != nil {
		edges = append(edges, user.EdgeOauthAuthorizations)
	}
	if m.verifications != nil {
		edges = append(edges, user.EdgeVerifications)
	}
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.user_permissions != nil {
		edges = append(edges, user.EdgeUserPermissions)
	}
	if m.system_roles != nil {
		edges = append(edges, user.EdgeSystemRoles)
	}
	if m.assigned_user_roles != nil {
		edges = append(edges, user.EdgeAssignedUserRoles)
	}
	if m.assigned_user_permissions != nil {
		edges = append(edges, user.EdgeAssignedUserPermissions)
	}
	if m.audit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.activities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentInvitations:
		ids := make([]ent.Value, 0, len(m.sent_invitations))
		for id := range m.sent_invitations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaMethods:
		ids := make([]ent.Value, 0, len(m.mfa_methods))
		for id := range m.mfa_methods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.passkeys))
		for id := range m.passkeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthTokens:
		ids := make([]ent.Value, 0, len(m.oauth_tokens))
		for id := range m.oauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthAuthorizations:
		ids := make([]ent.Value, 0, len(m.oauth_authorizations))
		for id := range m.oauth_authorizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVerifications:
		ids := make([]ent.Value, 0, len(m.verifications))
		for id := range m.verifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPermissions:
		ids := make([]ent.Value, 0, len(m.user_permissions))
		for id := range m.user_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSystemRoles:
		ids := make([]ent.Value, 0, len(m.system_roles))
		for id := range m.system_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedUserRoles:
		ids := make([]ent.Value, 0, len(m.assigned_user_roles))
		for id := range m.assigned_user_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedUserPermissions:
		ids := make([]ent.Value, 0, len(m.assigned_user_permissions))
		for id := range m.assigned_user_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedmemberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.removedsent_invitations != nil {
		edges = append(edges, user.EdgeSentInvitations)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedmfa_methods != nil {
		edges = append(edges, user.EdgeMfaMethods)
	}
	if m.removedpasskeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.removedoauth_tokens != nil {
		edges = append(edges, user.EdgeOauthTokens)
	}
	if m.removedoauth_authorizations != nil {
		edges = append(edges, user.EdgeOauthAuthorizations)
	}
	if m.removedverifications != nil {
		edges = append(edges, user.EdgeVerifications)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.removeduser_permissions != nil {
		edges = append(edges, user.EdgeUserPermissions)
	}
	if m.removedsystem_roles != nil {
		edges = append(edges, user.EdgeSystemRoles)
	}
	if m.removedassigned_user_roles != nil {
		edges = append(edges, user.EdgeAssignedUserRoles)
	}
	if m.removedassigned_user_permissions != nil {
		edges = append(edges, user.EdgeAssignedUserPermissions)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.removedactivities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentInvitations:
		ids := make([]ent.Value, 0, len(m.removedsent_invitations))
		for id := range m.removedsent_invitations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaMethods:
		ids := make([]ent.Value, 0, len(m.removedmfa_methods))
		for id := range m.removedmfa_methods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.removedpasskeys))
		for id := range m.removedpasskeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthTokens:
		ids := make([]ent.Value, 0, len(m.removedoauth_tokens))
		for id := range m.removedoauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthAuthorizations:
		ids := make([]ent.Value, 0, len(m.removedoauth_authorizations))
		for id := range m.removedoauth_authorizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVerifications:
		ids := make([]ent.Value, 0, len(m.removedverifications))
		for id := range m.removedverifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPermissions:
		ids := make([]ent.Value, 0, len(m.removeduser_permissions))
		for id := range m.removeduser_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSystemRoles:
		ids := make([]ent.Value, 0, len(m.removedsystem_roles))
		for id := range m.removedsystem_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedUserRoles:
		ids := make([]ent.Value, 0, len(m.removedassigned_user_roles))
		for id := range m.removedassigned_user_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedUserPermissions:
		ids := make([]ent.Value, 0, len(m.removedassigned_user_permissions))
		for id := range m.removedassigned_user_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.clearedmemberships {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.clearedsent_invitations {
		edges = append(edges, user.EdgeSentInvitations)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedmfa_methods {
		edges = append(edges, user.EdgeMfaMethods)
	}
	if m.clearedpasskeys {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.clearedoauth_tokens {
		edges = append(edges, user.EdgeOauthTokens)
	}
	if m.clearedoauth_authorizations {
		edges = append(edges, user.EdgeOauthAuthorizations)
	}
	if m.clearedverifications {
		edges = append(edges, user.EdgeVerifications)
	}
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.cleareduser_permissions {
		edges = append(edges, user.EdgeUserPermissions)
	}
	if m.clearedsystem_roles {
		edges = append(edges, user.EdgeSystemRoles)
	}
	if m.clearedassigned_user_roles {
		edges = append(edges, user.EdgeAssignedUserRoles)
	}
	if m.clearedassigned_user_permissions {
		edges = append(edges, user.EdgeAssignedUserPermissions)
	}
	if m.clearedaudit_logs {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.clearedactivities {
		edges = append(edges, user.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOrganization:
		return m.clearedorganization
	case user.EdgeMemberships:
		return m.clearedmemberships
	case user.EdgeSentInvitations:
		return m.clearedsent_invitations
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeMfaMethods:
		return m.clearedmfa_methods
	case user.EdgePasskeys:
		return m.clearedpasskeys
	case user.EdgeOauthTokens:
		return m.clearedoauth_tokens
	case user.EdgeOauthAuthorizations:
		return m.clearedoauth_authorizations
	case user.EdgeVerifications:
		return m.clearedverifications
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	case user.EdgeUserPermissions:
		return m.cleareduser_permissions
	case user.EdgeSystemRoles:
		return m.clearedsystem_roles
	case user.EdgeAssignedUserRoles:
		return m.clearedassigned_user_roles
	case user.EdgeAssignedUserPermissions:
		return m.clearedassigned_user_permissions
	case user.EdgeAuditLogs:
		return m.clearedaudit_logs
	case user.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case user.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case user.EdgeSentInvitations:
		m.ResetSentInvitations()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeMfaMethods:
		m.ResetMfaMethods()
		return nil
	case user.EdgePasskeys:
		m.ResetPasskeys()
		return nil
	case user.EdgeOauthTokens:
		m.ResetOauthTokens()
		return nil
	case user.EdgeOauthAuthorizations:
		m.ResetOauthAuthorizations()
		return nil
	case user.EdgeVerifications:
		m.ResetVerifications()
		return nil
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case user.EdgeUserPermissions:
		m.ResetUserPermissions()
		return nil
	case user.EdgeSystemRoles:
		m.ResetSystemRoles()
		return nil
	case user.EdgeAssignedUserRoles:
		m.ResetAssignedUserRoles()
		return nil
	case user.EdgeAssignedUserPermissions:
		m.ResetAssignedUserPermissions()
		return nil
	case user.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case user.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserPermissionMutation represents an operation that mutates the UserPermission nodes in the graph.
type UserPermissionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *xid.ID
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	context_type                *model.ContextType
	resource_type               *string
	resource_id                 *xid.ID
	permission_type             *model.PermissionType
	assigned_at                 *time.Time
	expires_at                  *time.Time
	active                      *bool
	conditions                  *map[string]interface{}
	reason                      *string
	clearedFields               map[string]struct{}
	user                        *xid.ID
	cleareduser                 bool
	permission                  *xid.ID
	clearedpermission           bool
	assigned_by_user            *xid.ID
	clearedassigned_by_user     bool
	organization_context        *xid.ID
	clearedorganization_context bool
	done                        bool
	oldValue                    func(context.Context) (*UserPermission, error)
	predicates                  []predicate.UserPermission
}

var _ ent.Mutation = (*UserPermissionMutation)(nil)

// userpermissionOption allows management of the mutation configuration using functional options.
type userpermissionOption func(*UserPermissionMutation)

// newUserPermissionMutation creates new mutation for the UserPermission entity.
func newUserPermissionMutation(c config, op Op, opts ...userpermissionOption) *UserPermissionMutation {
	m := &UserPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPermissionID sets the ID field of the mutation.
func withUserPermissionID(id xid.ID) userpermissionOption {
	return func(m *UserPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPermission
		)
		m.oldValue = func(ctx context.Context) (*UserPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPermission sets the old UserPermission of the mutation.
func withUserPermission(node *UserPermission) userpermissionOption {
	return func(m *UserPermissionMutation) {
		m.oldValue = func(context.Context) (*UserPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPermission entities.
func (m *UserPermissionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPermissionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPermissionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserPermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserPermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserPermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userpermission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserPermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserPermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userpermission.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserPermissionMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPermissionMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPermissionMutation) ResetUserID() {
	m.user = nil
}

// SetPermissionID sets the "permission_id" field.
func (m *UserPermissionMutation) SetPermissionID(x xid.ID) {
	m.permission = &x
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *UserPermissionMutation) PermissionID() (r xid.ID, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldPermissionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *UserPermissionMutation) ResetPermissionID() {
	m.permission = nil
}

// SetContextType sets the "context_type" field.
func (m *UserPermissionMutation) SetContextType(mt model.ContextType) {
	m.context_type = &mt
}

// ContextType returns the value of the "context_type" field in the mutation.
func (m *UserPermissionMutation) ContextType() (r model.ContextType, exists bool) {
	v := m.context_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContextType returns the old "context_type" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldContextType(ctx context.Context) (v model.ContextType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextType: %w", err)
	}
	return oldValue.ContextType, nil
}

// ResetContextType resets all changes to the "context_type" field.
func (m *UserPermissionMutation) ResetContextType() {
	m.context_type = nil
}

// SetContextID sets the "context_id" field.
func (m *UserPermissionMutation) SetContextID(x xid.ID) {
	m.organization_context = &x
}

// ContextID returns the value of the "context_id" field in the mutation.
func (m *UserPermissionMutation) ContextID() (r xid.ID, exists bool) {
	v := m.organization_context
	if v == nil {
		return
	}
	return *v, true
}

// OldContextID returns the old "context_id" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldContextID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextID: %w", err)
	}
	return oldValue.ContextID, nil
}

// ClearContextID clears the value of the "context_id" field.
func (m *UserPermissionMutation) ClearContextID() {
	m.organization_context = nil
	m.clearedFields[userpermission.FieldContextID] = struct{}{}
}

// ContextIDCleared returns if the "context_id" field was cleared in this mutation.
func (m *UserPermissionMutation) ContextIDCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldContextID]
	return ok
}

// ResetContextID resets all changes to the "context_id" field.
func (m *UserPermissionMutation) ResetContextID() {
	m.organization_context = nil
	delete(m.clearedFields, userpermission.FieldContextID)
}

// SetResourceType sets the "resource_type" field.
func (m *UserPermissionMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *UserPermissionMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ClearResourceType clears the value of the "resource_type" field.
func (m *UserPermissionMutation) ClearResourceType() {
	m.resource_type = nil
	m.clearedFields[userpermission.FieldResourceType] = struct{}{}
}

// ResourceTypeCleared returns if the "resource_type" field was cleared in this mutation.
func (m *UserPermissionMutation) ResourceTypeCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldResourceType]
	return ok
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *UserPermissionMutation) ResetResourceType() {
	m.resource_type = nil
	delete(m.clearedFields, userpermission.FieldResourceType)
}

// SetResourceID sets the "resource_id" field.
func (m *UserPermissionMutation) SetResourceID(x xid.ID) {
	m.resource_id = &x
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *UserPermissionMutation) ResourceID() (r xid.ID, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldResourceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *UserPermissionMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[userpermission.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *UserPermissionMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *UserPermissionMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, userpermission.FieldResourceID)
}

// SetPermissionType sets the "permission_type" field.
func (m *UserPermissionMutation) SetPermissionType(mt model.PermissionType) {
	m.permission_type = &mt
}

// PermissionType returns the value of the "permission_type" field in the mutation.
func (m *UserPermissionMutation) PermissionType() (r model.PermissionType, exists bool) {
	v := m.permission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionType returns the old "permission_type" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldPermissionType(ctx context.Context) (v model.PermissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionType: %w", err)
	}
	return oldValue.PermissionType, nil
}

// ResetPermissionType resets all changes to the "permission_type" field.
func (m *UserPermissionMutation) ResetPermissionType() {
	m.permission_type = nil
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserPermissionMutation) SetAssignedBy(x xid.ID) {
	m.assigned_by_user = &x
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserPermissionMutation) AssignedBy() (r xid.ID, exists bool) {
	v := m.assigned_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldAssignedBy(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserPermissionMutation) ClearAssignedBy() {
	m.assigned_by_user = nil
	m.clearedFields[userpermission.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserPermissionMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserPermissionMutation) ResetAssignedBy() {
	m.assigned_by_user = nil
	delete(m.clearedFields, userpermission.FieldAssignedBy)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserPermissionMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserPermissionMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserPermissionMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserPermissionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserPermissionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *UserPermissionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[userpermission.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *UserPermissionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserPermissionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, userpermission.FieldExpiresAt)
}

// SetActive sets the "active" field.
func (m *UserPermissionMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserPermissionMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserPermissionMutation) ResetActive() {
	m.active = nil
}

// SetConditions sets the "conditions" field.
func (m *UserPermissionMutation) SetConditions(value map[string]interface{}) {
	m.conditions = &value
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *UserPermissionMutation) Conditions() (r map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *UserPermissionMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[userpermission.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *UserPermissionMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *UserPermissionMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, userpermission.FieldConditions)
}

// SetReason sets the "reason" field.
func (m *UserPermissionMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *UserPermissionMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the UserPermission entity.
// If the UserPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *UserPermissionMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[userpermission.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *UserPermissionMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[userpermission.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *UserPermissionMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, userpermission.FieldReason)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPermissionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userpermission.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPermissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPermissionMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPermissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPermission clears the "permission" edge to the Permission entity.
func (m *UserPermissionMutation) ClearPermission() {
	m.clearedpermission = true
	m.clearedFields[userpermission.FieldPermissionID] = struct{}{}
}

// PermissionCleared reports if the "permission" edge to the Permission entity was cleared.
func (m *UserPermissionMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *UserPermissionMutation) PermissionIDs() (ids []xid.ID) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *UserPermissionMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// SetAssignedByUserID sets the "assigned_by_user" edge to the User entity by id.
func (m *UserPermissionMutation) SetAssignedByUserID(id xid.ID) {
	m.assigned_by_user = &id
}

// ClearAssignedByUser clears the "assigned_by_user" edge to the User entity.
func (m *UserPermissionMutation) ClearAssignedByUser() {
	m.clearedassigned_by_user = true
	m.clearedFields[userpermission.FieldAssignedBy] = struct{}{}
}

// AssignedByUserCleared reports if the "assigned_by_user" edge to the User entity was cleared.
func (m *UserPermissionMutation) AssignedByUserCleared() bool {
	return m.AssignedByCleared() || m.clearedassigned_by_user
}

// AssignedByUserID returns the "assigned_by_user" edge ID in the mutation.
func (m *UserPermissionMutation) AssignedByUserID() (id xid.ID, exists bool) {
	if m.assigned_by_user != nil {
		return *m.assigned_by_user, true
	}
	return
}

// AssignedByUserIDs returns the "assigned_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByUserID instead. It exists only for internal usage by the builders.
func (m *UserPermissionMutation) AssignedByUserIDs() (ids []xid.ID) {
	if id := m.assigned_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedByUser resets all changes to the "assigned_by_user" edge.
func (m *UserPermissionMutation) ResetAssignedByUser() {
	m.assigned_by_user = nil
	m.clearedassigned_by_user = false
}

// SetOrganizationContextID sets the "organization_context" edge to the Organization entity by id.
func (m *UserPermissionMutation) SetOrganizationContextID(id xid.ID) {
	m.organization_context = &id
}

// ClearOrganizationContext clears the "organization_context" edge to the Organization entity.
func (m *UserPermissionMutation) ClearOrganizationContext() {
	m.clearedorganization_context = true
	m.clearedFields[userpermission.FieldContextID] = struct{}{}
}

// OrganizationContextCleared reports if the "organization_context" edge to the Organization entity was cleared.
func (m *UserPermissionMutation) OrganizationContextCleared() bool {
	return m.ContextIDCleared() || m.clearedorganization_context
}

// OrganizationContextID returns the "organization_context" edge ID in the mutation.
func (m *UserPermissionMutation) OrganizationContextID() (id xid.ID, exists bool) {
	if m.organization_context != nil {
		return *m.organization_context, true
	}
	return
}

// OrganizationContextIDs returns the "organization_context" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationContextID instead. It exists only for internal usage by the builders.
func (m *UserPermissionMutation) OrganizationContextIDs() (ids []xid.ID) {
	if id := m.organization_context; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganizationContext resets all changes to the "organization_context" edge.
func (m *UserPermissionMutation) ResetOrganizationContext() {
	m.organization_context = nil
	m.clearedorganization_context = false
}

// Where appends a list predicates to the UserPermissionMutation builder.
func (m *UserPermissionMutation) Where(ps ...predicate.UserPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPermission).
func (m *UserPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPermissionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, userpermission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userpermission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userpermission.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userpermission.FieldUserID)
	}
	if m.permission != nil {
		fields = append(fields, userpermission.FieldPermissionID)
	}
	if m.context_type != nil {
		fields = append(fields, userpermission.FieldContextType)
	}
	if m.organization_context != nil {
		fields = append(fields, userpermission.FieldContextID)
	}
	if m.resource_type != nil {
		fields = append(fields, userpermission.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, userpermission.FieldResourceID)
	}
	if m.permission_type != nil {
		fields = append(fields, userpermission.FieldPermissionType)
	}
	if m.assigned_by_user != nil {
		fields = append(fields, userpermission.FieldAssignedBy)
	}
	if m.assigned_at != nil {
		fields = append(fields, userpermission.FieldAssignedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, userpermission.FieldExpiresAt)
	}
	if m.active != nil {
		fields = append(fields, userpermission.FieldActive)
	}
	if m.conditions != nil {
		fields = append(fields, userpermission.FieldConditions)
	}
	if m.reason != nil {
		fields = append(fields, userpermission.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpermission.FieldCreatedAt:
		return m.CreatedAt()
	case userpermission.FieldUpdatedAt:
		return m.UpdatedAt()
	case userpermission.FieldDeletedAt:
		return m.DeletedAt()
	case userpermission.FieldUserID:
		return m.UserID()
	case userpermission.FieldPermissionID:
		return m.PermissionID()
	case userpermission.FieldContextType:
		return m.ContextType()
	case userpermission.FieldContextID:
		return m.ContextID()
	case userpermission.FieldResourceType:
		return m.ResourceType()
	case userpermission.FieldResourceID:
		return m.ResourceID()
	case userpermission.FieldPermissionType:
		return m.PermissionType()
	case userpermission.FieldAssignedBy:
		return m.AssignedBy()
	case userpermission.FieldAssignedAt:
		return m.AssignedAt()
	case userpermission.FieldExpiresAt:
		return m.ExpiresAt()
	case userpermission.FieldActive:
		return m.Active()
	case userpermission.FieldConditions:
		return m.Conditions()
	case userpermission.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userpermission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userpermission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userpermission.FieldUserID:
		return m.OldUserID(ctx)
	case userpermission.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case userpermission.FieldContextType:
		return m.OldContextType(ctx)
	case userpermission.FieldContextID:
		return m.OldContextID(ctx)
	case userpermission.FieldResourceType:
		return m.OldResourceType(ctx)
	case userpermission.FieldResourceID:
		return m.OldResourceID(ctx)
	case userpermission.FieldPermissionType:
		return m.OldPermissionType(ctx)
	case userpermission.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case userpermission.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case userpermission.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case userpermission.FieldActive:
		return m.OldActive(ctx)
	case userpermission.FieldConditions:
		return m.OldConditions(ctx)
	case userpermission.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown UserPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userpermission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userpermission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userpermission.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpermission.FieldPermissionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case userpermission.FieldContextType:
		v, ok := value.(model.ContextType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextType(v)
		return nil
	case userpermission.FieldContextID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextID(v)
		return nil
	case userpermission.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case userpermission.FieldResourceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case userpermission.FieldPermissionType:
		v, ok := value.(model.PermissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionType(v)
		return nil
	case userpermission.FieldAssignedBy:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case userpermission.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case userpermission.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case userpermission.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case userpermission.FieldConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case userpermission.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown UserPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpermission.FieldDeletedAt) {
		fields = append(fields, userpermission.FieldDeletedAt)
	}
	if m.FieldCleared(userpermission.FieldContextID) {
		fields = append(fields, userpermission.FieldContextID)
	}
	if m.FieldCleared(userpermission.FieldResourceType) {
		fields = append(fields, userpermission.FieldResourceType)
	}
	if m.FieldCleared(userpermission.FieldResourceID) {
		fields = append(fields, userpermission.FieldResourceID)
	}
	if m.FieldCleared(userpermission.FieldAssignedBy) {
		fields = append(fields, userpermission.FieldAssignedBy)
	}
	if m.FieldCleared(userpermission.FieldExpiresAt) {
		fields = append(fields, userpermission.FieldExpiresAt)
	}
	if m.FieldCleared(userpermission.FieldConditions) {
		fields = append(fields, userpermission.FieldConditions)
	}
	if m.FieldCleared(userpermission.FieldReason) {
		fields = append(fields, userpermission.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPermissionMutation) ClearField(name string) error {
	switch name {
	case userpermission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userpermission.FieldContextID:
		m.ClearContextID()
		return nil
	case userpermission.FieldResourceType:
		m.ClearResourceType()
		return nil
	case userpermission.FieldResourceID:
		m.ClearResourceID()
		return nil
	case userpermission.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case userpermission.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case userpermission.FieldConditions:
		m.ClearConditions()
		return nil
	case userpermission.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown UserPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPermissionMutation) ResetField(name string) error {
	switch name {
	case userpermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userpermission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userpermission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userpermission.FieldUserID:
		m.ResetUserID()
		return nil
	case userpermission.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case userpermission.FieldContextType:
		m.ResetContextType()
		return nil
	case userpermission.FieldContextID:
		m.ResetContextID()
		return nil
	case userpermission.FieldResourceType:
		m.ResetResourceType()
		return nil
	case userpermission.FieldResourceID:
		m.ResetResourceID()
		return nil
	case userpermission.FieldPermissionType:
		m.ResetPermissionType()
		return nil
	case userpermission.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case userpermission.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case userpermission.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case userpermission.FieldActive:
		m.ResetActive()
		return nil
	case userpermission.FieldConditions:
		m.ResetConditions()
		return nil
	case userpermission.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown UserPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, userpermission.EdgeUser)
	}
	if m.permission != nil {
		edges = append(edges, userpermission.EdgePermission)
	}
	if m.assigned_by_user != nil {
		edges = append(edges, userpermission.EdgeAssignedByUser)
	}
	if m.organization_context != nil {
		edges = append(edges, userpermission.EdgeOrganizationContext)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpermission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userpermission.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	case userpermission.EdgeAssignedByUser:
		if id := m.assigned_by_user; id != nil {
			return []ent.Value{*id}
		}
	case userpermission.EdgeOrganizationContext:
		if id := m.organization_context; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, userpermission.EdgeUser)
	}
	if m.clearedpermission {
		edges = append(edges, userpermission.EdgePermission)
	}
	if m.clearedassigned_by_user {
		edges = append(edges, userpermission.EdgeAssignedByUser)
	}
	if m.clearedorganization_context {
		edges = append(edges, userpermission.EdgeOrganizationContext)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case userpermission.EdgeUser:
		return m.cleareduser
	case userpermission.EdgePermission:
		return m.clearedpermission
	case userpermission.EdgeAssignedByUser:
		return m.clearedassigned_by_user
	case userpermission.EdgeOrganizationContext:
		return m.clearedorganization_context
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPermissionMutation) ClearEdge(name string) error {
	switch name {
	case userpermission.EdgeUser:
		m.ClearUser()
		return nil
	case userpermission.EdgePermission:
		m.ClearPermission()
		return nil
	case userpermission.EdgeAssignedByUser:
		m.ClearAssignedByUser()
		return nil
	case userpermission.EdgeOrganizationContext:
		m.ClearOrganizationContext()
		return nil
	}
	return fmt.Errorf("unknown UserPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPermissionMutation) ResetEdge(name string) error {
	switch name {
	case userpermission.EdgeUser:
		m.ResetUser()
		return nil
	case userpermission.EdgePermission:
		m.ResetPermission()
		return nil
	case userpermission.EdgeAssignedByUser:
		m.ResetAssignedByUser()
		return nil
	case userpermission.EdgeOrganizationContext:
		m.ResetOrganizationContext()
		return nil
	}
	return fmt.Errorf("unknown UserPermission edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *xid.ID
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	context_type                *model.ContextType
	assigned_at                 *time.Time
	expires_at                  *time.Time
	active                      *bool
	conditions                  *map[string]interface{}
	clearedFields               map[string]struct{}
	user                        *xid.ID
	cleareduser                 bool
	role                        *xid.ID
	clearedrole                 bool
	organization_context        *xid.ID
	clearedorganization_context bool
	assigned_by_user            *xid.ID
	clearedassigned_by_user     bool
	done                        bool
	oldValue                    func(context.Context) (*UserRole, error)
	predicates                  []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id xid.ID) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userrole.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(x xid.ID) {
	m.role = &x
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r xid.ID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role = nil
}

// SetContextType sets the "context_type" field.
func (m *UserRoleMutation) SetContextType(mt model.ContextType) {
	m.context_type = &mt
}

// ContextType returns the value of the "context_type" field in the mutation.
func (m *UserRoleMutation) ContextType() (r model.ContextType, exists bool) {
	v := m.context_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContextType returns the old "context_type" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldContextType(ctx context.Context) (v model.ContextType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextType: %w", err)
	}
	return oldValue.ContextType, nil
}

// ResetContextType resets all changes to the "context_type" field.
func (m *UserRoleMutation) ResetContextType() {
	m.context_type = nil
}

// SetContextID sets the "context_id" field.
func (m *UserRoleMutation) SetContextID(x xid.ID) {
	m.organization_context = &x
}

// ContextID returns the value of the "context_id" field in the mutation.
func (m *UserRoleMutation) ContextID() (r xid.ID, exists bool) {
	v := m.organization_context
	if v == nil {
		return
	}
	return *v, true
}

// OldContextID returns the old "context_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldContextID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextID: %w", err)
	}
	return oldValue.ContextID, nil
}

// ClearContextID clears the value of the "context_id" field.
func (m *UserRoleMutation) ClearContextID() {
	m.organization_context = nil
	m.clearedFields[userrole.FieldContextID] = struct{}{}
}

// ContextIDCleared returns if the "context_id" field was cleared in this mutation.
func (m *UserRoleMutation) ContextIDCleared() bool {
	_, ok := m.clearedFields[userrole.FieldContextID]
	return ok
}

// ResetContextID resets all changes to the "context_id" field.
func (m *UserRoleMutation) ResetContextID() {
	m.organization_context = nil
	delete(m.clearedFields, userrole.FieldContextID)
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserRoleMutation) SetAssignedBy(x xid.ID) {
	m.assigned_by_user = &x
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserRoleMutation) AssignedBy() (r xid.ID, exists bool) {
	v := m.assigned_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldAssignedBy(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserRoleMutation) ClearAssignedBy() {
	m.assigned_by_user = nil
	m.clearedFields[userrole.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserRoleMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[userrole.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserRoleMutation) ResetAssignedBy() {
	m.assigned_by_user = nil
	delete(m.clearedFields, userrole.FieldAssignedBy)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserRoleMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserRoleMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserRoleMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserRoleMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserRoleMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *UserRoleMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[userrole.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *UserRoleMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserRoleMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, userrole.FieldExpiresAt)
}

// SetActive sets the "active" field.
func (m *UserRoleMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserRoleMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserRoleMutation) ResetActive() {
	m.active = nil
}

// SetConditions sets the "conditions" field.
func (m *UserRoleMutation) SetConditions(value map[string]interface{}) {
	m.conditions = &value
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *UserRoleMutation) Conditions() (r map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *UserRoleMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[userrole.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *UserRoleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[userrole.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *UserRoleMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, userrole.FieldConditions)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userrole.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []xid.ID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetOrganizationContextID sets the "organization_context" edge to the Organization entity by id.
func (m *UserRoleMutation) SetOrganizationContextID(id xid.ID) {
	m.organization_context = &id
}

// ClearOrganizationContext clears the "organization_context" edge to the Organization entity.
func (m *UserRoleMutation) ClearOrganizationContext() {
	m.clearedorganization_context = true
	m.clearedFields[userrole.FieldContextID] = struct{}{}
}

// OrganizationContextCleared reports if the "organization_context" edge to the Organization entity was cleared.
func (m *UserRoleMutation) OrganizationContextCleared() bool {
	return m.ContextIDCleared() || m.clearedorganization_context
}

// OrganizationContextID returns the "organization_context" edge ID in the mutation.
func (m *UserRoleMutation) OrganizationContextID() (id xid.ID, exists bool) {
	if m.organization_context != nil {
		return *m.organization_context, true
	}
	return
}

// OrganizationContextIDs returns the "organization_context" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationContextID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) OrganizationContextIDs() (ids []xid.ID) {
	if id := m.organization_context; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganizationContext resets all changes to the "organization_context" edge.
func (m *UserRoleMutation) ResetOrganizationContext() {
	m.organization_context = nil
	m.clearedorganization_context = false
}

// SetAssignedByUserID sets the "assigned_by_user" edge to the User entity by id.
func (m *UserRoleMutation) SetAssignedByUserID(id xid.ID) {
	m.assigned_by_user = &id
}

// ClearAssignedByUser clears the "assigned_by_user" edge to the User entity.
func (m *UserRoleMutation) ClearAssignedByUser() {
	m.clearedassigned_by_user = true
	m.clearedFields[userrole.FieldAssignedBy] = struct{}{}
}

// AssignedByUserCleared reports if the "assigned_by_user" edge to the User entity was cleared.
func (m *UserRoleMutation) AssignedByUserCleared() bool {
	return m.AssignedByCleared() || m.clearedassigned_by_user
}

// AssignedByUserID returns the "assigned_by_user" edge ID in the mutation.
func (m *UserRoleMutation) AssignedByUserID() (id xid.ID, exists bool) {
	if m.assigned_by_user != nil {
		return *m.assigned_by_user, true
	}
	return
}

// AssignedByUserIDs returns the "assigned_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByUserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) AssignedByUserIDs() (ids []xid.ID) {
	if id := m.assigned_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedByUser resets all changes to the "assigned_by_user" edge.
func (m *UserRoleMutation) ResetAssignedByUser() {
	m.assigned_by_user = nil
	m.clearedassigned_by_user = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.context_type != nil {
		fields = append(fields, userrole.FieldContextType)
	}
	if m.organization_context != nil {
		fields = append(fields, userrole.FieldContextID)
	}
	if m.assigned_by_user != nil {
		fields = append(fields, userrole.FieldAssignedBy)
	}
	if m.assigned_at != nil {
		fields = append(fields, userrole.FieldAssignedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, userrole.FieldExpiresAt)
	}
	if m.active != nil {
		fields = append(fields, userrole.FieldActive)
	}
	if m.conditions != nil {
		fields = append(fields, userrole.FieldConditions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case userrole.FieldDeletedAt:
		return m.DeletedAt()
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldContextType:
		return m.ContextType()
	case userrole.FieldContextID:
		return m.ContextID()
	case userrole.FieldAssignedBy:
		return m.AssignedBy()
	case userrole.FieldAssignedAt:
		return m.AssignedAt()
	case userrole.FieldExpiresAt:
		return m.ExpiresAt()
	case userrole.FieldActive:
		return m.Active()
	case userrole.FieldConditions:
		return m.Conditions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldContextType:
		return m.OldContextType(ctx)
	case userrole.FieldContextID:
		return m.OldContextID(ctx)
	case userrole.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case userrole.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case userrole.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case userrole.FieldActive:
		return m.OldActive(ctx)
	case userrole.FieldConditions:
		return m.OldConditions(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldContextType:
		v, ok := value.(model.ContextType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextType(v)
		return nil
	case userrole.FieldContextID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextID(v)
		return nil
	case userrole.FieldAssignedBy:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case userrole.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case userrole.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case userrole.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case userrole.FieldConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldDeletedAt) {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.FieldCleared(userrole.FieldContextID) {
		fields = append(fields, userrole.FieldContextID)
	}
	if m.FieldCleared(userrole.FieldAssignedBy) {
		fields = append(fields, userrole.FieldAssignedBy)
	}
	if m.FieldCleared(userrole.FieldExpiresAt) {
		fields = append(fields, userrole.FieldExpiresAt)
	}
	if m.FieldCleared(userrole.FieldConditions) {
		fields = append(fields, userrole.FieldConditions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userrole.FieldContextID:
		m.ClearContextID()
		return nil
	case userrole.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case userrole.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case userrole.FieldConditions:
		m.ClearConditions()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldContextType:
		m.ResetContextType()
		return nil
	case userrole.FieldContextID:
		m.ResetContextID()
		return nil
	case userrole.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case userrole.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case userrole.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case userrole.FieldActive:
		m.ResetActive()
		return nil
	case userrole.FieldConditions:
		m.ResetConditions()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	if m.organization_context != nil {
		edges = append(edges, userrole.EdgeOrganizationContext)
	}
	if m.assigned_by_user != nil {
		edges = append(edges, userrole.EdgeAssignedByUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeOrganizationContext:
		if id := m.organization_context; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeAssignedByUser:
		if id := m.assigned_by_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	if m.clearedorganization_context {
		edges = append(edges, userrole.EdgeOrganizationContext)
	}
	if m.clearedassigned_by_user {
		edges = append(edges, userrole.EdgeAssignedByUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	case userrole.EdgeOrganizationContext:
		return m.clearedorganization_context
	case userrole.EdgeAssignedByUser:
		return m.clearedassigned_by_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	case userrole.EdgeOrganizationContext:
		m.ClearOrganizationContext()
		return nil
	case userrole.EdgeAssignedByUser:
		m.ClearAssignedByUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	case userrole.EdgeOrganizationContext:
		m.ResetOrganizationContext()
		return nil
	case userrole.EdgeAssignedByUser:
		m.ResetAssignedByUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}

// VerificationMutation represents an operation that mutates the Verification nodes in the graph.
type VerificationMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *string
	token         *string
	email         *string
	phone_number  *string
	redirect_url  *string
	used          *bool
	used_at       *time.Time
	attempts      *int
	addattempts   *int
	expires_at    *time.Time
	ip_address    *string
	user_agent    *string
	attestation   *map[string]interface{}
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	user          *xid.ID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Verification, error)
	predicates    []predicate.Verification
}

var _ ent.Mutation = (*VerificationMutation)(nil)

// verificationOption allows management of the mutation configuration using functional options.
type verificationOption func(*VerificationMutation)

// newVerificationMutation creates new mutation for the Verification entity.
func newVerificationMutation(c config, op Op, opts ...verificationOption) *VerificationMutation {
	m := &VerificationMutation{
		config:        c,
		op:            op,
		typ:           TypeVerification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVerificationID sets the ID field of the mutation.
func withVerificationID(id xid.ID) verificationOption {
	return func(m *VerificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Verification
		)
		m.oldValue = func(ctx context.Context) (*Verification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Verification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVerification sets the old Verification of the mutation.
func withVerification(node *Verification) verificationOption {
	return func(m *VerificationMutation) {
		m.oldValue = func(context.Context) (*Verification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VerificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VerificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Verification entities.
func (m *VerificationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VerificationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VerificationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Verification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VerificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VerificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VerificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VerificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VerificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VerificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VerificationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VerificationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VerificationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[verification.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VerificationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[verification.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VerificationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, verification.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *VerificationMutation) SetUserID(x xid.ID) {
	m.user = &x
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VerificationMutation) UserID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUserID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VerificationMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *VerificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VerificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *VerificationMutation) ResetType() {
	m._type = nil
}

// SetToken sets the "token" field.
func (m *VerificationMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *VerificationMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *VerificationMutation) ResetToken() {
	m.token = nil
}

// SetEmail sets the "email" field.
func (m *VerificationMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *VerificationMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *VerificationMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[verification.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *VerificationMutation) EmailCleared() bool {
	_, ok := m.clearedFields[verification.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *VerificationMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, verification.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *VerificationMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *VerificationMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *VerificationMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[verification.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *VerificationMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[verification.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *VerificationMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, verification.FieldPhoneNumber)
}

// SetRedirectURL sets the "redirect_url" field.
func (m *VerificationMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *VerificationMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ClearRedirectURL clears the value of the "redirect_url" field.
func (m *VerificationMutation) ClearRedirectURL() {
	m.redirect_url = nil
	m.clearedFields[verification.FieldRedirectURL] = struct{}{}
}

// RedirectURLCleared returns if the "redirect_url" field was cleared in this mutation.
func (m *VerificationMutation) RedirectURLCleared() bool {
	_, ok := m.clearedFields[verification.FieldRedirectURL]
	return ok
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *VerificationMutation) ResetRedirectURL() {
	m.redirect_url = nil
	delete(m.clearedFields, verification.FieldRedirectURL)
}

// SetUsed sets the "used" field.
func (m *VerificationMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *VerificationMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *VerificationMutation) ResetUsed() {
	m.used = nil
}

// SetUsedAt sets the "used_at" field.
func (m *VerificationMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *VerificationMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *VerificationMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[verification.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *VerificationMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[verification.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *VerificationMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, verification.FieldUsedAt)
}

// SetAttempts sets the "attempts" field.
func (m *VerificationMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *VerificationMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *VerificationMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *VerificationMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *VerificationMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *VerificationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *VerificationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *VerificationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *VerificationMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *VerificationMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *VerificationMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[verification.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *VerificationMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[verification.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *VerificationMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, verification.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *VerificationMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *VerificationMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *VerificationMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[verification.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *VerificationMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[verification.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *VerificationMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, verification.FieldUserAgent)
}

// SetAttestation sets the "attestation" field.
func (m *VerificationMutation) SetAttestation(value map[string]interface{}) {
	m.attestation = &value
}

// Attestation returns the value of the "attestation" field in the mutation.
func (m *VerificationMutation) Attestation() (r map[string]interface{}, exists bool) {
	v := m.attestation
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestation returns the old "attestation" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldAttestation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestation: %w", err)
	}
	return oldValue.Attestation, nil
}

// ClearAttestation clears the value of the "attestation" field.
func (m *VerificationMutation) ClearAttestation() {
	m.attestation = nil
	m.clearedFields[verification.FieldAttestation] = struct{}{}
}

// AttestationCleared returns if the "attestation" field was cleared in this mutation.
func (m *VerificationMutation) AttestationCleared() bool {
	_, ok := m.clearedFields[verification.FieldAttestation]
	return ok
}

// ResetAttestation resets all changes to the "attestation" field.
func (m *VerificationMutation) ResetAttestation() {
	m.attestation = nil
	delete(m.clearedFields, verification.FieldAttestation)
}

// SetMetadata sets the "metadata" field.
func (m *VerificationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *VerificationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *VerificationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[verification.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *VerificationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[verification.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *VerificationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, verification.FieldMetadata)
}

// ClearUser clears the "user" edge to the User entity.
func (m *VerificationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[verification.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VerificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VerificationMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VerificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VerificationMutation builder.
func (m *VerificationMutation) Where(ps ...predicate.Verification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VerificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VerificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Verification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VerificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VerificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Verification).
func (m *VerificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VerificationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, verification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, verification.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, verification.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, verification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, verification.FieldType)
	}
	if m.token != nil {
		fields = append(fields, verification.FieldToken)
	}
	if m.email != nil {
		fields = append(fields, verification.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, verification.FieldPhoneNumber)
	}
	if m.redirect_url != nil {
		fields = append(fields, verification.FieldRedirectURL)
	}
	if m.used != nil {
		fields = append(fields, verification.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, verification.FieldUsedAt)
	}
	if m.attempts != nil {
		fields = append(fields, verification.FieldAttempts)
	}
	if m.expires_at != nil {
		fields = append(fields, verification.FieldExpiresAt)
	}
	if m.ip_address != nil {
		fields = append(fields, verification.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, verification.FieldUserAgent)
	}
	if m.attestation != nil {
		fields = append(fields, verification.FieldAttestation)
	}
	if m.metadata != nil {
		fields = append(fields, verification.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VerificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case verification.FieldCreatedAt:
		return m.CreatedAt()
	case verification.FieldUpdatedAt:
		return m.UpdatedAt()
	case verification.FieldDeletedAt:
		return m.DeletedAt()
	case verification.FieldUserID:
		return m.UserID()
	case verification.FieldType:
		return m.GetType()
	case verification.FieldToken:
		return m.Token()
	case verification.FieldEmail:
		return m.Email()
	case verification.FieldPhoneNumber:
		return m.PhoneNumber()
	case verification.FieldRedirectURL:
		return m.RedirectURL()
	case verification.FieldUsed:
		return m.Used()
	case verification.FieldUsedAt:
		return m.UsedAt()
	case verification.FieldAttempts:
		return m.Attempts()
	case verification.FieldExpiresAt:
		return m.ExpiresAt()
	case verification.FieldIPAddress:
		return m.IPAddress()
	case verification.FieldUserAgent:
		return m.UserAgent()
	case verification.FieldAttestation:
		return m.Attestation()
	case verification.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VerificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case verification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case verification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case verification.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case verification.FieldUserID:
		return m.OldUserID(ctx)
	case verification.FieldType:
		return m.OldType(ctx)
	case verification.FieldToken:
		return m.OldToken(ctx)
	case verification.FieldEmail:
		return m.OldEmail(ctx)
	case verification.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case verification.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case verification.FieldUsed:
		return m.OldUsed(ctx)
	case verification.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case verification.FieldAttempts:
		return m.OldAttempts(ctx)
	case verification.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case verification.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case verification.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case verification.FieldAttestation:
		return m.OldAttestation(ctx)
	case verification.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Verification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VerificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case verification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case verification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case verification.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case verification.FieldUserID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case verification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case verification.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case verification.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case verification.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case verification.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case verification.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case verification.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case verification.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case verification.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case verification.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case verification.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case verification.FieldAttestation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestation(v)
		return nil
	case verification.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Verification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VerificationMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, verification.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VerificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case verification.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VerificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case verification.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown Verification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VerificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(verification.FieldDeletedAt) {
		fields = append(fields, verification.FieldDeletedAt)
	}
	if m.FieldCleared(verification.FieldEmail) {
		fields = append(fields, verification.FieldEmail)
	}
	if m.FieldCleared(verification.FieldPhoneNumber) {
		fields = append(fields, verification.FieldPhoneNumber)
	}
	if m.FieldCleared(verification.FieldRedirectURL) {
		fields = append(fields, verification.FieldRedirectURL)
	}
	if m.FieldCleared(verification.FieldUsedAt) {
		fields = append(fields, verification.FieldUsedAt)
	}
	if m.FieldCleared(verification.FieldIPAddress) {
		fields = append(fields, verification.FieldIPAddress)
	}
	if m.FieldCleared(verification.FieldUserAgent) {
		fields = append(fields, verification.FieldUserAgent)
	}
	if m.FieldCleared(verification.FieldAttestation) {
		fields = append(fields, verification.FieldAttestation)
	}
	if m.FieldCleared(verification.FieldMetadata) {
		fields = append(fields, verification.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VerificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VerificationMutation) ClearField(name string) error {
	switch name {
	case verification.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case verification.FieldEmail:
		m.ClearEmail()
		return nil
	case verification.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case verification.FieldRedirectURL:
		m.ClearRedirectURL()
		return nil
	case verification.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case verification.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case verification.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case verification.FieldAttestation:
		m.ClearAttestation()
		return nil
	case verification.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Verification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VerificationMutation) ResetField(name string) error {
	switch name {
	case verification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case verification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case verification.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case verification.FieldUserID:
		m.ResetUserID()
		return nil
	case verification.FieldType:
		m.ResetType()
		return nil
	case verification.FieldToken:
		m.ResetToken()
		return nil
	case verification.FieldEmail:
		m.ResetEmail()
		return nil
	case verification.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case verification.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case verification.FieldUsed:
		m.ResetUsed()
		return nil
	case verification.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case verification.FieldAttempts:
		m.ResetAttempts()
		return nil
	case verification.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case verification.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case verification.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case verification.FieldAttestation:
		m.ResetAttestation()
		return nil
	case verification.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Verification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VerificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, verification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VerificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case verification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VerificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VerificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VerificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, verification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VerificationMutation) EdgeCleared(name string) bool {
	switch name {
	case verification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VerificationMutation) ClearEdge(name string) error {
	switch name {
	case verification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Verification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VerificationMutation) ResetEdge(name string) error {
	switch name {
	case verification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Verification edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                  Op
	typ                 string
	id                  *xid.ID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	url                 *string
	secret              *string
	active              *bool
	event_types         *[]string
	appendevent_types   []string
	version             *string
	retry_count         *int
	addretry_count      *int
	timeout_ms          *int
	addtimeout_ms       *int
	format              *model.WebhookFormat
	metadata            *map[string]interface{}
	headers             *map[string]string
	clearedFields       map[string]struct{}
	organization        *xid.ID
	clearedorganization bool
	events              map[xid.ID]struct{}
	removedevents       map[xid.ID]struct{}
	clearedevents       bool
	done                bool
	oldValue            func(context.Context) (*Webhook, error)
	predicates          []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id xid.ID) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Webhook entities.
func (m *WebhookMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WebhookMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WebhookMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WebhookMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[webhook.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WebhookMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WebhookMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, webhook.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *WebhookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebhookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebhookMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *WebhookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebhookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebhookMutation) ResetURL() {
	m.url = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WebhookMutation) SetOrganizationID(x xid.ID) {
	m.organization = &x
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WebhookMutation) OrganizationID() (r xid.ID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldOrganizationID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WebhookMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetSecret sets the "secret" field.
func (m *WebhookMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *WebhookMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *WebhookMutation) ResetSecret() {
	m.secret = nil
}

// SetActive sets the "active" field.
func (m *WebhookMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WebhookMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WebhookMutation) ResetActive() {
	m.active = nil
}

// SetEventTypes sets the "event_types" field.
func (m *WebhookMutation) SetEventTypes(s []string) {
	m.event_types = &s
	m.appendevent_types = nil
}

// EventTypes returns the value of the "event_types" field in the mutation.
func (m *WebhookMutation) EventTypes() (r []string, exists bool) {
	v := m.event_types
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypes returns the old "event_types" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEventTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypes: %w", err)
	}
	return oldValue.EventTypes, nil
}

// AppendEventTypes adds s to the "event_types" field.
func (m *WebhookMutation) AppendEventTypes(s []string) {
	m.appendevent_types = append(m.appendevent_types, s...)
}

// AppendedEventTypes returns the list of values that were appended to the "event_types" field in this mutation.
func (m *WebhookMutation) AppendedEventTypes() ([]string, bool) {
	if len(m.appendevent_types) == 0 {
		return nil, false
	}
	return m.appendevent_types, true
}

// ResetEventTypes resets all changes to the "event_types" field.
func (m *WebhookMutation) ResetEventTypes() {
	m.event_types = nil
	m.appendevent_types = nil
}

// SetVersion sets the "version" field.
func (m *WebhookMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *WebhookMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *WebhookMutation) ResetVersion() {
	m.version = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *WebhookMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *WebhookMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *WebhookMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *WebhookMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *WebhookMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetTimeoutMs sets the "timeout_ms" field.
func (m *WebhookMutation) SetTimeoutMs(i int) {
	m.timeout_ms = &i
	m.addtimeout_ms = nil
}

// TimeoutMs returns the value of the "timeout_ms" field in the mutation.
func (m *WebhookMutation) TimeoutMs() (r int, exists bool) {
	v := m.timeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutMs returns the old "timeout_ms" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldTimeoutMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutMs: %w", err)
	}
	return oldValue.TimeoutMs, nil
}

// AddTimeoutMs adds i to the "timeout_ms" field.
func (m *WebhookMutation) AddTimeoutMs(i int) {
	if m.addtimeout_ms != nil {
		*m.addtimeout_ms += i
	} else {
		m.addtimeout_ms = &i
	}
}

// AddedTimeoutMs returns the value that was added to the "timeout_ms" field in this mutation.
func (m *WebhookMutation) AddedTimeoutMs() (r int, exists bool) {
	v := m.addtimeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeoutMs resets all changes to the "timeout_ms" field.
func (m *WebhookMutation) ResetTimeoutMs() {
	m.timeout_ms = nil
	m.addtimeout_ms = nil
}

// SetFormat sets the "format" field.
func (m *WebhookMutation) SetFormat(mf model.WebhookFormat) {
	m.format = &mf
}

// Format returns the value of the "format" field in the mutation.
func (m *WebhookMutation) Format() (r model.WebhookFormat, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFormat(ctx context.Context) (v model.WebhookFormat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *WebhookMutation) ResetFormat() {
	m.format = nil
}

// SetMetadata sets the "metadata" field.
func (m *WebhookMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *WebhookMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *WebhookMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[webhook.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *WebhookMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[webhook.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *WebhookMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, webhook.FieldMetadata)
}

// SetHeaders sets the "headers" field.
func (m *WebhookMutation) SetHeaders(value map[string]string) {
	m.headers = &value
}

// Headers returns the value of the "headers" field in the mutation.
func (m *WebhookMutation) Headers() (r map[string]string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldHeaders(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ClearHeaders clears the value of the "headers" field.
func (m *WebhookMutation) ClearHeaders() {
	m.headers = nil
	m.clearedFields[webhook.FieldHeaders] = struct{}{}
}

// HeadersCleared returns if the "headers" field was cleared in this mutation.
func (m *WebhookMutation) HeadersCleared() bool {
	_, ok := m.clearedFields[webhook.FieldHeaders]
	return ok
}

// ResetHeaders resets all changes to the "headers" field.
func (m *WebhookMutation) ResetHeaders() {
	m.headers = nil
	delete(m.clearedFields, webhook.FieldHeaders)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WebhookMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[webhook.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WebhookMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WebhookMutation) OrganizationIDs() (ids []xid.ID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WebhookMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddEventIDs adds the "events" edge to the WebhookEvent entity by ids.
func (m *WebhookMutation) AddEventIDs(ids ...xid.ID) {
	if m.events == nil {
		m.events = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the WebhookEvent entity.
func (m *WebhookMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the WebhookEvent entity was cleared.
func (m *WebhookMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the WebhookEvent entity by IDs.
func (m *WebhookMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevents == nil {
		m.removedevents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the WebhookEvent entity.
func (m *WebhookMutation) RemovedEventsIDs() (ids []xid.ID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *WebhookMutation) EventsIDs() (ids []xid.ID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *WebhookMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, webhook.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, webhook.FieldName)
	}
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.organization != nil {
		fields = append(fields, webhook.FieldOrganizationID)
	}
	if m.secret != nil {
		fields = append(fields, webhook.FieldSecret)
	}
	if m.active != nil {
		fields = append(fields, webhook.FieldActive)
	}
	if m.event_types != nil {
		fields = append(fields, webhook.FieldEventTypes)
	}
	if m.version != nil {
		fields = append(fields, webhook.FieldVersion)
	}
	if m.retry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.timeout_ms != nil {
		fields = append(fields, webhook.FieldTimeoutMs)
	}
	if m.format != nil {
		fields = append(fields, webhook.FieldFormat)
	}
	if m.metadata != nil {
		fields = append(fields, webhook.FieldMetadata)
	}
	if m.headers != nil {
		fields = append(fields, webhook.FieldHeaders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	case webhook.FieldDeletedAt:
		return m.DeletedAt()
	case webhook.FieldName:
		return m.Name()
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldOrganizationID:
		return m.OrganizationID()
	case webhook.FieldSecret:
		return m.Secret()
	case webhook.FieldActive:
		return m.Active()
	case webhook.FieldEventTypes:
		return m.EventTypes()
	case webhook.FieldVersion:
		return m.Version()
	case webhook.FieldRetryCount:
		return m.RetryCount()
	case webhook.FieldTimeoutMs:
		return m.TimeoutMs()
	case webhook.FieldFormat:
		return m.Format()
	case webhook.FieldMetadata:
		return m.Metadata()
	case webhook.FieldHeaders:
		return m.Headers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webhook.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case webhook.FieldName:
		return m.OldName(ctx)
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case webhook.FieldSecret:
		return m.OldSecret(ctx)
	case webhook.FieldActive:
		return m.OldActive(ctx)
	case webhook.FieldEventTypes:
		return m.OldEventTypes(ctx)
	case webhook.FieldVersion:
		return m.OldVersion(ctx)
	case webhook.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case webhook.FieldTimeoutMs:
		return m.OldTimeoutMs(ctx)
	case webhook.FieldFormat:
		return m.OldFormat(ctx)
	case webhook.FieldMetadata:
		return m.OldMetadata(ctx)
	case webhook.FieldHeaders:
		return m.OldHeaders(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webhook.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case webhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldOrganizationID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case webhook.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case webhook.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case webhook.FieldEventTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypes(v)
		return nil
	case webhook.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case webhook.FieldTimeoutMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutMs(v)
		return nil
	case webhook.FieldFormat:
		v, ok := value.(model.WebhookFormat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case webhook.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case webhook.FieldHeaders:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.addtimeout_ms != nil {
		fields = append(fields, webhook.FieldTimeoutMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldRetryCount:
		return m.AddedRetryCount()
	case webhook.FieldTimeoutMs:
		return m.AddedTimeoutMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case webhook.FieldTimeoutMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeoutMs(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldDeletedAt) {
		fields = append(fields, webhook.FieldDeletedAt)
	}
	if m.FieldCleared(webhook.FieldMetadata) {
		fields = append(fields, webhook.FieldMetadata)
	}
	if m.FieldCleared(webhook.FieldHeaders) {
		fields = append(fields, webhook.FieldHeaders)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case webhook.FieldMetadata:
		m.ClearMetadata()
		return nil
	case webhook.FieldHeaders:
		m.ClearHeaders()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webhook.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case webhook.FieldName:
		m.ResetName()
		return nil
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case webhook.FieldSecret:
		m.ResetSecret()
		return nil
	case webhook.FieldActive:
		m.ResetActive()
		return nil
	case webhook.FieldEventTypes:
		m.ResetEventTypes()
		return nil
	case webhook.FieldVersion:
		m.ResetVersion()
		return nil
	case webhook.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case webhook.FieldTimeoutMs:
		m.ResetTimeoutMs()
		return nil
	case webhook.FieldFormat:
		m.ResetFormat()
		return nil
	case webhook.FieldMetadata:
		m.ResetMetadata()
		return nil
	case webhook.FieldHeaders:
		m.ResetHeaders()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, webhook.EdgeOrganization)
	}
	if m.events != nil {
		edges = append(edges, webhook.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case webhook.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, webhook.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, webhook.EdgeOrganization)
	}
	if m.clearedevents {
		edges = append(edges, webhook.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeOrganization:
		return m.clearedorganization
	case webhook.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	case webhook.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case webhook.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}

// WebhookEventMutation represents an operation that mutates the WebhookEvent nodes in the graph.
type WebhookEventMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	event_type     *string
	headers        *map[string]string
	payload        *map[string]interface{}
	delivered      *bool
	delivered_at   *time.Time
	attempts       *int
	addattempts    *int
	next_retry     *time.Time
	status_code    *int
	addstatus_code *int
	response_body  *string
	error          *string
	clearedFields  map[string]struct{}
	webhook        *xid.ID
	clearedwebhook bool
	done           bool
	oldValue       func(context.Context) (*WebhookEvent, error)
	predicates     []predicate.WebhookEvent
}

var _ ent.Mutation = (*WebhookEventMutation)(nil)

// webhookeventOption allows management of the mutation configuration using functional options.
type webhookeventOption func(*WebhookEventMutation)

// newWebhookEventMutation creates new mutation for the WebhookEvent entity.
func newWebhookEventMutation(c config, op Op, opts ...webhookeventOption) *WebhookEventMutation {
	m := &WebhookEventMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhookEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookEventID sets the ID field of the mutation.
func withWebhookEventID(id xid.ID) webhookeventOption {
	return func(m *WebhookEventMutation) {
		var (
			err   error
			once  sync.Once
			value *WebhookEvent
		)
		m.oldValue = func(ctx context.Context) (*WebhookEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebhookEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhookEvent sets the old WebhookEvent of the mutation.
func withWebhookEvent(node *WebhookEvent) webhookeventOption {
	return func(m *WebhookEventMutation) {
		m.oldValue = func(context.Context) (*WebhookEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebhookEvent entities.
func (m *WebhookEventMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookEventMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookEventMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebhookEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WebhookEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WebhookEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WebhookEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[webhookevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WebhookEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WebhookEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, webhookevent.FieldDeletedAt)
}

// SetWebhookID sets the "webhook_id" field.
func (m *WebhookEventMutation) SetWebhookID(x xid.ID) {
	m.webhook = &x
}

// WebhookID returns the value of the "webhook_id" field in the mutation.
func (m *WebhookEventMutation) WebhookID() (r xid.ID, exists bool) {
	v := m.webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookID returns the old "webhook_id" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldWebhookID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookID: %w", err)
	}
	return oldValue.WebhookID, nil
}

// ResetWebhookID resets all changes to the "webhook_id" field.
func (m *WebhookEventMutation) ResetWebhookID() {
	m.webhook = nil
}

// SetEventType sets the "event_type" field.
func (m *WebhookEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *WebhookEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *WebhookEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetHeaders sets the "headers" field.
func (m *WebhookEventMutation) SetHeaders(value map[string]string) {
	m.headers = &value
}

// Headers returns the value of the "headers" field in the mutation.
func (m *WebhookEventMutation) Headers() (r map[string]string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldHeaders(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ClearHeaders clears the value of the "headers" field.
func (m *WebhookEventMutation) ClearHeaders() {
	m.headers = nil
	m.clearedFields[webhookevent.FieldHeaders] = struct{}{}
}

// HeadersCleared returns if the "headers" field was cleared in this mutation.
func (m *WebhookEventMutation) HeadersCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldHeaders]
	return ok
}

// ResetHeaders resets all changes to the "headers" field.
func (m *WebhookEventMutation) ResetHeaders() {
	m.headers = nil
	delete(m.clearedFields, webhookevent.FieldHeaders)
}

// SetPayload sets the "payload" field.
func (m *WebhookEventMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *WebhookEventMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *WebhookEventMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[webhookevent.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *WebhookEventMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *WebhookEventMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, webhookevent.FieldPayload)
}

// SetDelivered sets the "delivered" field.
func (m *WebhookEventMutation) SetDelivered(b bool) {
	m.delivered = &b
}

// Delivered returns the value of the "delivered" field in the mutation.
func (m *WebhookEventMutation) Delivered() (r bool, exists bool) {
	v := m.delivered
	if v == nil {
		return
	}
	return *v, true
}

// OldDelivered returns the old "delivered" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldDelivered(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelivered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelivered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelivered: %w", err)
	}
	return oldValue.Delivered, nil
}

// ResetDelivered resets all changes to the "delivered" field.
func (m *WebhookEventMutation) ResetDelivered() {
	m.delivered = nil
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *WebhookEventMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *WebhookEventMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldDeliveredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *WebhookEventMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[webhookevent.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *WebhookEventMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *WebhookEventMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, webhookevent.FieldDeliveredAt)
}

// SetAttempts sets the "attempts" field.
func (m *WebhookEventMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *WebhookEventMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *WebhookEventMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *WebhookEventMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *WebhookEventMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetNextRetry sets the "next_retry" field.
func (m *WebhookEventMutation) SetNextRetry(t time.Time) {
	m.next_retry = &t
}

// NextRetry returns the value of the "next_retry" field in the mutation.
func (m *WebhookEventMutation) NextRetry() (r time.Time, exists bool) {
	v := m.next_retry
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRetry returns the old "next_retry" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldNextRetry(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRetry: %w", err)
	}
	return oldValue.NextRetry, nil
}

// ClearNextRetry clears the value of the "next_retry" field.
func (m *WebhookEventMutation) ClearNextRetry() {
	m.next_retry = nil
	m.clearedFields[webhookevent.FieldNextRetry] = struct{}{}
}

// NextRetryCleared returns if the "next_retry" field was cleared in this mutation.
func (m *WebhookEventMutation) NextRetryCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldNextRetry]
	return ok
}

// ResetNextRetry resets all changes to the "next_retry" field.
func (m *WebhookEventMutation) ResetNextRetry() {
	m.next_retry = nil
	delete(m.clearedFields, webhookevent.FieldNextRetry)
}

// SetStatusCode sets the "status_code" field.
func (m *WebhookEventMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *WebhookEventMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldStatusCode(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *WebhookEventMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *WebhookEventMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *WebhookEventMutation) ClearStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	m.clearedFields[webhookevent.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *WebhookEventMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *WebhookEventMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	delete(m.clearedFields, webhookevent.FieldStatusCode)
}

// SetResponseBody sets the "response_body" field.
func (m *WebhookEventMutation) SetResponseBody(s string) {
	m.response_body = &s
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *WebhookEventMutation) ResponseBody() (r string, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldResponseBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *WebhookEventMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[webhookevent.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *WebhookEventMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *WebhookEventMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, webhookevent.FieldResponseBody)
}

// SetError sets the "error" field.
func (m *WebhookEventMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *WebhookEventMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *WebhookEventMutation) ClearError() {
	m.error = nil
	m.clearedFields[webhookevent.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *WebhookEventMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *WebhookEventMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, webhookevent.FieldError)
}

// ClearWebhook clears the "webhook" edge to the Webhook entity.
func (m *WebhookEventMutation) ClearWebhook() {
	m.clearedwebhook = true
	m.clearedFields[webhookevent.FieldWebhookID] = struct{}{}
}

// WebhookCleared reports if the "webhook" edge to the Webhook entity was cleared.
func (m *WebhookEventMutation) WebhookCleared() bool {
	return m.clearedwebhook
}

// WebhookIDs returns the "webhook" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebhookID instead. It exists only for internal usage by the builders.
func (m *WebhookEventMutation) WebhookIDs() (ids []xid.ID) {
	if id := m.webhook; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebhook resets all changes to the "webhook" edge.
func (m *WebhookEventMutation) ResetWebhook() {
	m.webhook = nil
	m.clearedwebhook = false
}

// Where appends a list predicates to the WebhookEventMutation builder.
func (m *WebhookEventMutation) Where(ps ...predicate.WebhookEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebhookEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebhookEvent).
func (m *WebhookEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookEventMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, webhookevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhookevent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, webhookevent.FieldDeletedAt)
	}
	if m.webhook != nil {
		fields = append(fields, webhookevent.FieldWebhookID)
	}
	if m.event_type != nil {
		fields = append(fields, webhookevent.FieldEventType)
	}
	if m.headers != nil {
		fields = append(fields, webhookevent.FieldHeaders)
	}
	if m.payload != nil {
		fields = append(fields, webhookevent.FieldPayload)
	}
	if m.delivered != nil {
		fields = append(fields, webhookevent.FieldDelivered)
	}
	if m.delivered_at != nil {
		fields = append(fields, webhookevent.FieldDeliveredAt)
	}
	if m.attempts != nil {
		fields = append(fields, webhookevent.FieldAttempts)
	}
	if m.next_retry != nil {
		fields = append(fields, webhookevent.FieldNextRetry)
	}
	if m.status_code != nil {
		fields = append(fields, webhookevent.FieldStatusCode)
	}
	if m.response_body != nil {
		fields = append(fields, webhookevent.FieldResponseBody)
	}
	if m.error != nil {
		fields = append(fields, webhookevent.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhookevent.FieldCreatedAt:
		return m.CreatedAt()
	case webhookevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case webhookevent.FieldDeletedAt:
		return m.DeletedAt()
	case webhookevent.FieldWebhookID:
		return m.WebhookID()
	case webhookevent.FieldEventType:
		return m.EventType()
	case webhookevent.FieldHeaders:
		return m.Headers()
	case webhookevent.FieldPayload:
		return m.Payload()
	case webhookevent.FieldDelivered:
		return m.Delivered()
	case webhookevent.FieldDeliveredAt:
		return m.DeliveredAt()
	case webhookevent.FieldAttempts:
		return m.Attempts()
	case webhookevent.FieldNextRetry:
		return m.NextRetry()
	case webhookevent.FieldStatusCode:
		return m.StatusCode()
	case webhookevent.FieldResponseBody:
		return m.ResponseBody()
	case webhookevent.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhookevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhookevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webhookevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case webhookevent.FieldWebhookID:
		return m.OldWebhookID(ctx)
	case webhookevent.FieldEventType:
		return m.OldEventType(ctx)
	case webhookevent.FieldHeaders:
		return m.OldHeaders(ctx)
	case webhookevent.FieldPayload:
		return m.OldPayload(ctx)
	case webhookevent.FieldDelivered:
		return m.OldDelivered(ctx)
	case webhookevent.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	case webhookevent.FieldAttempts:
		return m.OldAttempts(ctx)
	case webhookevent.FieldNextRetry:
		return m.OldNextRetry(ctx)
	case webhookevent.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case webhookevent.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case webhookevent.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown WebhookEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhookevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhookevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webhookevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case webhookevent.FieldWebhookID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookID(v)
		return nil
	case webhookevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case webhookevent.FieldHeaders:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case webhookevent.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case webhookevent.FieldDelivered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelivered(v)
		return nil
	case webhookevent.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	case webhookevent.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case webhookevent.FieldNextRetry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRetry(v)
		return nil
	case webhookevent.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case webhookevent.FieldResponseBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case webhookevent.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookEventMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, webhookevent.FieldAttempts)
	}
	if m.addstatus_code != nil {
		fields = append(fields, webhookevent.FieldStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhookevent.FieldAttempts:
		return m.AddedAttempts()
	case webhookevent.FieldStatusCode:
		return m.AddedStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhookevent.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	case webhookevent.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhookevent.FieldDeletedAt) {
		fields = append(fields, webhookevent.FieldDeletedAt)
	}
	if m.FieldCleared(webhookevent.FieldHeaders) {
		fields = append(fields, webhookevent.FieldHeaders)
	}
	if m.FieldCleared(webhookevent.FieldPayload) {
		fields = append(fields, webhookevent.FieldPayload)
	}
	if m.FieldCleared(webhookevent.FieldDeliveredAt) {
		fields = append(fields, webhookevent.FieldDeliveredAt)
	}
	if m.FieldCleared(webhookevent.FieldNextRetry) {
		fields = append(fields, webhookevent.FieldNextRetry)
	}
	if m.FieldCleared(webhookevent.FieldStatusCode) {
		fields = append(fields, webhookevent.FieldStatusCode)
	}
	if m.FieldCleared(webhookevent.FieldResponseBody) {
		fields = append(fields, webhookevent.FieldResponseBody)
	}
	if m.FieldCleared(webhookevent.FieldError) {
		fields = append(fields, webhookevent.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookEventMutation) ClearField(name string) error {
	switch name {
	case webhookevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case webhookevent.FieldHeaders:
		m.ClearHeaders()
		return nil
	case webhookevent.FieldPayload:
		m.ClearPayload()
		return nil
	case webhookevent.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	case webhookevent.FieldNextRetry:
		m.ClearNextRetry()
		return nil
	case webhookevent.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case webhookevent.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case webhookevent.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookEventMutation) ResetField(name string) error {
	switch name {
	case webhookevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhookevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webhookevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case webhookevent.FieldWebhookID:
		m.ResetWebhookID()
		return nil
	case webhookevent.FieldEventType:
		m.ResetEventType()
		return nil
	case webhookevent.FieldHeaders:
		m.ResetHeaders()
		return nil
	case webhookevent.FieldPayload:
		m.ResetPayload()
		return nil
	case webhookevent.FieldDelivered:
		m.ResetDelivered()
		return nil
	case webhookevent.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	case webhookevent.FieldAttempts:
		m.ResetAttempts()
		return nil
	case webhookevent.FieldNextRetry:
		m.ResetNextRetry()
		return nil
	case webhookevent.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case webhookevent.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case webhookevent.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.webhook != nil {
		edges = append(edges, webhookevent.EdgeWebhook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhookevent.EdgeWebhook:
		if id := m.webhook; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwebhook {
		edges = append(edges, webhookevent.EdgeWebhook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookEventMutation) EdgeCleared(name string) bool {
	switch name {
	case webhookevent.EdgeWebhook:
		return m.clearedwebhook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookEventMutation) ClearEdge(name string) error {
	switch name {
	case webhookevent.EdgeWebhook:
		m.ClearWebhook()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookEventMutation) ResetEdge(name string) error {
	switch name {
	case webhookevent.EdgeWebhook:
		m.ResetWebhook()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent edge %s", name)
}
